课程主题
	设计模式中的创建型设计模式
	
课程目标
	1.掌握三种工厂模式：简单工厂、工厂方法和抽象工厂
	2.掌握原型模式
	3.掌握构建者模式
	4.掌握单例模式的两种懒汉式写法：双重检查锁和静态内部类
	5.了解并发编程中的可见性、有序性和原子性
	6.了解volatile关键字的作用
	
课程回顾
	面向对象的三大特征：
		封装、继承、多态
		
	面向对象七大设计原则：可维护性和可复用性
		开闭原则：是总纲、最基本原则
		单一职责原则：类如何定义
		接口隔离原则：接口如何定义
		里式替换原则：如何玩继承
		依赖倒置原则：如何玩继承和多态
		合成复用原则：如何处理继承关系和组合/聚合关系
		最少认知原则（迪米特法则）：如何处理类与类的关系
		
课程内容
	设计模式，就是遵循了七大设计原则的具体实现，在每个设计模式中，都有设计原则的一些体现。
	
	分析为何使用创建型设计模式？
		创建型设计模式，都是为了创建实例对象的。
		
		创建实例对象并初始化
			方式1：
			Student stu = new Student(18,"james");
			
			方式2：
			Student stu = new Student();
			stu.setAge(20);
			stu.setName("soso");
	
	
		如果初始化的字段大概100个左右，而且每次初始化需要的字段都一样。但是需要很多该对象。
		如果Student类是通过jar包提供的，而且Student类的属性很多。
			而且也不清楚要构造一个Student对象，需要哪些参数，以及这些参数代表什么意思？
			
		BasicDataSource类由dbcp jar包提供
			
		
		
		创建型设计模式的好处：
		1.使用者不需要关心对象的创建细节，直接由创建型设计模式给使用者一个现成的对象使用。
		2.屏蔽复杂的构造细节
		
		
		注意事项：
			需要使用创建型设计模式创建的实例，一般都是业务Bean，而不是数据Bean。
	
	简单工厂模式
		Spring容器就是通过简单工厂模式去实现的。Spring容器就是管理bean实例的。
		
		也称为上帝工厂模式。只要给它一个字符串，它就可以给你一个对象。
		
		简单工厂存在的问题：
		1.违反开闭原则，不利于扩展和维护
		2.入参不明确
		3.使用简单工厂去实现工厂模式，它会很累
		
		如何去解决简单工厂存在的问题呢？
		1.将对象的名称和对象通过配置文件（XML）进行配置，读取到内存中建立映射关系（Map集合）
		2.入参不明确，可以将入参设置为要查找的对象的类名
		3.通过对象名称，去Map集合查找对象，只需要一行代码就够，所以代码不臃肿。
		
		其实除了以上方式，还有工厂方法可以解决简单工厂存在的问题。
		
	工厂方法模式
		工厂方法，其实就是教使用者先如何建立工厂。如何建工厂呢？通过标准（接口）教给大家。
		
		可以解决的问题：
			当我们需要创建A产品时，只需要根据工厂方法接口，去创建A产品对应的工厂即可。
			当我们需要创建B产品时，只需要根据工厂方法接口，去创建B产品对应的工厂即可。
	
	抽象工厂模式
	
		当我们需要生产的产品，是一个产品家族，那么使用工厂方法模式，就不够用了，需要使用抽象工厂模式。
		
		抽象工厂模式和工厂方法模式的区别在于：
		1.抽象工厂模式，每个工厂可以生产多种产品，当然这些产品是一个家族（品牌）
		2.工厂方法模式，每个工厂只生产一种产品
		
		需求：
		1.小米需要生产小米手机，包含小米电池、小米显示屏、小米处理器等零件（产品）
		2.华为需要生产华为手机，包含华为电池、华为显示屏、华为处理器等零件（产品）
	
	工厂模式总结：
		1.如果要生产的产品的类型很多的话，其实建议使用简单工厂
		2.只有要生产的产品类型不多的情况下，才考虑使用工厂方法模式和抽象工厂模式
		
	
	原型模式
		其实就是通过复制、克隆去重新创建一个一样的对象。
	
		原型模式中包括浅复制（浅拷贝）和深复制（深拷贝）两种实现方式
		浅复制指的只是对基本类型和String类型进行复制，没有对引用类型进行复制
		深复制指的就是对象的所有属性，都完全是新的，和原有的对象没有关系。
	构建者模式
		如果说工厂模式是批量生产产品，那么构建者模式就是可以私人定制产品（产品的属性可以随意指定）
		一般来说，读取配置文件产生对象的时候，最好选择构建者模式来构建对象，因为配置文件中配置的信息可有可无。
		
		角色：
			产品角色：要构建的对象
			导演角色：导演该产品如何构建。
			构建者角色：提供构建表示（属性外露）
		
		
	
	单例模式
		两种实现方式：懒汉式、饿汉式
		
		单例模式的特征：
		1.构造私有
		2.通过静态私有的成员变量去声明实例对象
		3.通过静态公开的成员方法去获取实例对象
		
		如何判断存在线程安全问题？
		1.是否存在共享数据（存储数据的成员变量）
		2.是否存在多线程
		3.是否是非原子性操作
		
		饿汉式写法：
		public Student{
		
			private Student(){}
			//static修饰的变量在new对象时，不存在多线程问题
			private static Student stu = new Student();
			
			public static getInstance(){
				return stu;
			}
		}
		
		//JVM通过类加载器去加载一个类的时候，默认针对该流程是加锁的，也就是线程安全的。
		//类加载的时候，会初始化类的静态成员，其实就是调用clinit()方法
		
		
		懒汉式写法：
			1.双重检查锁方式
			2.静态内部类方式
			3.枚举方式