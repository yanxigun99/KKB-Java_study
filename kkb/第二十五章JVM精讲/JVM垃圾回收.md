# JVM-垃圾回收

举个例⼦抛砖引⽟，下⾯这些问题是⾯试过程当中基本上都会常问的，不管是应届毕业⽣还是有丰 富⼯作经验的同学。

Java有个东⻄叫垃圾收集器，它是做什么⽤的，为什么要有； GC的主要职能是什么；

GC怎么检测垃圾； GC怎么回收垃圾； G1有什么优点吗；

......

另外现实企业级Java应⽤开发、维护中，有时候我们会碰到下⾯这些问题：

OutOfMemoryError，内存不⾜内存泄露

年轻代、年⽼代如何选择垃圾收集器

......

这些问题在⽇常开发、维护中可能被很多⼈忽视（⽐如有的⼈遇到上⾯的问题只是重启服务器或者 调⼤内存，⽽不会深究问题根源），但能够理解并解决这些问题是Java程序员进阶的必备要求。

# 1. 垃圾回收相关概述

## 1.1 什么是垃圾

垃圾指的是在运⾏程序中没有**任何指针\****(或引⽤***\*)指向**的对象，这个对象就是需要回收的垃圾。 如果不及时对内存中的垃圾进⾏清理，那么这些垃圾对象所占⽤的内存空间⼀直保留到应⽤程序结束，被保 留的空间⽆法被其他对象使⽤。可能会导致内存溢出。

对于⾼级语⾔来说，如果不进⾏垃圾回收，因为不断分配内存⽽不进⾏回收，内存早晚会被消耗完。除了释放没有⽤的对象，垃圾回收也可以清除内存⾥的碎⽚，碎⽚整理将所占⽤的堆内存移动到堆 的⼀端，便于JVM将整理出内存分配给新的对象。特别是⼤的对象，可能需要⼀块连续的⼤的内存空间。

## 1.2 什么是GC

**垃圾回收（\****Garbage Collection）**作为⼀⻔实⽤⽽⼜重要的技术，可以说拯救了⽆数苦于内存管理的程序员。尽管很多⼈认为，GC技术⾛进⼤众的视野，多是源于Java语⾔的崛起，但是GC技术本身却相当的古⽼。早在1960年，Lisp之⽗John McCarthy已经在其论⽂中发布了GC算法，Lisp语⾔也是第

⼀个实现GC的语⾔。

在 GC 最开始设计时，⼈们在思考 GC 时就需要完成三件事情：

#### 1. 哪些内存需要进⾏回收？

1. **什么时候对这些内存进⾏回收？**

#### 3. 如何进⾏回收？

垃圾回收与“java⾯向对象编程”⼀样是java语⾔的特性之⼀；它与“ c/c++语⾔”最⼤区别是不⽤⼿动调⽤ free() 和 delete() 释放内存。GC 主要是处理 **Java堆\****Heap** ，也就是作⽤在 Java虚拟机 ⽤于存放对象实例的内存区域，（Java堆⼜称为GC堆）。JVM能够完成**内存分配和内存回收**，虽然降低了开发难 度，避免了像C/C++直接操作内存的危险。但也正因为太过于依赖JVM去完成内存管理，导致很多Java 开发者不再关⼼内存分配，导致很多程序低效、耗内存问题。因此开发者需要主动了解GC机制，充分利

⽤有限的内存的程序，才能写出更⾼效的程序。

垃圾回收机制仍然在不断的迭代中，不同的场景对垃圾回收提出了新的挑战，这当然也是⾯试中的热 点。例如下：

阿⾥：

什么时候触发垃圾回收？ JVM有哪些垃圾回收器？ 讲讲垃圾回收算法？

京东：

常⻅的垃圾收集器有哪些，以及各⾃的优缺点？ 重点讲下CMS和G1 ？

## 1.3

## STW

**Stop-the-World**,简称STW，指的是GC事件发⽣过程中，会产⽣应⽤程序的停顿。停顿是产⽣时整个应⽤程序线程会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。Stop-the-world意 味着 JVM由于要执⾏GC⽽停⽌了应⽤程序(⽤户线程、⼯作线程)的执⾏，并且这种情形会在任何⼀种GC 算法中发⽣。当Stop-the-world发⽣时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。

STW事件和采⽤哪款GC⽆关，所有的GC都有这个事件。哪怕是G1也不能完全避免Stop-the-world

情况发⽣，只能说垃圾回收器越来越优秀，回收效率越来越⾼，尽可能缩短了暂停时间。

STW是JVM在**后台⾃动发起和⾃动完成**的，在⽤户不可⻅的情况下，把⽤户正常的⼯作线程全部停

掉。

随着应⽤程序越来越复杂，每次GC不能保证应⽤程序的正常运⾏。⽽经常造成STW的GC跟不上实

际的需求，所以才需要不断对GC进⾏优化。事实上，GC优化很多时候就是指**减少\****Stop-the-world***\*发⽣的时间，从⽽使系统具有⾼吞吐 、低停顿的特点**。

## 1.4 并⾏与并发

#### 并发(Concurrent)

在操作系统中，是指⼀个时间段中有个⼏个程序都处于已启动运⾏到运⾏完毕之间，且这⼏个程序 都是在同⼀个处理器上运⾏。

并发并不是真正意义上的"同时进⾏"，只是CPU把⼀个时间段划分成⼏个时间⽚段(时间区间)，然 后在这⼏个时间区间之间来回切换，由于CPU处理的速度⾮常快，只要时间间隔处理得当，即可让⽤户 感觉是多个应⽤程序是同时进⾏的。

#### 并⾏(Parallel)

当系统有⼀个以上CPU时，当⼀个CPU执⾏⼀个进程时，另外⼀个CPU可以执⾏另⼀个进程，两个进程 互不抢占CPU资源，可以同时进⾏，我们称之为并⾏(Parallel)；

其实决定并⾏的因素不是CPU的数量，⽽是CPU的核⼼数量，⽐如⼀个CPU多个核可以并⾏。 适合科学计算，后台处理等弱交互场景。

#### ⼆者对⽐：

并发，**指的是多个事情，在同⼀时间段内同时发⽣了**。 并⾏，**指的是多个事情，在同⼀时间点上同时发⽣了**。

并发的多个任务之间是互相抢占资源的。并⾏的多个任务之间是不互相抢占资源的。

只有在多个CPU或者⼀个CPU多核的情况中，才会发⽣并⾏。 否则，看似同时发⽣的事情，其实都是并发执⾏的。

## 1.5

## System.gc()

在默认情况下，通过System.gc()或者Runtime getRuntime().gc()的调⽤，**会显示触发\****Full GC**，同时对⽼年代和新⽣代进⾏回收，尝试释放被丢弃对象的占⽤的内存。

然⽽System.gc()调⽤附带⼀个免责声明，**⽆法保证对垃圾收集器的调⽤**。

JVM实现者可以通过System.gc()调⽤在决定JVM的GC⾏为。⽽⼀般情况下，垃圾回收应该是⾃动进

⾏的，**⽆须⼿动触发，否则就太过于麻烦了**。在⼀些特殊情况下，如我们正在编写⼀个性能基准，我们 可以在运⾏之间调⽤System.gc()。

## 1.6 安全点与安全区域

#### 安全点(safepoint)

程序执⾏时并⾮在所有的地⽅都能停顿下来开始执⾏GC，只有在特定的位置才能停顿下来开始

GC，这些位置称为"安全点(safepoint)"。

Safe Point的选择很重要，**如果太少可能导致\****GC***\*等待的时间太⻓，如果太频繁可能导致运⾏时的性能问题。**⼤部分指令的执⾏时间都⾮常短暂，通常会根据"**是否具有让程序⻓时间执⾏的特征**"为标准。

⽐如：选择⼀些执⾏时间较⻓的指令作为Safe Point，如**⽅法调⽤、循环跳转和异常跳转**等。

如何在GC发⽣时，检查所有线程都跑到最近的安全点停顿下来呢？

**抢先式中断**：(⽬前没有虚拟机采⽤)

⾸先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。

#### 主动式中断：

设置⼀个中断标志，各个线程运⾏到Safe Point的时候主动轮询这标志，如果中断标志为真，则将⾃⼰进⾏中断挂起。

#### 安全区域(Safe Region)

SafePoint机制保证了程序执⾏时，在不太⻓的时间内就会遇到可进⼊GC的Safepoint。但是程 序"不执⾏"的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程⽆法响应JVM的中断请

求，"⾛"到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。

**安全区域是在在⼀段代码⽚段中，对象的引⽤关系不会发⽣变化，在这个区域中的任何位置开始\****GC***\*都是** **安全的。**我们也可以把Safe Region看做是被扩展了的Safepoint。

#### 实际执⾏时：

1、当线程运⾏到Safe Region的代码是，⾸先标识已经进⼊了Safe Region，如果这段时间内发⽣GC， JVM会忽略标识为Safe Region状态的线程。

2、当线程即将离开Safe Region时，会检测JVM是否已经完成GC，如果完成了，则继续运⾏，否则线程必须等到知道收到可以安全离开Safe Region 的信号为⽌。

## 1.7 GC分类

JVM在进⾏回收时，是针对不同的内存区域进⾏回收的，⼤多数的回收指的是对新⽣代的回收。

针对HotSpot VM的实现，它⾥⾯的GC其实准确分类只有两⼤种： Partial GC：并不收集整个GC堆的模式。其中⼜分为

新⽣代的回收：(Minor GC/Young GC),只收集新⽣代的GC

⽼年代的回收：(Major GC/Old GC),只收集⽼年代的GC。

⽬前只有CMS的concurrent collection是这个模式，只收集⽼年代。Mixed GC：收集整个young gen以及部分old gen的GC。

只有G1有这个模式。

Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。

Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年， 外界对各种名词的解读已经完全混乱了，当有⼈说“major GC”的时候⼀定要问清楚他想要指的是上

⾯的full GC还是old GC。

约定: 新⽣代/新⽣区/年轻代 养⽼区/⽼年区/⽼年代/年⽼代 永久区/永久代

从次数上讲：

频繁收集年轻代较少收集⽼年代基本不动⽅法区

## 1.8 GC触发条件

最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是： 年轻代(Minor GC)触发条件：

⼀般情况下，所有新⽣成的对象⾸先都是放在新⽣代的。新⽣代内存按照 8:1:1 的⽐例分为⼀

个eden区和两个survivor(from survivor，to survivor)区，⼤部分对象在Eden区中⽣成。

在进⾏垃圾回收时，先将eden区存活对象复制到from survivor区，然后清空eden区，当这个from survivor区也满了时，则将eden区和from survivor区存活对象复制到to survivor区，然后清空eden和这个from survivor区，此时from survivor区是空的，然后交换from survivor区和to survivor区的⻆⾊（即下次垃圾回收时会扫描Eden区和to survivor区），即保持from survivor区为空，如此往复。

特别地，当to survivor区也不⾜以存放eden区和from survivor区的存活对象时，就将存活对象直接存放到⽼年代。如果⽼年代也满了，就会触发⼀次FullGC，也就是新⽣代、⽼年代都进⾏回 收。注意，新⽣代发⽣的GC叫做MinorGC，MinorGC发⽣频率⽐较⾼，不⼀定等 Eden区满了才触发。

Minor GC触发⽐较频繁，⼀般回收速度也是⽐较快的。Minor GC会引发STW，暂停⽤户线程，等待垃圾回收完毕后，⽤户线程才会恢复。

⽼年代(Major GC)触发条件：

- 由Eden区、from survivor区向to survivor区复制时，对象⼤⼩⼤于to survivor可⽤内存，则把该对象转存到⽼年代，会先尝试触发Minor GC，如果之后空间还是不⾜，则会触发Major GC。

(2) 如果Major GC后还是不⾜ 就会OOM。

- 发⽣Major GC，通常伴随Minor GC，但这并不是绝对的,Parallel Scavage这种收集器就有直接进⾏Major GC的策略过程。

说明：Major GC的速度⼀般会⽐Minor GC的速度慢10倍以上。FULL GC触发条件：

- gc()⽅法的调⽤

此⽅法的调⽤是建议JVM进⾏Full GC,虽然只是建议⽽⾮⼀定,但很多情况下它会触发 Full GC,从⽽增加Full GC的频率,也即增加了间歇性停顿的次数。建议能不使⽤此⽅法就别使⽤，让虚拟机⾃⼰去管理它的内存，可通过通过-XX:+DisableExplicitGC来禁⽌RMI（Java远程⽅法调⽤）调⽤System.gc。

- ⽼年代空间不⾜

⽼年代空间只有在新⽣代对象转⼊及创建为⼤对象、⼤数组时才会出现不⾜的现象，当执⾏ Full GC后空间仍然不⾜，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新

⽣代多存活⼀段时间及不要创建过⼤的对象及数组。

- ⽅法区空间不⾜

JVM规范中运⾏时数据区域中的⽅法区，在HotSpot虚拟机中⼜被习惯称为永⽣代或者永⽣区，Permanet Generation中存放的为⼀些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调⽤的⽅法较多时，Permanet Generation可能会被占满，在未配置为采⽤CMS GC的情况下也会执⾏Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：

java.lang.OutOfMemoryError: PermGen space

为避免Perm Gen占满造成Full GC现象，可采⽤的⽅法为增⼤Perm Gen空间或转为使⽤CMS GC。

- 通过Minor GC后进⼊⽼年代的平均⼤⼩⼤于⽼年代的可⽤内存

如果发现统计数据说之前Minor GC的平均晋升⼤⼩⽐⽬前old gen剩余的空间⼤，则不会触发Minor GC⽽是转为触发full GC

- 由Eden区、from survivor区向to survivor区复制时，对象⼤⼩⼤于To Space可⽤内存，则把该对象转存到⽼年代，且⽼年代的可⽤内存⼩于该对象⼤⼩

# 2. 检测垃圾

在堆⾥放着⼏乎所有的java对象实例，在GC执⾏垃圾回收之前，⾸先需要区分出内存中哪些是存活 对象，哪些是已经死亡的对象，**只有被标记为已经死亡的对象，\****GC***\*才会在执⾏垃圾回收**，释放掉其所占

⽤的内存空间，因此这个过程我们可以称为**垃圾标记阶段**。

那么在JVM中究竟是如何标记⼀个对象是死亡的呢？简单地说，当⼀个对象已经不再被任何的存活 对象继续引⽤是，就可以判断为已经死亡。

判断对象存活⼀般有两种⽅式：**引⽤计数算法和可达性分析算法**。

## 2.1 引⽤计数算法（Reference Counting）

引⽤计数算法：通过判断对象的引⽤数量来决定对象是否可以被回收。

引⽤计数算法是垃圾收集器中的早期策略。在这种⽅法中，堆中的每个对象实例都有⼀个引⽤计数。当⼀个对象被创建时，且将该对象实例分配给⼀个引⽤变量，该对象实例的引⽤计数设置为 1。当任何其它变量被赋值为这个对象的引⽤时，对象实例的引⽤计数加 1（a = b，则b引⽤的对象实例的计数器加 1），但当⼀个对象实例的某个引⽤超过了⽣命周期或者被设置为⼀个新值时，对象实例的引⽤计数减 1。特别地，当⼀个对象实例被垃圾收集时，它引⽤的任何对象实例的引⽤计数器均减 1。任何引⽤计数为0的对象实例可以被当作垃圾收集。

引⽤计数收集器可以很快的执⾏，并且交织在程序运⾏中，对需要不被⻓时间打断的实时环境⽐较 有利，但其很难解决对象之间相互循环引⽤的问题。如下⾯示例所示，对象objA和objB之间的引⽤计数 永远不可能为 0，那么这两个对象就永远不能被回收。

上述代码最后⾯两句将objA和objB赋值为null，也就是说objA和objB指向的对象已经不可能再被访 问，但是由于它们互相引⽤对⽅，导致它们的引⽤计数器都不为 0，那么垃圾收集器就永远不会回收它们。

#### 优点：

实现简单，垃圾对象便于标识； 判定效率⾼，回收没有延迟性。

#### 缺点：

它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。

每次赋值都需要更新计数器，伴随这加法和减法操作，这就增加了时间开销。

#### 致命缺陷，即⽆法处理循环引⽤的情况。导致在java的垃圾回收器中没有使⽤这类算法。

**扩展知识点**

java并没有选择引⽤计数，是因为其存在⼀个基本的难题，也就是很难处理循环引⽤关系。引⽤计 数算法，是很多语⾔的资源回收选择，例如python，它更是同时⽀持引⽤计数和垃圾收集机制。Python如何解决循环引⽤？

⼿动解除：很好理解，就是在合适的时机，解除引⽤关系。

使⽤弱引⽤weakref，weakref是Ptyhon提供的标准库，旨在解决循环引⽤。

## 2.2 可达性分析算法（Rearchability Analysis）

### 2.2.1 概述

相对于引⽤计数算法，这⾥的可达性分析是java、c# 选择的。这种类型的垃圾收集通常也叫**追踪性\****垃圾收集***\*(Tracing Garbage Collection)**

可达性分析算法是通过判断对象的引⽤链是否可达来决定对象是否可以被回收。

可达性分析算法是从离散数学中的图论引⼊的，程序把所有的引⽤关系看作⼀张图，通过⼀系列的 名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所⾛过的路径称为引⽤链

（Reference Chain）。当⼀个对象到 GC Roots 没有任何引⽤链相连（⽤图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可⽤的，如下图所示。

在java中，可作为 GC Root 的对象包括以下⼏种：

- 虚拟机栈(栈帧中的局部变量表)中引⽤的对象；

⽐如:各个线程被调⽤的⽅法中使⽤的参数、局部变量等。

- ⽅法区中类静态属性引⽤的对象；

⽐如:java类的引⽤类型静态变量

3) ⽅法区中常量引⽤的对象；

⽐如:字符串常量池(String Table)⾥的引⽤4)本地⽅法栈中Native⽅法引⽤的对象；

5) 所有被同步锁synchronized持有的对象；

- java虚拟机内部的引⽤；

⽐如:基本数据类型对应的Class对象，⼀些异常对象(如:NullPointerException、

OutOfMemoryError)，系统类加载器

- 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

由于Root采⽤栈⽅式存放变量和指针，所以如果⼀个指针，它**保存了堆内存⾥⾯的对象地址，但是**

**⾃⼰⼜不存放在堆内存⾥⾯**，那它就是⼀个Root。

### 2.2.2 代码演示

下⾯以⼀段代码来简单说明⼀下

⾸先，类加载器加载RearchabilityTest类，会初始化静态变量a，将常量引⽤指向常量池中的字符串，完成RearchabilityTest类的加载； 然后main⽅法执⾏，main⽅法会⼊虚拟机⽅法栈，执⾏main⽅法会在堆中创建A的对象，并赋值给局部变量innerA。

此时GC Roots状态如下：

当main⽅法执⾏完出栈后，变为：

第三个对象已经没有引⽤链可达GC Root。此时，第三个对象被第⼀次标记。

### 2.2.3 对象的finalization机制

java提供了对象终⽌(finalization)机制来允许开发⼈员提供对象销毁之前的⾃定义处理逻辑。 当垃圾回收器发现没有引⽤指向⼀个对象，即:垃圾回收次对象之前，总会先调⽤这个对象的

finalize()⽅法。

finalize()⽅法允许在⼦类中被重写，**⽤于在对象被回收时进⾏资源释放**。通常在这个⽅法张中进⾏

⼀些资源释放和清理的⼯作，⽐如关闭⽂件、套接字和数据库连接等。

从功能上来说，finalize()⽅法与C++中的析构函数⽐较类似，但是java采⽤的是基于垃圾回收器的

⾃动内存管理机制，所以finalize()⽅法在本质上不同于C++中的析构函数。

**永远不要主动调⽤某个对象的\****finalize()***\*⽅法**，应该交给垃圾回收机制调⽤。理由也包含下⾯三点:

在finalize()时可能会导致对象复活

finalize()⽅法的执⾏时间是没有保障的，它完全由GC线程决定，极端情况下，若不发⽣GC，则finalize()⽅法将没有执⾏机会

⼀个糟糕的finalize()会严重影响GC的性能

由于finalize()⽅法的存在，**虚拟机中的对象⼀般处于三种可能的状态。**

如果从所有的根节点都⽆法访问到某个对象，说明对象已经不再使⽤了。⼀般来说，该对象需要 备回收。但事实上，也并⾮是"⾮死不可"的。这时候他们暂时处于"缓刑"阶段。⼀个⽆法触及的对象有 可能在某⼀条件下"复活"⾃⼰，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象 可能的三种状态。如下：

**可触及的**:从根节点开始，可以到达这个对象。

**可复活的\****:**对象的所有引⽤都被释放，但是对象有可能在finalize()中复活。

**不可触及的\****:**对象的finalize()被调⽤，并且没有复活，那么就会进⼊不可触及的状态。不可触及的 对象不可能被复活，因为**finalize()***\*只会被调⽤⼀次**。

以上3种状态中，是由于finalize()⽅法的存在，进⾏的区分。只有在对象不可触及是才可以被回收。

判定⼀个对象objA是否可回收，⾄少要经历两次标记过程：

1. 如果对象objA到GC Roots没有引⽤链，则进⾏第⼀次标记。
2. 进⾏筛选，判断此对象是否执⾏finalize()⽅法
   - 如果对象objA没有重写finalize()⽅法，或者finalize()已经被虚拟机调⽤过，则虚拟机视为"没 有必要执⾏"，objA被判定是不可触及的。

- 如果对象objA重写了finalize()⽅法，且还未执⾏过，那么objA会被插⼊到F-Queue队列中，有

⼀个虚拟机⾃动创建的、低优先级Finalizer线程触发器finalize()⽅法执⾏。

- finalize()⽅法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进⾏第⼆次标记。如果objA在finalize()⽅法中与引⽤链上的任何⼀个对象建⽴了联系，那么在第⼆次标记是，objA会 被移除"即将回收"集合。之后，对象会再次出现没有引⽤存在的情况。在这个情况下，finalize⽅法不会 被再次调⽤，对象会直接变成不可触及的状态，也就是说，**⼀个对象的\****finalize()***\*⽅法只会被调⽤⼀次**。

}

public static void main(String[] args) { try {

obj = new CanReliveObj(); obj = null;

System.gc(); System.out.println("第1次 gc");

//因为 finalizer线程优先级很低，暂停2s，以等待它

Thread.sleep(2000); if(obj == null){

System.out.println("obj is dead");

}else {

System.out.println("obj is still alive");

}

System.out.println("第2次 gc");

//下⾯这段代码与上⾯完全相同，但是这次却⾃救失败了

obj = null; System.gc();

//因为 finalizer线程优先级很低，暂停2s，以等待它

Thread.sleep(2000); if(obj == null){

System.out.println("obj is dead");

}else {

System.out.println("obj is still alive");

}

} catch (InterruptedException e) { e.printStackTrace();

}

}

}

### 2.2.4 使⽤MAT查看GC Roots

MAT是⼀个强⼤的内存分析⼯具，可以快捷、有效地帮助我们找到内存泄露，减少内存消耗分析⼯

具。

MAT是Memory Analyzer tool的缩写，是⼀种快速，功能丰富的Java堆分析⼯具，能帮助你查找内

存泄漏和减少内存消耗。很多情况下，我们需要处理测试提供的hprof⽂件，分析内存相关问题，那么

MAT也绝对是不⼆之选。

MAT安装有两种⽅式，⼀种是以eclipse插件⽅式安装，⼀种是独⽴安装。在MAT的官⽅⽂档中有相 应的安装⽂件下载，下载地址为：https://www.eclipse.org/mat/downloads.php

# 3 垃圾收集算法

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执⾏垃圾回收，释放掉⽆⽤对 象所占⽤的内存空间，以便有⾜够的可⽤内存空间为新对象分配内存。

⽬前在JVM中⽐较常⻅的三种垃圾回收算法是**标记\****-***\*清除算法\****(Mark-Sweep)***\*、复制算法**

**(Copying)\****、标记***\*-\****压缩算法***\*(Mark-Compact)**。

- **标记清除算法**

标记-清除算法(Mark-Sweep)是⼀种⾮常基础和常⻅的垃圾收集算法，该算法被J.McCarthy等⼈在

1960年提出并应⽤于Lisp语⾔。

清除算法分为**标记和清除**两个阶段。该算法⾸先从根集合进⾏扫描，对存活的对象对象标记，标记 完毕后，再扫描整个空间中未被标记的对象并进⾏回收，如下图所示。

标记:GC从引⽤根节点开始遍历，**标记所有被引⽤的对象**。⼀般是在对象的Header中记录。

清除:GC对堆内存从头到尾进⾏线性的遍历，如果发现某个对象再其Header中没有标记为可达对 象，则将其回收。

标记-清除算法的主要不⾜有：

效率问题：标记和清除两个过程的效率都不⾼；

在进⾏GC的时候，需停⽌整个应⽤程序，导致⽤户体验性差；

空间问题：标记-清除算法不需要进⾏对象的移动，并且仅对不存活的对象进⾏处理，因此标记清除之后会产⽣⼤量不连续的内存碎⽚，空间碎⽚太多可能会导致以后在程序运⾏过程中需要分配较

⼤对象时，⽆法找到⾜够的连续内存⽽不得不提前触发另⼀次垃圾收集动作。

## 3.2 复制算法

为了解决标记-清除算法在垃圾收集效率⽅⾯的缺陷， M. L. Minsky 于 1963 年发表了著名的论

⽂“⼀种使⽤双存储区的 Lisp 语⾔垃圾收集器（ A LISP Garbage Collector Algorithm Using Serial Secondary Storage ）”。 M. L. Minsky 在该论⽂中描述的算法被⼈们称为复制算法(Copying)，它也被

1. L. Minsky 本⼈成功地引⼊到了 Lisp 语⾔的⼀个实现版本中。

复制算法别出⼼裁地将堆空间**⼀分为⼆**，并使⽤简单的复制操作来完成垃圾收集⼯作，这个思路相 当有趣。

复制算法将可⽤内存按容量划分为⼤⼩相等的两块，每次只使⽤其中的⼀块。当这⼀块的内存⽤完 了，就将还**存活着的对象复制**到另外⼀块上⾯，然后再把已使⽤过的内存空间⼀次清理掉。这种算法适

⽤于对象存活率低的场景，⽐如新⽣代。这样使得每次都是对整个半区进⾏内存回收，内存分配时也就 不⽤考虑内存碎⽚等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运⾏⾼效。该算 法示意图如下所示：

#### 应⽤场景:

事实上，现在商⽤的虚拟机都采⽤这种算法来回收新⽣代。因为研究发现，新⽣代中的对象每次回 收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。不适合存活量对象⽐较 多的场景。

#### 优点:

没有标记和清除过程，实现简单，运⾏⾼效

复制过去以后保证空间的连续性，不会出现"碎⽚" 问题。

**缺点**：

此算法的缺点也是很明显，就是需要两倍的内存空间

如果对象的存活率很⾼，我们可以极端⼀点，假设是100%存活，那么我们需要将所有对象都复制

⼀遍，并将所有引⽤地址重置⼀遍。**复制这⼀⼯作所花费的时间，在对象存活率达到⼀定程度时，** **将会变的不可忽视**。

## 3.3 标记整理算法

复制收集算法在对象存活率较⾼时就要进⾏较多的复制操作，效率将会变低。更关键的是，如果不 想浪费50%的空间，以应对被使⽤的内存中所有对象都100%存活的极端情况，所以在⽼年代⼀般不能直接选⽤这种算法。

标记-整理算法或标记-压缩算法(Mark-Compact)是标记-清除算法和复制算法的有机结合。把标记- 清除算法在内存占⽤上的优点和复制算法在执⾏效率上的特⻓综合起来，这是所有⼈都希望看到的结果。不过，两种垃圾收集算法的整合并不像 1 加 1 等于 2 那样简单，我们必须引⼊⼀些全新的思路。1970 年前后， G. L. Steele ， C. J. Cheney 和 D. S. Wise 等研究者陆续找到了正确的⽅向，标记-整理算法的轮廓也逐渐清晰了起来。

标记-整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进⾏清理，⽽是让所有存活的对象都向⼀端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾 回收算法适⽤于对象存活率⾼的场景（⽼年代），其作⽤原理如下图所示。

标记-整理算法与标记-清除算法最显著的区别是：**标记\****-***\*清除算法不进⾏对象的移动**，并且仅对不存 活的对象进⾏处理；⽽**标记整理算法会将所有的存活对象移动到⼀端**，并对不存活对象进⾏处理，因此 其不会产⽣内存碎⽚。标记-整理算法的作⽤示意图如下：

标记-整理算法的最终效果等同于标记-清除算法执⾏完成后，再进⾏⼀次内存碎⽚整理，因此，也 可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。

⼆者的本质差异在于标记-清除算法是⼀种⾮移动式的回收算法，标记-压缩是移动式的。是否移动 回收后的存活对象是⼀项优缺点并存的⻛险决策。

可以看到，标记的存活对象将会被整理，按照内存地址依次排列，⽽未被标记的内存会被清理掉。 如此⼀来，当我们需要给新对象分配内存时，JVM只需要持有⼀个内存的起始地址即可，这⽐维护⼀个 空闲列表显然少了许多开销。

#### 优点：

消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持 有⼀个内存的起始地址即可。

消除了复制算法当中，内存两倍的⾼额代价。

#### 缺点:

从效率上来说，标记-整理算法要低于复制算法。

移动对象的同时，如果对象被其他对象引⽤，则还需要调整引⽤的地址。 移动过程中，需要全程暂停⽤户应⽤程序。即：STW

#### 对⽐三种算法

**标记\****-***\*清除**

**标记\****-***\*压缩**

**复制算法**

速度

中等

最慢

最快

空间开销

少(但会堆积碎⽚)

少(不堆积碎⽚)

通常需要活对象的2倍⼤⼩(不堆积碎⽚)

移动对象

否

是

是

效率上来说，复制算法是最快的，但是却浪费了太多的内存。

⽽为了兼顾上⾯提到的三个指标，**标记\****-整理算法相对来说更平滑⼀些**，但是效率上不尽如⼈意， 它⽐复制算法多了⼀个标记的阶段，⽐标记-清除多了⼀个整理内存的阶段。

## 3.4 分代收集算法

前⾯所有这些算法中，并没有⼀种算法可以完全替代其他算法，它们都具有⾃⼰独特的优势和特 点。分代收集算法应运⽽⽣。

分代收集算法(Generational Collecting)，是基于这样的⼀个事实:不同的对象⽣命周期是不⼀样的。因此不同⽣命周期的对象可以采取不同的收集⽅式，以便提⾼回收效率。⼀般是把java堆分成新⽣ 代和⽼年代，这样就可以根据各个年代的特点使⽤不同的回收算法，以提⾼垃圾回收的效率。

### 3.4.1 对象分配⼀般过程

为新对象分配内存是⼀件⾮常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在 哪⾥分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执⾏完内存回收 后是否会在内存空间中产⽣内存碎⽚。

1. new 的对象先放在Eden区。此区有⼤⼩限制。
   1. 当Eden区空间填满时，程序⼜需要创建对象，JVM的垃圾回收器将对Eden区进⾏垃圾回收(Minor GC)，将Eden区中的不再被其他对象所引⽤的对象进⾏销毁。再加载新的对象放到Eden区。
2. 然后将Eden区中的剩余对象移动到Survivor 0区。
3. 如果再次触发垃圾回收，此时上次幸存下来的放到Survivor 0区的，这次如果没有回收，就会放到Survivor 1区。
4. 如果再次经历垃圾回收,此时会重新放回Survivor 0区，接着再去Survivor 1区。
5. 什么时候去⽼年代呢？可以设置次数。默认是15次。可以设置参数: -XX:MaxTenuringThreshold=

进⾏设置。

1. 在⽼年代，相当悠闲。当养⽼区内存不⾜是，再此触发GC：Major GC，进⾏⽼年代的内存清理。
2. 若⽼年代执⾏了 Major GC 之后发现依然⽆法进⾏对象的保存，就会产⽣OOM异常。

java.lang.OutOfMemoryError: Java Heap Space

#### 总结：

针对幸存者S0、S1区的总结：复制之后有交换，谁空谁是to。

关于垃圾回收：频繁在新⽣代收集，很少在⽼年代收集，⼏乎不在永久代/元空间收集。

### 3.4.2 对象分配的特殊情况

- **各分代特点**

1、新⽣代（Young Generation）

#### 新⽣代特点：区域相对⽼年代较⼩，对象⽣命周期短、存活率低，回收频繁。

这种情况适合复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象⼤⼩有关， 因此很适⽤于年轻代的回收。⽽复制算法内存利⽤率不⾼的问题，通过hotspot中的两个survivor的设计 得到缓解。

2、⽼年代（Old Generation）

#### ⽼年代特点:区域较⼤，对象⽣命周期⻓、存货效率⾼，回收不及年轻代频繁

这种情况存在⼤量存活率⾼的对象，复制算法明显变得不合适。⼀般是由标记-清除或者是标记-清 除与标记-整理的混合实现。

标记(Mark)阶段的开销与存活对象的数量成正⽐；

清除(Sweep)阶段的开销与所管理区域的⼤⼩成正⽐相关； 压缩(Compact)阶段的开销与存活对象的数据成正⽐。

⽼年代存放的都是⼀些⽣命周期较⻓的对象，就像上⾯所叙述的那样，在新⽣代中经历了N次垃圾 回收后仍然存活的对象就会被放到⽼年代中。此外，⽼年代的内存也⽐新⽣代⼤很多(⼤概⽐例是1:2)， 当⽼年代满时会触发Major GC(Full GC)，⽼年代对象存活时间⽐较⻓，因此FullGC发⽣的频率⽐较低。

3、 永久代（Permanent Generation）

永久代主要⽤于存放静态⽂件，如Java类、⽅法等。永久代对垃圾回收没有显著影响，但是有些应

⽤可能动态⽣成或者调⽤⼀些class，例如使⽤反射、动态代理、CGLib等bytecode框架时，在这种时候 需要设置⼀个⽐较⼤的永久代空间来存放这些运⾏过程中新增的类。

分代的思想被现有的虚拟机⼴发使⽤。**⼏乎所有的垃圾回收器都区分新⽣代和⽼年代。**

## 3.5 增量式垃圾回收

增量式垃圾回收并不是⼀个新的回收算法, ⽽是结合之前算法的⼀种新的思路.

之前说的各种垃圾回收, 都需要暂停程序, 执⾏GC, 这就导致在GC执⾏期间, 程序得不到执⾏. 因此出现了增量式垃圾回收, 它并不会等GC执⾏完, 才将控制权交回程序, ⽽是⼀步⼀步执⾏, 跑⼀点, 再跑⼀点, 逐步完成垃圾回收, 在程序运⾏中穿插进⾏. 极⼤地降低了GC的最⼤暂停时间。

总体来说，增量式垃圾回收算法的基础仍是传统的标记-清除和复制算法。增量式垃圾回收通过对 线程间冲突的妥善处理，允许垃圾收集线程以分阶段的⽅式完成标记、清理或复制⼯作。

#### 缺点：

使⽤这种⽅式，由于在垃圾回收过程中，间断性地还执⾏了应⽤程序代码，所以能减少系统的停顿 时间。但是，因为线程切换和上下⽂转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的 下降。

## 3.6 分区算法

⼀般来说，在相同条件下，堆空间越⼤，⼀次GC时所需要的时间也就越⻓，有关GC产⽣的停顿也 越⻓。为了更好的控制GC产⽣的停顿时间，将⼀块⼤的内存区域分割成多个⼩块，根据⽬标的停顿时 间，每次合理回收若⼲个⼩区件，⽽不是整个堆空间，从⽽减少⼀次GC所产⽣的停顿。

分代算法将按照对象的⽣命周期⻓短划分成两个部分，分区算法将整个堆空间划分成连续的不同⼩ 区间。

每⼀个⼩区间都独⽴使⽤，独⽴回收。这种算法的好处是可以控制⼀次回收多个⼩区间。

注意：这些都只是基本的算法思路，实际GC实现过程要复杂得多，⽬前发展中的前沿GC都是复合 算法，并且并⾏和并发兼备。

# 4 垃圾收集器

## 4.1 垃圾收集器分类

垃圾收集器没有在规范中进⾏过多的规定，可以由不同的⼚商、不同版本的JVM来实现。由于JDK 版本的处于⾼速迭代过程中，因此java发展⾄今已经衍⽣了众多GC版本。从不同⻆度分析垃圾收集器， 可以将GC分为不同的类型。

- 按线程数分，可以分为串⾏垃圾回收器和并⾏垃圾回收器。

**串⾏**回收指的是在同⼀时间段只允许有**⼀个\****CPU**⽤于执⾏垃圾回收操作，此时⼯作线程被暂停，直

⾄垃圾收集⼯作结束。

和串⾏回收相反，**并⾏**收集可以运⽤**多个\****CPU**同时执⾏垃圾回收，因此提升了应⽤的吞吐量，不过 并⾏回收仍然与串⾏回收⼀样，采⽤独占式，使⽤了“Stop-the-world”机制。

在诸如单CPU处理器或者较⼩内存等硬件场合中，串⾏回收器的性能表现可以超过并⾏回收器和并 发回收器。所以，串⾏回收默认被应⽤在客户端Client模式下的JVM中。

在并发能⼒较强的CPU上，并⾏回收器产⽣的停顿时间要短于串⾏回收器。

- 按照⼯作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。

并发式垃圾回收器与应⽤程序线程交替⼯作，以尽可能减少应⽤程序的停顿时间。

独占式垃圾回收器⼀旦运⾏，就停⽌应⽤程序中的所有⽤户线程，直到垃圾回收过程完全结束。

- 按碎⽚处理⽅式分，可分为压缩式垃圾回收器和⾮压缩式垃圾回收器。

压缩式垃圾回收器在回收完成后，对存活对象进⾏压缩整理，消除回收后的碎⽚。

⾮压缩式的垃圾回收器不进⾏这不操作，会产⽣碎⽚。

- 按⼯作的内存空间分，⼜可分为年轻代垃圾回收器和⽼年代垃圾回收器

## 4.2 评估GC的性能指标

吞吐量:运⾏⽤户代码的时间占总运⾏时间的⽐例 （总运⾏时间=程序的运⾏时间+内存回收的时间）；

暂停时间:执⾏垃圾收集时，程序的⼯作线程被暂停的时间； 内存占⽤:java堆区所占的内存⼤⼩；

吞吐量就是CPU⽤于运⾏⽤户代码的时间与CPU总消耗的时间的⽐值，即吞吐量=运⾏⽤户代 码时间/(运⾏⽤户代码时间+垃圾收集时间)。⽐如：虚拟机总共运⾏了100分钟，其中垃圾收集花 掉1分钟，那么吞吐量就是99%。这种情况下，应⽤程序能容忍较⾼的暂停时间，因此，⾼吞吐量 的应⽤程序有更⻓的时间基准，快速响应是不必考虑的。

暂停时间是指⼀个时间段内应⽤程序线程暂停，让GC线程执⾏的状态。⽐如：GC期间100毫 秒的暂停时间意味这在这100毫秒期间内没有应⽤程序线程是活动的。

**注重吞吐量**：吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2= 0.4 s

**注重低延迟**：暂停时间优先，意味这尽可能让单次STW的时间最短:0.1 + 0.1 + 0.1 + 0.1 + 0.1 =

0.5 s

这三者共同构成⼀个”不可能三⻆“。三者总体的表现会随着技术进步⽽越来越好。⼀款优秀的收集 器通常最多同时满⾜其中的两项。

简单来说，主要抓住两点:

#### 吞吐量暂停时间

在设计(或使⽤)GC算法时，必须确定我们的⽬标:⼀个GC算法只可能针对两个⽬标之⼀(即只专 注于较⼤吞吐量或最⼩暂停时间)，或尝试找⼀个⼆者的折衷。

现在标准，**在最⼤吞吐量优先的情况下，降低停顿时间。**

## 4.3 垃圾收集器发展史

有了虚拟机，就⼀定有需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称之为Garbage Collector

1999年随着JDK1.3.1 ⼀起来的是串⾏⽅式的Serial GC，它是第⼀款GC。ParNew垃圾收集器是Serial收集器的多线程版本。

2002年2⽉26⽇，Parallel GC和Concurrent Mark Sweep GC跟随着JDK1.4.2 ⼀起发布

Parallel GC在JDK6之后成为HotSpot默认GC。2012年，在JDK1.7u4版本中，G1可⽤。

2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。

2018年3⽉，JDK10中G1垃圾回收器的并⾏完整垃圾回收，实现并⾏性来改善最坏情况下的延迟。

2018年9⽉，JDK11发布。引⼊Epsilon垃圾回收器，⼜被称为"No-Op(⽆操作)"回收器。同时引⼊ZGC(Oracle 发布)：可伸缩的低延迟垃圾回收器(Experimental).

2019年3⽉，JDK12发布。增强G1，⾃动返回未⽤堆内存给操作系统。同时，引⼊Shenandoah GC(Red Hat 开发):低停顿时间的GC(Experimetal).

2019年9⽉，JDK13发布。增强ZGC，⾃动返回未⽤堆内存给操作系统。

2020年3⽉，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应⽤

## 4.4 经典垃圾回收器

串⾏回收器：Serial 、 Serial Old

并⾏回收器：ParNew、Parallel Scavenge、Parallel Old

并发回收器：CMS、G1

[https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-1500 20.pdf](https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)

## 4.5 垃圾回收器的组合关系

如果说垃圾收集算法是内存回收的⽅法论，那么垃圾收集器就是内存回收的具体实现。下图展示了 7种作⽤于不同分代的收集器，其中⽤于回收新⽣代的收集器包括Serial、PraNew、Parallel Scavenge，回收⽼年代的收集器包括Serial Old、Parallel Old、CMS，还有⽤于回收整个Java堆的G1 收集器。不同收集器之间的连线表示它们可以搭配使⽤。

为什么要有很多收集器，⼀个不够吗 ？因为java的使⽤场景很多，移动端、服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提⾼垃圾收集的性能。

虽然我们会对各个收集器进⾏⽐较，但并⾮为了挑选⼀个最好的收集器出来。没有⼀种放之四海⽽ 皆准、任何场景下都适⽤的完美收集器存在，更加没有万能的收集器。所以 我们选择的**只是对具体应⽤\****最合适的收集器**。

#### 如何查看默认的垃圾回收器

-XX:+PrintCommandLineFlags:查看命令⾏相关参数(包含使⽤的垃圾收集器)

使⽤命令⾏指令: jinfo -flag 相关垃圾回收参数 进程ID

## 4.6 Serial(复制算法)

Serial/Serial Old收集器是最基本最古⽼的收集器，Serial是JDK1.3之前回收新⽣代唯⼀的选择。它是⼀个单线程收集器，并且在它进⾏垃圾收集时，必须暂停所有⽤户线程。

Serial收集器是作为HotSpot中Client模式下的默认新⽣代垃圾收集器，采⽤的是复制算法。Serial Old收集器是针对⽼年代的收集器，采⽤的是标记-整理算法。

如下是 Serial 收集器和 Serial Old 收集器结合进⾏垃圾收集的示意图，当⽤户线程都执⾏到安全点时，所有线程暂停执⾏，Serial 收集器以单线程，采⽤复制算法进⾏垃圾收集⼯作，收集完之后，⽤户线程继续开始执⾏。它的”单线程“的意义并不仅仅说明它只会使⽤⼀个CPU或⼀条收集线程去完成垃圾 收集⼯作，更重要的是在它进⾏垃圾收集时，必须暂停其他所有的⼯作线程，直到它收集结束(Stop the world)

优点：实现简单⾼效（与其他收集器的单线程相⽐)，对于限定单个CPU的环境来说，Serial收集器 由于没有线程交互的开销，专⼼做垃圾收集⾃然可以获得最⾼的单线程收集效率。

缺点：会给⽤户带来停顿。

适⽤场景：Client 模式（桌⾯应⽤）；单核服务器。

可以⽤ -XX:+UseSerialGC 参数可以指定年轻代和⽼年代都使⽤串⾏收集器。等价于 新⽣代⽤

Serial GC，并且⽼年代⽤ Serial Old GC

#### 总结

这种垃圾收集器了解即可，现在已经不⽤串⾏的了。⽽且在限定单核CPU才可以使⽤，现在都不是 单核的了。

对于交互较强的应⽤⽽⾔，这种垃圾收集器是不能接受的。⼀般在java web应⽤程序中是不会使⽤串⾏垃圾收集器的。

## 4.7 Serial Old(标记-整理算法)

⽼年代单线程收集器，Serial收集器的⽼年代版本；Serial Old是运⾏在Client模式下默认的⽼年代的垃圾回收器。Serial Old在server模式下主要有两个⽤途：1) 与新⽣代的Parallel Scavenge配合使⽤

；2)作为⽼年代CMS收集器的后备垃圾收集⽅法

如下图是 Serial 收集器和 Serial Old 收集器结合进⾏垃圾收集的示意图：

适⽤场景：Client 模式（桌⾯应⽤）；单核服务器；与 Parallel Scavenge 收集器搭配；作为 CMS

收集器的后备预案。

## 4.8 ParNew (复制算法)

如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器就是Serial收集器的多线程版本。

Par是Parallel的缩写，New：只能处理的是新⽣代

新⽣代收并⾏集器，ParNew收集器是Serial收集器的**多线程版本**，使⽤多个线程进⾏垃圾收集。在 多核CPU环境下有着⽐Serial更好的表现；ParNew收集器在年轻代中同样也是采⽤复制算法、“stop- the-wold”机制。

如下是 ParNew 收集器和 Serial Old 收集器结合进⾏垃圾收集的示意图，当⽤户线程都执⾏到安全点时，所有线程暂停执⾏，ParNew 收集器以多线程，采⽤复制算法进⾏垃圾收集⼯作，收集完之后，

⽤户线程继续开始执⾏。

对于新⽣代，回收次数频繁，使⽤并⾏⽅式⾼效。

对于⽼年代，回收次数少，使⽤串⾏⽅式节省资源。(CPU并⾏需要切换线程，串⾏可以省去切换线 程的资源)。

由于ParNew收集器是基于并⾏回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都 会⽐Serial收集器更⾼效？**(\****扩展点***\*:\****多线程程序效率⼀定⾼于单线程程序吗？？**)

ParNew收集器运⾏在多CPU的环境下，由于可以充分利⽤多CPU、多核⼼等物理硬件资源优势， 可以更快速地完成垃圾收集，提升程序的吞吐量。

但是在单个CPU的环境下，ParNew收集器不⽐Serial收集器更⾼效。虽然Serial收集器是基于串⾏ 回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产⽣的⼀些额外开 销。

#### 适⽤场景

多核服务器；与 CMS 收集器搭配使⽤（除Serial外，⽬前只有ParNew GC能与CMS收集器配合

⼯作）。

#### 参数

当使⽤ -XX:+UseConcMarkSweepGC 来选择 CMS 作为⽼年代收集器时，新⽣代收集器默认就是 ParNew，也可以⽤ -XX:+UseParNewGC 来指定使⽤ ParNew 作为新⽣代收集器。

-XX:ParallelGCThreads 限制线程数量，默认开启和cpu数据相同的线程数。

## 4.9 Parallel Scavenge(复制算法)

HotSpot的年轻代中除了拥有ParNew收集器是基于并⾏回收的以外，Parallel Scavenge收集器同样也采⽤了复制算法、并⾏回收和“stop the world”机制。

那么Parallel收集器的出现是否是多此⼀举？

和ParNew收集器不同，Parallel Scavenge收集器的⽬标是达到⼀个**可控制的吞吐量**

**(**Throughput),它也被称为**吞吐量优先**的垃圾收集器。

⾃适应调节策略也是Parallel Scavenge与ParNew⼀个重要区别。

⾼吞吐量意味着⾼效利⽤ CPU。⾼吞吐量可以⾼效率的利⽤CPU时间，尽快完成程序的运算任务。如下是 Parallel 收集器和 Parallel Old 收集器结合进⾏垃圾收集的示意图，在新⽣代，当⽤户线程

都执⾏到安全点时，所有线程暂停执⾏，ParNew 收集器以多线程，采⽤复制算法进⾏垃圾收集⼯作，

收集完之后，⽤户线程继续开始执⾏；在⽼年代，当⽤户线程都执⾏到安全点时，所有线程暂停执⾏，

Parallel Old 收集器以多线程，采⽤标记-整理算法进⾏垃圾收集⼯作。

#### 适⽤场景：

注重吞吐量，⾼效利⽤ CPU，需要⾼效运算且不需要太多交互。适合后台应⽤等对交互相应要求不

⾼的场景；例如，那些**执⾏批量处理、订单处理、⼯资⽀付、科学计算的应⽤程序。**

#### 参数配置：

-XX:+UseParallelGC 来选择 Parallel Scavenge 作为新⽣代收集器，

-XX:+UseParallelOldGC ⼿动指定⽼年代都是使⽤并⾏回收收集器。分别适⽤于新⽣代和⽼年代。默认jdk8是开启的。

上⾯两个参数，默认开启⼀个，另⼀个也会被开启。(互相激活)

-XX:ParallelGCThreads设置年轻代并⾏收集器的线程数。⼀般地，最好与CPU数量相等。以避免过 多的线程数影响垃圾收集性能。

默认情况下，当CPU数量⼩于8个，ParallelGCThreads的值等于CPU数量。 当CPU数量⼤于8个，ParallelGCThreads的值等于3+[5*CPU-Count]/8]。

-XX:MaxGCPauseMillis 设置垃圾收集器最⼤停顿时间(即STW的时间)。单位是毫秒。

为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在⼯作时会调整java堆⼤⼩或者 其他⼀些参数。

对于⽤户来说，停顿时间越短体验越好。但是在服务器端，我们注重⾼并发，整体的吞吐量。所以 服务器端适合Parallel，进⾏控制。

#### 该参数使⽤需谨慎

-XX:GCTimeRatio垃圾收集时间占总时间的⽐例(=1/(N+1))。⽤户衡量吞吐量的⼤⼩。 取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。

与前⼀个-XX:MaxGCPauseMillis参数有⼀定的⽭盾性。暂停时间越⻓，Radio参数就容易超过设定

的⽐例。

## 4.10 Parallel Old (标记-整理算法)

⽼年代并⾏收集器，吞吐量优先，Parallel Scavenge收集器的⽼年代版本；

适⽤场景：与Parallel Scavenge收集器搭配使⽤；注重吞吐量。jdk7、**jdk8 默认使⽤该收集器作为⽼年代收集器**，使⽤ -XX:+UseParallelOldGC 来指定使⽤ Paralle Old 收集器。

4.11
CMS(Concurrent Mark Sweep)收集器(标记-清除算法)

------

在JDK1.5时，HotSpot推出了⼀款在**强交互应⽤**中重要的⼀款垃圾收集器: **CMS\****（***\*Concurrent- Mark-Sweep\****）**,这款垃圾收集器是HotSpot虚拟机中第⼀款真正意义上的并发收集器，它第⼀次实现了**垃圾收集线程与⽤户线程同时⼯作**

CMS收集器是⼀种尽可能缩短⽤户线程的停顿时间(**低延迟**)收集器，停顿时间越短(低延迟)就越适合 与⽤户交互的程序，良好的响应速度能提升⽤户体验。

⽬前很⼤⼀部分的java应⽤集中在B/S系统的服务端上，这类应⽤尤其重视服务的响应速度，希望 系统**停顿时间最短**，以给⽤户带来较好的体验。CMS收集器就⾮常符合这类应⽤的需求。

它是⼀种并发收集器，采⽤的是**标记\****-***\*清除**算法。

JDK1.5中使⽤CMS来收集⽼年代的时候，新⽣代只能选择ParNew或者Serial收集器中的⼀个。在 G1出现之前，CMS使⽤还是⾮常⼴泛的。⼀直到今天，仍然有很多系统使⽤CMS GC。

### 4.11.1 收集过程

整个垃圾收集过程分为 4 个步骤：

① 初始标记(Initial-Mark)：在这个阶段中，程序中所有的⽤户线程都会因为STW机制 ⽽出现短暂的暂停，主要任务是 **标记⼀下** **GC Roots** **能直接关联到的对象**，⼀旦标记完成就会恢复之前的⽤户线程，由于直接关联对象⽐较⼩，所以**速度⾮常快**。

② 并发标记(Concurrent-Mark)：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，标记出全部的垃圾对象，耗时较⻓。**这个过程耗时较⻓但是不需要暂停⽤户线程**，可以与垃圾收集线程⼀起 并发执⾏。

③ 重新标记(Remark)：由于在并发标记阶段中，程序的⽤户线程和垃圾收集线程同时运⾏或者交叉运⾏，因此为了**修正并发标记期间，因⽤户线程继续运作⽽导致标记产⽣变动的那⼀部分对象的标记** **记录**，这个阶段的停顿时间通常会⽐初始标记极端稍⻓⼀些，但也远⽐并发标记阶段的时间短。

④ 并发清除(Current-Sweep)：此阶段**清理删除标记阶段判断的已经死亡的对象，释放内存空间**。由于不需要移动存活对象，所以这个阶段也是可以与⽤户线程同时并发的。

整个过程耗时最⻓的并发标记和并发清除都是和⽤户线程⼀起⼯作，所以从总体上来说，CMS 收集器垃圾收集可以看做是和⽤户线程并发执⾏的。

尽管CMS收集器采⽤的是并发回收(⾮独占式)，但是在其初始化标记和重新标记这两个阶段中仍然 需要执⾏"stop-the-world"机制暂停程序中的⼯作线程，不过暂停时间并不太⻓，因此可以说明⽬前所 有的垃圾收集器都做不到完全不需要"stop-the-world"，只是尽可能地缩短暂停时间。

#### 由于最耗费时间的并发标记与并发清除阶段都不需要暂停⼯作，所以整体的回收是低停顿的。

另外，由于在垃圾收集阶段⽤户线程没有中断，所以在CMS回收过程中，还应该确保应⽤程序⽤户 线程有⾜够的内存可⽤。因此，CMS收集器不能像其他收集器那样等到⽼年代集合完全被填满了再进⾏ 收集，⽽是**当堆内存使⽤率达到某⼀阀值时，便开始进⾏回收。**以确保应⽤程序在CMS⼯作过程中依然 有⾜够的空间⽀持应⽤程序运⾏。要是CMS运⾏期间预留的内存⽆法满⾜程序需要，就会出现⼀

次"Conrurrent Mode Failure"失败，这时虚拟机将启动后备预案：**临时启动\****Serial Old***\*收集器**来重新进

⾏⽼年的垃圾收集，这样停顿时间就很⻓了。

### 4.11.2 空闲列表

CMS收集器的垃圾收集算法采⽤是标记-清除算法，这意味这每次执⾏完内存回收后，由于被执⾏ 内存回收的⽆⽤对象所占⽤的内存空间极有可能是不连续的⼀些内存块，不可能避免的讲会**产⽣⼀些内** **存碎⽚**。那么CMS在为新对象分配内存空间时，将⽆法使⽤**指针碰撞**(Bump the Pointer)技术，⽽只能够选择**空闲列表**(Free List)执⾏内存分配。

为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从Java堆中划分出来。假设Java堆中内存是绝 对规整的，所有⽤过的内存都放在⼀边，空闲的内存放在另⼀边，中间放着⼀个指针作为分界点的指示 器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动⼀段与对象⼤⼩相等的距离，这种分配⽅式 称为**“指针碰撞\****”（***\*Bump the Pointer）**。如果Java堆中的内存并不是规整的，已使⽤的内存和空闲的内存相互交错，那就没有办法简单地进⾏指针碰撞了，虚拟机就必须维护⼀个列表，记录上哪些内存块 是可⽤的，在分配的时候从列表中找到⼀块⾜够⼤的空间划分给对象实例，并更新列表上的记录，这种 分配⽅式称为**“空闲列表\****”（***\*FreeList）**。选择哪种分配⽅式由Java堆是否规整决定，⽽Java堆是否规整

⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。

因此，在使⽤Serial、ParNew等带Compact过程的收集器时，系统采⽤的分配算法是指针碰撞，

⽽使⽤CMS这种基于Mark-Sweep算法的收集器时，通常采⽤空闲列表。

#### 指针碰撞：

**空闲列表\****:**

#### 有⼈会觉得既然Mark Sweep会造成内存碎⽚，那么为什么不把算法换成Mark Compact？

答案其实很简单，因为当并发清除的时候，⽤Compact整理内存的话，原来的⽤户线程使⽤的内存 还怎么⽤？要保证⽤户线程能继续执⾏，前提是它允许的资源不受影响。

### 4.11.3 主要优缺点

#### CMS主要优点：

1. 并发收集；
2. 低停顿。

#### CMS明显的缺点：

- **CMS\****收集器对***\*CPU\****资源⾮常敏感。**在并发阶段，它虽然不会导致⽤户线程停顿，但是会因为占⽤ 了⼀部分线程⽽导致应⽤程序变慢，总吞吐量会降低。
- **CMS\****收集器⽆法处理浮动垃圾**，可能出现“Concurrent Mode Failure”失败⽽导致另⼀次Full GC 的产⽣。由于CMS并发清理阶段⽤户线程还在运⾏着，伴随程序运⾏⾃然就还会有新的垃圾不断产⽣， 这部分垃圾出现在标记过程之后，CMS⽆法在当次收集中处理掉它们，只好留待下⼀次GC时再清理 掉。这⼀部分垃圾就称为“浮动垃圾”。
- CMS是基于“标记-清除”算法实现的收集器，收集结束时会有**⼤量空间碎⽚产⽣**。空间碎⽚过多， 可能会出现⽼年代还有很⼤空间剩余，但是⽆法找到⾜够⼤的连续空间来分配当前对象，不得不提前出 发FullGC。

### 4.11.4 常⽤参数设置

https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

1) **-XX:+UseConcMarkSweepGC** ⼿动执⾏使⽤CMS收集器执⾏内存回收任务。开启该参数后会⾃动将-XX:+UseParNewGC打开。即:ParNew(Young区) + CMS(Old区) + Serial Old的组合

2)**-XX:CMSInitiatingOccupancyFraction** 设置堆内存使⽤率的阀值，⼀旦达到该阀值，便开始进⾏回收。

-XX:CMSInitiatingOccupancyFraction=20 设置到20%时

如果内存增⻓缓慢，则可以设置⼀个稍⼤的值，⼤的阀值可以有效降低CMS的触发频率，检索⽼年 代回收的次数可以较为明显的改善应⽤程序性能。

相反，如果应⽤程序内存使⽤率增⻓很快，则应该降低这个阀值，以避免频繁触发⽼年代串⾏收集 器。通过该选项可以有效降低Full GC的执⾏次数。

3)**-XX:+UseCMSCompactAtFullCollection** ⽤于指定在执⾏完FullGC后对内存空间进⾏压缩整理，以此避免内存碎⽚的产⽣。不过由于内存压缩整理过程⽆法并发执⾏，所带来的问题就是停顿时间变得更

⻓了。

4) **-XX:CMSFullGCsBeforeCompaction**设置在执⾏多少次Full GC后对内存空间进⾏验收整理5)**-XX:ParallelCMSThreads**设置CMS的线程数量

CMS默认启动的线程数(CPU数量+3)/4,ParallelGCThreads，ParallelGCThreads是年轻代并⾏收集 器的线程数。当CPU资源⽐较紧张时，收到CMS收集器线程的影响，应⽤程序的性能在垃圾回收阶段可 能会⾮常糟糕

### 4.11.5 ⼩结

HotSpot这么多的垃圾回收器，Serial/Serial Old、Parallel GC、CMS这些GC有什么不同吗？ 如果你想要最⼩化地使⽤内存和并⾏开销，请选择**Serial Old(\****⽼年代***\*) +** **Serial(\****年轻代***\*)**

如果你想要最⼤化应⽤程序的吞吐量，请选择**Parallel Old(\****⽼年代***\*) +** **Parallel(\****年轻代***\*)**

如果你想要最⼩化GC的中断或停顿时间，请选择**CMS(\****⽼年代***\*) + ParNew(\****年轻代***\*)**

#### 后续版本

**JDK9新特性**：CMS被标记**废弃**(Deprecate)了，如果对JDK9 以以上版本的Hotspot虚拟机使⽤- XX:+UseConcMarkSweepGC参数来开启CMS收集器的话，⽤户会收到⼀个警告信息，同时CMS在未来 将会被废弃

**JDK14 新 特 性** ： **删 除** CMS 垃 圾 回 收 器 ， 移 除 CMS 垃 圾 收 集 器 ， 如 果 在 JDK14 中 使 ⽤ - XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出⼀个warning信息，但是不会exit，JVM会

⾃动回退以默认GC的⽅式启动JVM。

## 4.12 G1(Garbage First)收集器 (区域化分代式)

#### 既然已经有了前⾯的⼏个强⼤的GC，为什么还要发布Garbage First(G1)GC ?

原因在于应⽤程序所对应的**业务越来越庞⼤、复杂、⽤户越来越多**，没有GC就不能保证应⽤程序正常运⾏，⽽经常造成STW的GC⼜跟不上实际的需求，所以才会不断地尝试对GC进⾏优化。G1 垃圾回收器是在java7 update4之后引⼊的⼀个新的垃圾回收器，是当前收集器技术发展的最前沿成果之⼀。G1收集器基于“标记-整理”算法实现，也就是说不会产⽣内存碎⽚。此外，G1收集器不同于之前的收集器的⼀个重要特点是：**G1\****回收的范围是整个***\*Java\****堆***\*(\****包括新⽣代，⽼年代***\*)\****，⽽前六种收集器回收的范围仅限于新⽣代或⽼年代。**

与此同时，为了适应现在**不断扩⼤的内存和不断增加的处理器数量**，进⼀步**降低暂停时间**(pause time)，同时兼顾**良好的吞吐量**。

官⽅给G1设定的⽬标**是在延迟可控的情况下获得尽可能⾼的吞吐量**，所以才担当起"**全功能收集** **器**"的重任与期望。

G1收集器是当今收集器技术发展最前沿的成果，它是⼀款⾯向服务端应⽤的收集器，它能充分利⽤ 多CPU、多核环境。因此它是⼀款并⾏与并发收集器，并且它能建⽴可预测的停顿时间模型。

- **为什么叫做\****Garbage First(G1)***\*呢？**

因为G1是⼀个并⾏回收器，它⽤堆内存分割为很多不相关的区域(Region)（物理上是不连续的)。 使⽤不同的Region来表示Eden、survivor、old等。

G1 GC有计划的避免在整个java堆中进⾏全区域的垃圾收集。G1 跟踪各个Region⾥⾯的垃圾堆积的价值⼤⼩(回收所获得的空间⼤⼩以及回收所需时间的经验值)，**在后台维护⼀个优先列表，每次根据** **允许的收集时间，优先回收价值最⼤的\****Region***\*。**

由于这种⽅式的侧重点在于回收垃圾最⼤量的区间(Region)，所以我们给G1⼀个名字:垃圾优先

(Garbage First)

G1是⼀款⾯向服务端应⽤的垃圾收集器，主要针对配备多核CPU及⼤容量内存的机器，以**极⼤概率** **满⾜\****GC***\*停顿时间的同时，还兼具⾼吞吐量的性能特性。**

在JDK1.7版本正式启⽤，移除了Experimetal的标识，是JDK9以后的默认垃圾回收器，取代了CMS 回收器以及Parallel + ParallelOld 组合。被Oracle官⽅称为**"全功能的垃圾收集器**"。

与此同时，CMS已经在JDK9中被标记为废弃(deprecated)。在jdk8中还不是默认的垃圾回收器，需 要使⽤-XX:+UseG1GC来启⽤。

### 4.12.2 G1收集器的优点

与其他GC收集器相⽐，G1使⽤全新的分区算法，其特点如下所示：

#### 1) 并⾏与并发

并⾏性: G1在回收期间，可以有多个GC线程同时⼯作，有效利⽤多核计算能⼒。此时⽤户线程STW。

并发性:G1拥有与⽤户线程交替执⾏的能⼒，部分⼯作可以和应⽤程序同时执⾏。因此，⼀般来 说，不会再整个回收阶段发⽣完全阻塞应⽤程序的情况。

#### 2) 分代收集

从分代上看，**G1依然属于分代⾏垃圾回收器**，它会区分年轻代和⽼年代，年轻代依然有Eden区和Survivor区。但从堆的结构上，它不要求整个Eden区、Survivor区或者⽼年代都是联系的，也不再坚持 固定⼤⼩和固定数量。

#### 将堆空间划分为若⼲个区域(Region)，这些区域包含了逻辑上的年轻代和⽼年代。

和之前的各类垃圾回收器不同，它同时**兼顾年轻代和⽼年代**。对⽐其他回收器，或者⼯作在年轻 代，或者⼯作在⽼年代。

#### 3) 可预测的停顿时间模型(即:软实时 soft real time)

G1会通过⼀个合理的计算模型，计算出每个Region的收集成本并量化，这样⼀来，收集器在给定了“停顿”时间限制的情况下，总是能选择⼀组恰当的Regions作为收集⽬标，让其收集开销满⾜这个限制 条件，以此达到实时收集的⽬的。**G1\****收集器之所以能建⽴可预测的停顿时间模型，是因为它可以有计划** **地避免在整个\****java***\*堆中进⾏全区域的垃圾收集**。

由于分区原因，G1可以只选取部分区域进⾏内存回收，这样缩⼩了回收的范围，因此对于全局停 顿的发⽣也能得到较好的控制。

G1跟踪各个Reion⾥⾯的垃圾堆积的价值⼤⼩(回收所获得的空间⼤⼩以及回收所需的时间的经验 值)，在后台维护⼀个优先列表，每次根据允许的收集时间，优先回收价值最⼤的Region。保证了 G1收集器在优先的时间内可以获取尽可能⾼的收集效率。

相⽐于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

#### 如何建⽴可靠的停顿预测模型（满⾜⽤户设定的期望停顿时间）？

G1 收集器的停顿模型是以衰减均值（Decaying Average）为理论基础来实现的：垃圾收集过程中，G1 收集器会根据每个 Region 的回收耗时、记忆集中的脏卡数量等，分析得出平均值、标准偏差等。

“衰减平均值”⽐普通的平均值更能准确地代表“最近的”平均状态，通过这些信息预测现在开始回收 的话，由哪些 Region 组成回收集才能在不超期望停顿时间的约束下获得最⾼收益。

### 4.12.3 G1收集器的缺点

相对于CMS，G1还不具备全⽅位、压倒性优势。⽐如在⽤户程序运⾏过程中，G1⽆论是为垃圾收 集产⽣的内存占⽤还是程序运⾏时的额外执⾏负载都要⽐CMS要⾼。

从经验上来说， 整体⽽⾔：

⼩内存应⽤上，CMS ⼤概率会优于 G1；

⼤内存应⽤上，G1 则很可能更胜⼀筹。

这个临界点⼤概是在 6~8G 之间（经验值）

### 4.12.4 G1回收器的参数设置

https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

-XX:+UseG1GC ⼿动指定使⽤G1收集器执⾏内存回收任务。

‐XX:G1HeapRegionSize 设置每个Region的⼤⼩。值是2的幂，范围是1MB到32MB之间，⽬标是根据最⼩的java堆⼤⼩划分出约2048个区域。默认是堆内存的1/2000。

‐XX:MaxGCPauseMillis 设置期望达到的最⼤GC停顿时间指标(JVM会尽⼒实现，但不保证达到)。默认200ms。

‐XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的java堆占⽤阀值。超过此值，就触发

GC。默认值是45。

-XX:ParallelGCThread 设置STW⼯作线程数的值。最多设置为8

-XX:ConcGCThreads 设置并发标记的线程数。设置为CPU数量的1/4左右。

### 4.12.5 如何设置

G1的设计原则就是简化JVM性能调优，只需要简单三步即可完成： 第⼀步: 开启G1垃圾收集器 （-XX:+UseG1GC）

第⼆步:设置堆的最⼤内存( -Xmx -Xms)

第三步:设置最⼤的停顿时间(‐XX:MaxGCPauseMillis)

### 4.12.6 收集过程

如下图所示，G1 收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和 CMS 收集器前⼏步的收集过程很相似：

① 初始标记：标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停⽌⽤户线程，单线程执⾏。

② 并发标记：从 GC Root 开始对堆中的对象进⾏可达性分析，找出存活对象，这个阶段耗时较

⻓，但可以和⽤户线程并发执⾏。

③ 最终标记：修正在并发标记阶段由于⽤户程序执⾏⽽产⽣变动的标记记录。

④ 筛选回收：筛选回收阶段会对各个 Region 的回收价值和成本进⾏排序，根据⽤户所期望的 GC

停顿时间来指定回收计划（⽤最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来

——第⼀时间清理垃圾最多的区块），这⾥为了提⾼回收效率，并没有采⽤和⽤户线程并发执⾏的⽅ 式，⽽是停顿⽤户线程。

### 4.12.7 G1回收器的使⽤场景

- ⾯向服务端应⽤，针对具有⼤内存、多处理器的机器。(在普通⼤⼩的堆⾥表现并不惊喜)
- 最主要的应⽤是需要低GC延迟，并具有⼤堆的应⽤程序提供解决⽅案；
  - 在堆⼤⼩约6GB或更⼤时，可预测的暂停时间可以低于5秒；(G1通过每次只清理⼀部分⽽不是全部Region的增量式清理在保证每次GC停顿时间不会过⻓) 。
  - ⽤来替换掉5中的CMS收集器，以下情况，使⽤G1可能⽐CMS好 超过50% 的java堆被活动数据占⽤;

对象分配频率或年代提升频率变化很⼤；

GC停顿时间过⻓(⼤于0.5⾄1秒)

- HotSpot垃圾收集器⾥，除了G1以外，其他的垃圾收集器使⽤**内置的\****JVM***\*线程**执⾏GC多线程操作，

⽽G1 GC可以**采⽤应⽤线程运⾏\****GC***\*的⼯作**，即当JVM的GC线程处理速度慢时，系统会调⽤应⽤程序帮助加速垃圾回收过程。

### 4.12.8 Region的使⽤介绍

分区Region:化整为零

使⽤G1收集器是，它将整个java堆划分为约2048个⼤⼩相同的独⽴Region块，每个Region块⼤⼩ 根据堆空间的实际⼤⼩⽽定，整体被控制在1mb到32mb之间，且为2的N次幂，即1mb、2mb、 4mb、8mb、16mb、32mb。可以通过‐XX:G1HeapRegionSize设定。**所有的\****Region⼤⼩相同，且在***\*JVM⽣命周期内不会被改变。**

虽然还保留这新⽣代和⽼年代的概念，但新⽣代和⽼年代不再是物理隔离的了，它们都是⼀部分

Region(不需要连续)的集合。通过Region的动态分配⽅式实现逻辑上的连续。

⼀个region有可能属于Eden，Survivor，或者Old 内存区域。但是⼀个region只可能属于⼀个⻆

⾊。图中的E表示region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。 图中空⽩的表示未使⽤的内存空间。

G1垃圾收集器还增加了⼀种新的内存区域，叫做**Humongous**内存区域，如图中的H块。主要⽤于 存储⼤对象，如果超过1.5个region，就放到H区。

设置H的原因：

对于堆中的⼤对象，默认直接会分配到⽼年代，但是如果他是⼀个短期存在的⼤对象，就会对垃圾 收集器造成负⾯影响。为了解决这个问题，G1划分了⼀个Humongous区，它⽤来专⻔存放⼤对象。**如** **果⼀个\****H区装不下⼀个⼤对象，那么***\*G1会寻找连续的\****H区来存储。**为了能找到连续的H区，有时候不得不启动Full GC。G1的⼤多数⾏为都把H区作为⽼年代⼀部分来看待。

### 4.12.9 主要回收环节

G1 GC的垃圾回收过程主要包含以下三个环节:

#### 年轻代GC (Young GC)

**⽼年代并发标记过程\****(Concurrent Marking)+***\*年轻代\****GC (Young GC)**

#### 混合回收(Mixed GC)

(如果需要，单线程、独占式、⾼强度的Full GC还是继续存在的。Full GC针对GC 的评估失败提供了⼀种失败的保护机制，即强⼒回收。)

#### Young GC -> Young GC + concurrent mark -> mixed GC 顺序，进⾏垃圾回收。

**年轻代\****GC**

应⽤程序分配内存，当年轻代的Eden区⽤尽时开始年轻代回收过程；G1的年轻代收集阶段是⼀个 **并⾏的独占式收集器**。在年轻代回收期，G1 GC暂停所有的应⽤程序线程，启动多线程执⾏年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者⽼年代区间，也有可能是两个区间都会涉及。

#### ⽼年代并发标记(Concurrent Marking)

当堆内存使⽤达到⼀定值(默认是45%)时，开始⽼年代并发标记过程。

#### 混合回收(Mixed GC)

标记完成⻢上开始混合回收过程。对于⼀个混合回收期，G1 GC从⽼年代移动存活对象到空闲区间，这些空闲区间也就成为了⽼年代的⼀部分。和年轻代不同，⽼年代的G1回收器和其他GC不同，G1 的⽼年代回收器不需要整个⽼年代被回收，⼀次主要扫描/回收⼀⼩部分⽼年代Region就可以了。同 时，这个⽼年代Region是和年轻代⼀起被回收的。

举个示例：⼀个Web服务器，java进程最⼤堆内存为4G，每分钟响应1500个请求，每45秒钟会新 分配⼤约2G的内存。G1会每45秒钟进⾏⼀次年轻代回收，每31个⼩时整个堆的使⽤率会达到45%。会 开始⽼年代并发标记过程，标记完成后开始四到五次的混合回收。

### 4.12.10 跨 Region 引⽤对象

记忆集 Remembered Set, 写屏障 Write Barrier

#### ⼀个对象被不同区域引⽤的问题

⼀个Region不可能是孤⽴的，⼀个Region中的对象可能被其他任意Region中对象引⽤，判断对象 存活时，是否需要扫描整个java堆才能保证准确

在其他的分代收集器，也存在这样的问题，但是在G1更突出

回收新⽣代也不得不同时扫描⽼年代 ，这样的话会降低Young GC的效率

#### 解决⽅法

⽆论是G1还是其他分代收集器，JVM都是使⽤Remembered Set来避免扫描全局扫描每个Region都有⼀个对应的Remember Set；

每次Reference类型数据写操作时，都会产⽣⼀个Write Barrier(写屏障)暂时中断操作；

写屏障是指，在改变特定内存的值（实际上也就是写⼊内存）的时候额外执⾏的⼀些动作。 在⼤多数的垃圾回收算法中，都利⽤到了写屏障。

G1的垃圾回收器的写屏障使⽤⼀种两级的log buffer结构：

1. global set of filled buffer：所有线程共享的⼀个全局的，存放填满了的log buffer的集合；
2. thread log buffer：每个线程⾃⼰的log buffer。所有的线程都会把写屏障的记录先放进去⾃⼰的log buffer中，装满了之后，就会把log buffer放到 global set of filled buffer中，⽽后再申请⼀个log buffer；

然后检查将要写⼊的引⽤指向的对象是否和该Reference类型数据在不同的Region(其他收集器： 检查⽼年代对象是否引⽤了新⽣代对象)；

如果不同，通过CardTable把相关的引⽤信息记录到引⽤指向对象的所在Region对应的Remember Set中；

当进⾏垃圾收集时，在GC根据节点的枚举范围加⼊Remember Set；就可以保证不进⾏全局扫描，也不会有遗漏

### 4.12.11 卡表 Card Table

如果⼀个线程修改了Region内部的引⽤，就必须要去通知RS，更改其中的记录。为了达到这种⽬的，G1回收器引⼊了⼀种新的结构，CT(Card Table)——卡表。每⼀个Region，⼜被分成了固定⼤⼩的若⼲张卡(Card)。每⼀张卡，都⽤⼀个Byte来记录是否修改过。卡表即这些byte的集合。实际上，**如果** **把\****RS理解成⼀个概念模型，那么***\*CT就可以说是\****RS的⼀种实现⽅式。**

在RS的修改上也会遇到并发的问题。因为⼀个Region可能有多个线程在并发修改，因此它们也会并发修改RS。为了避免这样⼀种冲突，G1垃圾回收器进⼀步把RS划分成了多个哈希表。每⼀个线程都在各⾃的哈希表⾥⾯修改。最终，从逻辑上来说，RS就是这些哈希表的集合。哈希表是实现RS的⼀种通 常的⽅式之⼀。它有⼀个极⼤的好处就是能够去除重复。这意味着，RS的⼤⼩将和修改的指针数量相当。⽽在不去重的情况下，RS的数量和写操作的数量相当。

图中RS的虚线表名的是，**RS\****并不是⼀个和***\*Card Table\****独⽴的**，不同的数据结构，⽽是指RS是⼀个概念模型。实际上，**Card Table***\*是\****RS***\*的⼀种实现⽅式**。

### 4.12.12 G1回收器优化建议

1) 年轻代⼤⼩

固定年轻代的⼤⼩会覆盖暂停时间⽬标

避免使⽤-Xmn或者-XX:NewRatio等相关选项显示设置年轻代⼤⼩

2) 暂停时间⽬标不要太过严苛

评估G1 GC的吞吐量时，暂停时间⽬标不要太严苛。如果太严苛表示你愿意承受更多的垃圾回收开销，⽽这样会直接影响吞吐量

G1 GC的吞吐量⽬标是90%的应⽤程序时间和10%的垃圾回收时间

从Oracle官⽅透露出来的信息可知，回收阶段(Evacuation)其实本也有想过设计成与⽤户⼀起并发 执⾏，但这件事情做起来⽐较复杂，考虑到G1只是回收⼀部分Region，停顿时间是⽤户可控制的，所以并不迫切去实现，⽽**选择把这个特性放到了\****G1之后出现的低延迟垃圾收集器***\*(即\****ZGC)中**。另外，还考 虑到G1不是仅仅⾯向低延迟，停顿⽤户线程能够最⼤幅度提⾼垃圾收集效率，为了保证吞吐量所以才选 择了完全暂停⽤户线程的实现⽅案。

## 4.13 垃圾回收器总结

GC 发展阶段

Serial => Parallel（并⾏) => CMS（并发) => G1 => ZGC

截⽌jdk1.8 ，⼀共有7款不同垃圾收集器。每⼀款不同的垃圾收集器都有不同的特点，在具体使⽤的时候，需要根据具体的情况选择不同的垃圾回收器

**垃圾收集器**

**分类**

**作⽤位置**

**使⽤算法**

**特点**

**使⽤场景**

Serial

串⾏

新⽣代

复制算法

响应速度优先

适⽤于单CPU环境下client模式

ParNew

并⾏

新⽣代

复制算法

响应速度优先

多CPU环境下Server模式下与

CMS配合使⽤

Parallel

并⾏

新⽣代

复制算法

吞吐量优先

适⽤于后台运算⽽不需要太多交互的场景

Serial Old

串⾏

⽼年代

标记-压缩

响应速度优先

适⽤于单CPU环境下client模式

Parallel Old

并⾏

⽼年代

标记-压缩

吞吐量优先

适⽤于后台运算⽽不需要太多交互的场景

CMS

并发

⽼年代

标记-清除

响应速度优先

适⽤于互联⽹或B/S业务

G1

并发、并⾏

新、

⽼

复制;标记- 清除

响应速度优先

⾯向服务端应⽤

## 4.14 垃圾收集器的新发展

GC仍然处于⻜速发展之中，⽬前的默认选项**G1 GC在不断的进⾏改进**，很多我们原来认为的缺点， 都已经被⼤幅改进，例如：JDK 10以后，Full GC已经是并⾏运⾏，在很多场景下，其表现略优于Parallel GC的并⾏Full GC实现。

即使是Serial GC，虽然⽐较古⽼，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是⾮常⼩的，所以随着云计算的兴起，**在\****Serverless***\*等新的应⽤场景下，\****Serial GC***\*找到了新的舞台**。

⽐较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有⾮常⼤的⽤户群体，但是JDK9中已经被标记为废弃，并在JDK14版本中移除。

http://openjdk.java.net/jeps/0

**Epsilon:** A No-Op Garbage Collector (Experimental) ("No-Op(⽆操作)"回收器)

内存分配之后，程序结束。

现在G1回收器已经成为默认回收器好⼏年了，我们还看到了引⼊两个新的收集器:ZGC( JDK11出现)

和Shenandoah(Open JDK12)。主打特点:低停顿时间

#### Shenandoah

**Shenandoah，⽆疑是众多\****GC中最孤独的⼀个**。是第⼀款不由Oracle公司团队领导开发的HotSpot垃圾收集器。不可避免的收到官⽅的排挤。⽐如号称OpenJDK和OracleJDK没有区别的Oracle 公司仍拒绝在OracleJDK12中⽀持Shenandoah。

Shenandoah垃圾回收器最初由RedHat进⾏的⼀项垃圾收集器研究项⽬Pauseless GC的实现，**旨\****在针对***\*JVM\****上的内存回收实现低停顿的需求**。在2014年贡献给OpenJDK。

Red Hat研究Shenandoah团队对外宣称，**Shenandoah\****垃圾回收器的暂停时间与堆⼤⼩⽆关，这意味这⽆论将堆设置为***\*200MB\****还是***\*200GB\****，***\*99.9%\****的⽬标都可以把垃圾收集的停顿时间限制在⼗毫秒以** **内**。不过实际使⽤性能取决于实际⼯作堆的⼤⼩和⼯作负载。

Shenandoah开发团队在实际应⽤中的测试数据

**收集器**

**运⾏时间**

**总停顿**

**最⼤停顿**

**平均停顿**

Shenandoah

387.602s

320ms

89.79ms

53.01ms

G1

312.052s

11.7s

1.24s

450.12ms

CMS

285.264s

12.78s

4.39s

852.ms

Parallel Scavenge

260.092s

6.59s

3.04s

823.75ms

这是RedHat在2016年发表的论⽂数据，测试内容是使⽤ES对200GB的维基百科数据进⾏索引。从结果 看：

停顿时间⽐其他⼏款收集器确实有了质的的⻜跃，但也未实现最⼤停顿时间控制在⼗毫秒以内的⽬标。

⽽吞吐量⽅⾯出现了明显的下降，总运⾏时间是所有测试收集器⾥最⻓的。

4.15
ZGC

------

https://docs.oracle.com/en/java/javase/12/gctuning/

ZGC: A Scalable Low-Latency Garbage Collector (Experimental)（ZGC: 可伸缩的低延迟垃圾回收器，处于实验性阶段） http://openjdk.java.net/jeps/333

#### ZGC的⽬标是:在尽可能对吞吐量影响不⼤的前提下，实现任意堆内存⼤⼩下都可以把垃圾收集的停 顿时间限制控制在⼗毫秒以内的低延迟。

《深⼊理解java虚拟机》⼀书中这样定义ZGC:ZGC收集器是⼀款基于Region内存布局的，(暂时)不 设分代的，使⽤了读屏障、染⾊指针的内存多重映射等技术来实现**可并发的标记\****-压缩算法**的，以低延迟 为⾸要⽬标的⼀款垃圾收集器。

ZGC的⼯作过程可以分为4个阶段:**并发标记\****-***\*并发预备重分配\****-***\*并发重分配\****-***\*并发重映射**等。

ZGC⼏乎在所有地⽅都是并发执⾏的，除了**初始标记是\****STW的。**所有停顿时间⼏乎就耗费在初始标 记上，这部分的实际时间是⾮常少的。

虽然ZGC还在试验阶段，没有完成所有特性，但此时性能已经相当亮眼，⽤"**令⼈震惊、⾰命性**"来 形容，都不为过。

未来将在服务端、⼤内存、低延迟应⽤的场景下⾸选垃圾收集器。

JDK14之前，ZGC仅在Linux才⽀持。

尽管许多使⽤ZGC的⽤户都使⽤类Linux的环境，但在Windows和macOS上，⼈们也需要ZGC进⾏ 开发部署和测试。许多桌⾯应⽤也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS 上。

现在mac或Windows上也能使⽤ZGC了，参数配置如下：