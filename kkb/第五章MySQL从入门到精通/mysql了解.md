**课堂目标**

1、理解关系型数据库的概念

2、了解MySQL历史

3、掌握MySQL在Linux下的安装及远程连接

4、掌握基本SQL的编写

5、理解SQL的解析顺序

6、理解多表间关联

7、掌握多表关联查询及子查询

**MySQL\****介绍篇**

# 数据库概述

## 什么是数据库

**什么是关系型数据库**

**数据库和表**

**常见的数据库管理系统**

我们要学习的数据库： MySQL

**MySQL\****介绍**

**MySQL\****是什么**

**MySQL\****发展历程**

- 到了1996年10月，MySQL 11.1发布(MySQL没有2.x版本)，最开始只提供Solaris下的二进制版本。一个月后，Linux版本出现了。在接下来的两年里，MySQL被依次移植到各个平台。
- 【1999～2000年】，【MySQL AB】公司在瑞典成立。Monty雇了几个人与Sleepycat合作，开发出了【Berkeley DB引擎】, 由于BDB支持事务处理，因此MySQL从此开始支持事务处理了。
- 2000，MySQL不仅公布自己的源代码，并采用GPL(GNU General Public License)许可协议，正式进入开源世界。同年4月，MySQL对旧的存储引擎ISAM进行了整理，将其命名为MyISAM。
- 2001年，集成Heikki Tuuri的存储引擎【InnoDB】，这个引擎不仅能【支持事务处理，并且支持行级锁】。后来该引擎被证明是最为成功的MySQL事务存储引擎。【MySQL与InnoDB的正式结合版本是0】
- 2003年12月，【MySQL 0】版本发布，提供了视图、存储过程等功能。
- 【2008年1月】，【MySQL AB公司被Sun公司以10亿美金收购】，MySQL数据库进入Sun时代。在Sun

时代，Sun公司对其进行了大量的推广、优化、Bug修复等工作。

- 2008年11月，MySQL 1发布，它提供了分区、事件管理，以及基于行的复制和基于磁盘的NDB集群系统，同时修复了大量的Bug。
- 【2009年4月】，Oracle公司以74亿美元收购Sun公司，自此MySQL数据库进入Oracle时代，而其第 三方的存储引擎InnoDB早在2005年就被Oracle公司收购。
- 2010年12月，【MySQL 5发布】，其主要新特性包括半同步的复制及对SIGNAL/RESIGNAL的异常处理功能的支持，【最重要的是InnoDB存储引擎终于变为当前MySQL的默认存储引擎】。MySQL 5.5不是时隔两年后的一次简单的版本更新，而是加强了MySQL各个方面在企业级的特性。Oracle公司同时也承诺MySQL 5.5和未来版本仍是采用GPL授权的开源产品。

**SQL\****介绍**

**什么是\****SQL**

**SQL\****语言分类**

**MySQL\****基础篇**

**MySQL\****单机安装***\*(Linux)**

**MySQL\****的卸载**

**查看\****MySQL***\*软件**

**卸载\****MySQL**

查看是否还有MySQL 软件，有的话继续删除。

**安装\****MySQL**

**启动\****MySQL**

**设置\****root***\*用户密码**

例如：为root 账号设置密码为root ：

**登录\****MySQL**

##### 登录命令

**命令说明：**

**配置\****MySQL**

##### 修改内容如下：

**MySQL\****远程连接授权**

##### 授权命令

**示例**

授予root用户对所有数据库对象的全部操作权限：

##### 命令说明：

:表示授予所有的权限，此处可以指定具体的授权权限。

:表示所有库中的所有表

： myuser是数据库的用户名，%表示是任意ip地址，可以指定具体ip地址。

：mypassword是数据库的密码。

**关闭\****linux***\*的防火墙**

## 客户端远程访问

利用navicat可以远程访问MySQL

注：如果连接不上，可以按以下步骤排错

1、MySQL是否正常启动

[root@localhost ~]# ps -ef | grep mysql

root 1114 1 0 10:21 ? 00:00:00 /bin/sh /usr/bin/mysqld_safe -

-datadir=/var/lib/mysql --socket=/var/lib/mysql/mysql.sock --pid- file=/var/run/mysqld/mysqld.pid --basedir=/usr --user=mysql

mysql 1698 1114 0 10:21 ? 00:00:03 /usr/sbin/mysqld 2、查看防火墙是否关闭

[root@localhost ~]# systemctl status firewalld firewalld.service - firewalld - dynamic firewall daemon

Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled) Active: inactive (dead)

3、查看root权限为所有ip都可以访问

mysql> show grants for root;

+

+

| Grants for root@%

| GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY PASSWORD '*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B' WITH GRANT OPTION |

- 4、服务器与客户端是否可以ping通

ping 192.168.239.129

**MySQL\****单机安装***\*(Windows)**

**MySQL\****的卸载**

1、打开控制面板上的卸载程序，选择相应的MySQL程序进行卸载

2、删除MySQL文件夹，默认是C:\ProgramFiles\MySQL

3、删除MySQL数据文件目录和配置文件，默认是C:\ProgramData\MySQL

**安装\****MySQL**

从MSQL官网下载MySQL服务器安装软件包，下载为版本“mysql-installer-community-5.7.26.0.msi”。 下载网址：https://dev.mysql.com/downloads/mysql/

双击安装包，出现安装选择对话框：

点击"Next"后点击“Execute”

输入root账户的登录口令

选择将MySQL作为windows服务启动

执行即可

安装完后可以检测是否能够登录

点击ﬁnish完成安装。(*^*^_)

**启动\****MySQL**

**以\****windows***\*服务的方式启动**

MySQL安装的时候，如果是选择以Windows Service的方式启动，则在MySQL安装好后可以以windows服务的方式启动。打开windows本地服务，如下图：

此时MySQL是在windows启动后自动启动的服务，也可以选择启动类型为手动，这样可以节省机器性能。

点击启动按钮即可启动MySQL服务。

#### 以应用程序的方式启动

找到mysql的安装目录

双击mysqld即可使用。

注：该操作需要管理员权限。

**登录\****MySQL**

**使用\****Navicat***\*操作\****MySQL***\*数据库**

**Navicat\****的安装**

Navicat是一套快速、可靠并价格相当便宜的[数据库管理](https://baike.baidu.com/item/数据库管理/10509024)工具，专为简化数据库的管理及降低系统管理[成本而设。它的设计符合数据库管理员、开发人员及中小企业的需要。Navicat 是以直觉化的图形用户界面而建的，让你可以以安全并且简单的方式创建、组织、访问并共用信息。(百度百科)](https://baike.baidu.com/item/图形用户界面/3352324)

使用navicat for mysql10.0.11简体中文绿色版解压后即可使用。(*^*^_)

**打开\****navicat***\*主界面**

#### 创建新连接

点击“连接”图标，出现创建新连接操作界面，如图：

填写：连接名、主机名或ip地址、端口、用户名、密码，并勾选保存密码

参数说明：

主机名：localhost或127.0.0.1 （本机安装）

其他ip地址，如:192.168.12.128 (非本机安装，需要授权)

端口：3306 是mysql默认服务端口，不可以修改

用户名：root是MySQL的管理员账户拥有最高权限，一般开发都要有最高权限密码： 是root的账户密码，是MySQL在安装时设置的，一定不要忘记

点击连接测试，可以测试是否连接成功 !

#### 管理用户

新建用户

点击用户图标--新建用户

可以赋权限

修改用户

删除用户

#### 创建数据库

在数据库上点击右键，选择新建数据库，填写数据库名和字符集，字符集选择utf8

#### 创建表

打开数据库，点击"新建表"

主键 可以选择自动递增。**表数据的基本操作** 在表中直接操作（不推荐)

使用SQL语句操作

点击“查询”，点击“新建查询”，打开SQL窗口就可以编写SQL语句了。 点击"运行"，可以运行编写的SQL语句。

**DDL\****语句**

**数据库操作：\****database**

#### 创建数据库

**查看数据库**

查看数据库服务器中的所有的数据库:

查看某个数据库的定义的信息:

#### 删除数据库（慎用）

**其他数据库操作命令**

切换数据库：

查看正在使用的数据库:

**表操作：\****table**

#### 字段类型

##### 常用的类型有：

**创建表**

**单表约束：**

**注意：**

**查看表**

查看数据库中的所有表：

查看表结构：

#### 删除表

**修改表**

**DML\****语句**

**插入记录：\****insert**

语法：

注意：

1. 列名数与values后面的值的个数相等
2. 列的顺序与插入的值得顺序一致
3. 列名的类型与插入的值要一致.
4. 插入值得时候不能超过最大长度.
5. 值如果是字符串或者日期需要加引号’’ （一般是单引号）

例如：

INSERT

INTO

sort(sid,sname) VALUES('s001', '电器');

INSERT

INTO

sort(sid,sname) VALUES('s002', '服饰');

INSERT

INTO

sort VALUES('s003', '化妆品');

INSERT

INTO

sort VALUES('s004','书籍');

**更新记录：\****update**

语法：

注意：

1. 列名的类型与修改的值要一致.
2. 修改值得时候不能超过最大长度.
3. 值如果是字符串或者日期需要加’’.

**删除记录：\****delete**

语法：

面试题：

**DQL\****语句**

## 准备工作

创建商品表：

**完整\****DQL***\*语法顺序：**

#### 简单查询

**SQL\****语法关键字：**

##### 案例：

1. 查询所有的商品.
2. 查询商品名和商品价格.
3. 别名查询，使用的as关键字，as可以省略的. 表别名:

列别名：

1. 去掉重复值.
2. 查询结果是表达式（运算查询）：将所有商品的价格+10元进行显示.

#### 条件查询

**SQL\****语法关键字：**

##### 案例：

1. 查询商品名称为十三香的商品所有信息：
2. 查询商品价格>60元的所有的商品信息:

**where\****后的条件写法：**

#### 排序

**SQL\****语法关键字：**

##### 案例：

1. 查询所有的商品，按价格进行排序.(asc-升序,desc-降序)
2. 查询名称有新的商品的信息并且按价格降序排序.

#### 聚合函数（组函数）

##### 特点：只对单列进行操作常用的聚合函数：

**案例：**

1. 获得所有商品的价格的总和：
2. 获得所有商品的平均价格：
3. 获得所有商品的个数：

#### 分组

**SQL\****语法关键字：**

##### 案例：

1. 根据cno字段分组，分组后统计商品的个数.
2. 根据cno分组，分组统计每组商品的平均价格，并且平均价格> 60;

注意事项：

## 分页查询

关键字：

lIMIT **关键字不是** SQL92 **标准提出的关键字，它是** MySQL **独有的语法。**

通过limit 关键字， MySQL 实现了物理分页。分页分为**逻辑分页**和**物理分页**：

格式：

offset ：偏移量

rows ：每页多少行记录。案例

## 子查询

定义

位置

举例

## 其他查询语句

集合的并集（不包含重复记录）

unionall 集合的并集（包含重复记录）

**SQL\****解析顺序**

接下来再走一步，让我们看看一条SQL语句的前世今生。首先看一下示例语句：

然而它的执行顺序是这样的：

虽然自己没想到是这样的，不过一看还是很自然和谐的，从哪里获取，不断的过滤条件，要选择一样或 不一样的，排好序，那才知道要取前几条呢。

既然如此了，那就让我们根据案例一步步来看看其中的细节吧。

**现在开始\****SQL***\*解析之旅吧！**

### **1.FROM**

对FROM的左边的表和右边的表计算 笛卡尔积(CROSS JOIN) 。产生虚表VT1

|

1

|

泰国大榴莲

|

98

|

NULL

|

1

|

1

|

国外食品

|

|

1

|

泰国大榴莲

|

98

|

NULL

|

1

|

2

|

国内食品

|

|

1

|

泰国大榴莲

|

98

|

NULL

|

1

|

3

|

国内服装

|

|

2

|

泰国大枣

|

38

|

NULL

|

1

|

1

|

国外食品

|

|

2

|

泰国大枣

|

38

|

NULL

|

1

|

2

|

国内食品

|

|

2

|

泰国大枣

|

38

|

NULL

|

1

|

3

|

国内服装

|

|

3

|

新疆切糕

|

68

|

NULL

|

2

|

1

|

国外食品

|

|

3

|

新疆切糕

|

68

|

NULL

|

2

|

2

|

国内食品

|

|

3

|

新疆切糕

|

68

|

NULL

|

2

|

3

|

国内服装

|

|

4

|

十三香

|

10

|

NULL

|

2

|

1

|

国外食品

|

|

4

|

十三香

|

10

|

NULL

|

2

|

2

|

国内食品

|

|

4

|

十三香

|

10

|

NULL

|

2

|

3

|

国内服装

|

|

5

|

泰国大枣

|

20

|

NULL

|

2

|

1

|

国外食品

|

|

5

|

泰国大枣

|

20

|

NULL

|

2

|

2

|

国内食品

|

|

5

|

泰国大枣

|

20

|

NULL

|

2

|

3

|

国内服装

|

|

6

|

泰国大枣

|

98

|

NULL

|

20

|

1

|

国外食品

|

|

6

|

泰国大枣

|

98

|

NULL

|

20

|

2

|

国内食品

|

|

6

|

泰国大枣

|

98

|

NULL

|

20

|

3

|

国内服装

|

|

7

|

iPhone手机

|

800

|

NULL

|

30

|

1

| 国外食品

|

|

7

|

iPhone手机

|

800

|

NULL

|

30

|

2

| 国内食品

|

|

7

|

iPhone手机

|

800

|

NULL

|

30

|

3

| 国内服装

|

1. **ON\****过滤**

对虚表VT1 进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。

**注意：**这里因为语法限制，使用了'WHERE'代替，从中读者也可以感受到两者之间微妙的关系；

1. **OUTER JOIN\****添加外部列**

如果指定了OUTER JOIN（比如left join、 right join） ，那么保留表中未匹配的行 就会作为外部行

添加 到虚拟表VT2 中，产生虚拟表VT3 。

如果FROM子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。

### **4.** **WHERE**

对虚拟表VT3 进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4 中。

##### 注意：

此时因为分组，不能使用聚合运算；也不能使用_SELECT_中创建的别名；

**与\****ON***\*的区别：**

如果有外部列，_ON_针对过滤的是关联表，主表（保留表）会返回所有的列； 如果没有添加外部列，两者的效果是一样的；

##### 应用：

对主表的过滤应该放在WHERE；

对于关联表，先条件查询后连接则用ON，先连接后条件查询则用WHERE；

### **5.** **GROUP BY**

根据group by子句中的列，对VT4中的记录进行分组操作，产生 虚拟表VT5 。

##### 注意：

其后处理过程的语句，如SELECT,HAVING，所用到的列必须包含在GROUP BY中。对于没有出现的，得用聚合函数；

##### 原因：

GROUP BY改变了对表的引用，将其转换为新的引用方式，能够对其进行下一级逻辑操作的列会减少；

##### 我的理解是：

根据分组字段，将具有相同分组字段的记录归并成一条记录，因为每一个分组只能返回一条记录，除非 是被过滤掉了，而不在分组字段里面的字段可能会有多个值，多个值是无法放进一条记录的，所以必须 通过聚合函数将这些具有多值的列转换成单值；

### **6.** **HAVING**

对虚拟表VT5 应用having过滤，只有符合的记录才会被 插入到虚拟表VT6 中。

|

5 | 泰国大枣

|

20

|

NULL

|

2

|

2

| 国内食品

|

|

2 | 泰国大枣

|

38

|

NULL

|

1

|

1

| 国外食品

|

### **7.SELECT**

这个子句对SELECT子句中的元素进行处理，生成VT5表。

(5-J1)计算表达式 计算SELECT 子句中的表达式，生成VT5-J1

### **8.DISTINCT**

寻找VT5-1中的重复列，并删掉，生成VT5-J2

如果在查询中指定了DISTINCT子句，则会创建一张内存临时表（如果内存放不下，就需要存放在硬盘了）。这张临时表的表结构和上一步产生的虚拟表VT5是一样的，不同的是对进行DISTINCT操作的列增 加了一个唯一索引，以此来除重复数据。

### **9.** **ORDER BY**

从VT5-J2 中的表中，根据ORDER BY 子句的条件对结果进行排序，生成VT6表。

##### 注意：

唯一可使用SELECT中别名的地方；

1. **LIMIT\****（***\*MySQL\****特有）**

LIMIT子句从上一步得到的VT6虚拟表 中选出从指定位置开始的指定行数据。

##### 注意：

offset 和rows 的正负带来的影响；

##### 当偏移量很大时效率是很低的，可以这么做：

采用子查询的方式优化 ，在子查询里先从索引获取到最大id，然后倒序排，再取N行结果集

采用INNER JOIN优化 ，JOIN子句里也优先从索引获取ID列表，然后直接关联查询获得最终结果

## 解析顺序总结

#### 图示

**流程分析**

##### 流程说明：

**单表查询：**根据WHERE 条件过滤表中的记录，形成中间表（这个中间表对用户是不可见的）；然后根据SELECT 的选择列选择相应的列进行返回最终结果。

**两表连接查询：**对两表求积（笛卡尔积）并用ON 条件和连接连接类型进行过滤形成中间表；然后根据WHERE条件过滤中间表的记录，并根据SELECT 指定的列返回查询结果。

**多表连接查询：**先对第一个和第二个表按照两表连接做查询，然后用查询结果和第三个表做连接查 询，以此类推，直到所有的表都连接上为止，最终形成一个中间的结果表，然后根据WHERE条件 过滤中间表的记录，并根据SELECT指定的列返回查询结果。

**WHERE\****条件解析顺序**

1. MySQL ：从左往右去执行WHERE 条件的。
2. Oracle ：从右往左去执行WHERE 条件的。

# 多表之间的关系

如上图所示，实际业务数据库中的表之间都是有关系的，我们接下来主要要学习的就是如何分析表关系 及建立表关系。

1. \1. 分类表
2. \1. 商品表
3. \1. 订单表
4. 订单项表

## 表与表之间的关系

##### 表与表之间的关系，说的就是表与表之间数据的关系。一对一关系

常见实例：一夫一妻

##### 一对多关系

常见实例：会员和订单

##### 多对多关系（需要中间表实现）

常见实例：商品和订单

## 外键

如何表示表与表之间的关系呢？就是使用**外键约束**表示的。

要想理解外键，我们先去理解表的角色：**主表和从表**（需要建立关系才有了主从表的角色区分）

主从表的理解

现在我们有两张表“分类表”和“商品表”。

目前从表的声明上来说，没有关系，但是我们有个需求：

**商品应该有所属的分类**，这个时候需要将分类表和商品表建立关系，如何建立？ 按照以上需求分析：

主键外键的理解

如何操作外键

主表添加外键的格式：

主表删除外键的格式：

使用外键目的：

## 一对一关系（了解）

在实际工作中，一对一在开发中应用不多，因为一对一完全可以创建成一张表

##### 案例：一个丈夫只能有一个妻子

建表语句：

一对一关系创建方式1之**外键唯一**：

添加外键列wid，指定该列的约束为唯一（**不加唯一约束就是一对多关系**）

添加外键约束

一对一关系创建方式2之**主键做外键**：（课后作业）

思路：使用主表的主键作为外键去关联从表的主键

## 一对多关系

##### 案例：一个分类对应多个商品总结：

**注意事项：**

**一对多关系创建：**

添加外键列添加外键约束

##### 案例：

1. 在商品表中添加一条记录，该记录的cid在分类表中不存在
2. 在分类表中，删除一条记录，这条记录在商品表中有外键关联

## 多对多关系

##### 案例：同一个商品对应多个订单，一个订单对应多个商品

注意事项：

多对多关系创建：

# 多表关联查询

我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据 表中读取数据。

本章节我们将向大家介绍如何使用 的 在两个或多个表中查询数据。

你可以在 SELECT ,

和 语句中使用

的 来联合多表查询。

按照**功能**大致分为如下三类：

CROSS JOIN （交叉连接）

INNER JOIN （内连接或等值连接）。

OUTER JOIN （外连接）

## 交叉连接

关键字：

**交叉连接也叫笛卡尔积连接。笛卡尔积**是指在数学中，两个集合X 和Y 的笛卡尓积（ Cartesian product ），又称直积，表示为X*Y ，第一个对象是X 的成员而第二个对象是Y 的所有可能有序对的其中一个成员。

##### 交叉连接的表现：

隐式交叉连接

|

1

|

泰国大榴莲

|

98

|

NULL

|

1

|

1

|

国外食品

|

|

1

|

泰国大榴莲

|

98

|

NULL

|

1

|

2

|

国内食品

|

|

1

|

泰国大榴莲

|

98

|

NULL

|

1

|

3

|

国内服装

|

|

2

|

泰国大枣

|

38

|

NULL

|

1

|

1

|

国外食品

|

|

2

|

泰国大枣

|

38

|

NULL

|

1

|

2

|

国内食品

|

|

2

|

泰国大枣

|

38

|

NULL

|

1

|

3

|

国内服装

|

|

3

|

新疆切糕

|

68

|

NULL

|

2

|

1

|

国外食品

|

|

3

|

新疆切糕

|

68

|

NULL

|

2

|

2

|

国内食品

|

|

3

|

新疆切糕

|

68

|

NULL

|

2

|

3

|

国内服装

|

|

4

|

十三香

|

10

|

NULL

|

2

|

1

|

国外食品

|

|

4

|

十三香

|

10

|

NULL

|

2

|

2

|

国内食品

|

|

4

|

十三香

|

10

|

NULL

|

2

|

3

|

国内服装

|

|

5

|

泰国大枣

|

20

|

NULL

|

2

|

1

|

国外食品

|

|

5

|

泰国大枣

|

20

|

NULL

|

2

|

2

|

国内食品

|

|

5

|

泰国大枣

|

20

|

NULL

|

2

|

3

|

国内服装

|

|

6

|

泰国大枣

|

98

|

NULL

|

20

|

1

|

国外食品

|

|

6

|

泰国大枣

|

98

|

NULL

|

20

|

2

|

国内食品

|

|

6

|

泰国大枣

|

98

|

NULL

|

20

|

3

|

国内服装

|

|

7

|

iPhone手机

|

800

|

NULL

|

30

|

1

|

国外食品

|

|

7

|

iPhone手机

|

800

|

NULL

|

30

|

2

|

国内食品

|

|

7

|

iPhone手机

|

800

|

NULL

|

30

|

3

|

国内服装

|

显式交叉连接

## 内连接

关键字：

内连接也叫**等值连接**，内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行。 隐式内连接

显式内连接

## 外连接

外联接可以是左向外联接、右向外联接或完整外部联接。也就是说外连接又分为：

外连接需要有**主表或者保留表**的概念。

在 FROM 子句中指定外联接时，可以由下列几组关键字中的一组指定： 左外连接：

右外连接:

|

2

|

泰国大枣

|

38

|

NULL

|

1

|

1

| 国外食品

|

|

3

|

新疆切糕

|

68

|

NULL

|

2

|

2

| 国内食品

|

|

4

|

十三香

|

10

|

NULL

|

2

|

2

| 国内食品

|

|

5

| 泰国大枣 | 20 | NULL | 2 | 2 | 国内食品 |

|

NULL

| NULL | NULL | NULL | NULL | 3 | 国内服装 |

+

- - - - - - +

全外连接（**MySQL不支持**）：

##### 外连接总结：

通过业务需求，分析主从表

如果使用LEFT JOIN ，则主表在它左边如果使用RIGHT JOIN ，则主表在它右边

查询结果以主表为主，从表记录匹配不到，则补null