# VM⾯试

# 1 JVM运⾏时数据区区域分为哪⼏部分？

Java虚拟机所管理的内存分为以下⼏个运⾏时数据区域:

线程共享：堆、⽅法区

线程私有：虚拟机栈、本地⽅法栈、程序计数器

**jdk1.7**之前，**HotSpot\****虚拟机**对于⽅法区的实现称之为“**永久代**”， \**Permanent Generation** 。

**jdk1.8**之后，**HotSpot\****虚拟机**对于⽅法区的实现称之为“**元空间**”， \**Meta Space** 。

⽅法区是Java虚拟机规范中的定义，是⼀种规范，⽽永久代和元空间是HotSpot 虚拟机不同版本的两种实现。

# 2 什么是栈帧？栈帧存储了什么？

虚拟机栈也是线程私有，⽽且⽣命周期与线程相同，每个Java⽅法在执⾏的时候都会创建⼀个栈 帧（Stack Frame）。

栈帧(Stack Frame)是⽤于⽀持虚拟机进⾏**⽅法调⽤**和**⽅法执⾏**的数据结构。栈帧存储了⽅法的局部变量表、操作数栈、动态连接和⽅法返回地址等信息。每⼀个⽅法从调⽤⾄执⾏完成的过程，都对应着

⼀个栈帧在虚拟机栈⾥从⼊栈到出栈的过程。

# 3 为什么使⽤PC寄存器记录当前线程的执⾏地址？

因为CPU需要不停地切换线程，这时候切换回来以后，线程就得知道接着从哪开始继续执⾏。JVM 的字节码解释器就需要通过改变PC寄存器的值来明确下⼀条应该执⾏什么样的字节码指令。

# 4 PC寄存器为什么被设定为线程私有

我们都知道所谓的多线程在⼀个特定的时间段内只会执⾏其中某⼀个线程的⽅法，CPU会不停地做 任务切换，这样必然导致经常中断或恢复，如何保证分毫⽆差呢？

**为了能够准确地记录各个线程正在执⾏的当前字节码指令地址，最好的办法⾃然是为每⼀个线程都** **分配⼀个\****PC***\*寄存器**，这样⼀来各个线程之间便可以进⾏独⽴计算，从⽽不会出现相互⼲扰的情况。

由于CPU时间⽚轮换限制，众多线程在并发执⾏过程中，任何⼀个确定的时刻，⼀个处理器或者多 核处理器中的⼀个内核，只会执⾏某个线程中的⼀条指令。

这样必然导致经常中断或恢复，如何保证分毫不差呢？每个线程在创建后，都会产⽣⾃⼰的程序计 数器和栈帧，程序计数器在各个线程之间互不影响。

# 5 虚拟机栈可能会发⽣哪些异常？

1. 如果线程请求的栈深度⼤于虚拟机所允许的深度，将会抛出 **StackOverflowError** 异常；
2. 如果虚拟机栈可以动态扩展(当前⼤部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也 允许固定⻓度的虚拟机栈)，如果扩展时⽆法申请到⾜够的内存，就会抛出

异常。

# 6 本地⽅法栈的作⽤是什么？

java使⽤起来⾮常⽅便，然⽽有些层次的任务⽤java实现起来不容易，或者我们对程序的效率很在 意时，问题就来了。

有时java应⽤需要与java外⾯的环境交互。这是本地⽅法存在的主要原因，java需要与⼀些底层系 统如操作系统或某些硬件交换信息时的情况。本地⽅法正是这样⼀种交流机制：它为我们提供了⼀个⾮ 常简洁的接⼝，⽽且我们⽆需去了解java应⽤之外的繁琐的细节。

# 7 哪些信息是存储在⽅法区？

⽅法区(Method Area) 与 Java堆⼀样，是**各个线程共享的内存区域**，它⽤于存储已被**虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据**。虽然Java虚拟机规范把⽅法区描述为 堆的

⼀个逻辑部分，但是它有⼀个别名叫做 "⾮堆"。

存储示意图如下，下⾯的图⽚显示的是JVM加载类的时候，⽅法区存储的信息：

# 8 堆空间分哪⼏个部分？以及如何设置各个部分⼤⼩？

Java堆被所有线程共享，在Java虚拟机启动时创建。是虚拟机管理最⼤的⼀块内存。

Java堆是**垃圾回收**的主要区域，⽽且主要采⽤**分代回收算法**。堆进⼀步划分主要是为了更好的回收内存 或更快的分配内存。

Java虚拟机规范的描是：所有的对象实例以及数组都要在堆上分配。 堆内存空间在物理上可以不连续，逻辑上连续即可。

堆的⼤⼩可通过参数 **–Xms\****（堆的初始容量）、***\*-Xmx\****（堆的最⼤容量）** 来指定。

其中，新⽣代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。

默认的，Eden : from : to = 8 : 1 : 1 。(可以通过参数 –XX:SurvivorRatio 来设定 。） 即: Eden = 8/10 的新⽣代空间⼤⼩，from = to = 1/10 的新⽣代空间⼤⼩。

JVM 每次只会使⽤ Eden 和其中的⼀块 Survivor 区域来为对象服务，所以⽆论什么时候，总是有

⼀块 Survivor 区域是空闲着的。

新⽣代实际可⽤的内存空间为 9/10 ( 即90% )的新⽣代空间。

-Xmn:⾄于这个参数则是对 -XX:newSize、-XX:MaxnewSize两个参数的同时配置，也就是说如果通过-Xmn来配置新⽣代的内存⼤⼩，那么-XX:newSize = -XX:MaxnewSize = -Xmn，虽然会很⽅便，但需要注意的是这个参数是在JDK1.4版本以后才使⽤的。

# 9 对象分配过程

为新对象分配内存是⼀件⾮常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在 哪⾥分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执⾏完内存回收 后是否会在内存空间中产⽣内存碎⽚。

1. new 的对象先放在Eden区。此区有⼤⼩限制。
   1. 当Eden区空间填满时，程序⼜需要创建对象，JVM的垃圾回收器将对Eden区进⾏垃圾回收(Minor GC)，将Eden区中的不再被其他对象所引⽤的对象进⾏销毁。再加载新的对象放到Eden区。
2. 然后将Eden区中的剩余对象移动到Survivor 0区。
   1. 如果再次触发垃圾回收，此时上次幸存下来的放到Survivor 0区的，如果没有回收，就会放到Survivor 1区。
3. 如果再次经历垃圾回收，此时会重新放回Survivor 0区，接着再去Survivor 1区。
4. 什么时候去⽼年代呢？可以设置次数。默认是15次。可以设置参数: -XX:MaxTenuringThreshold=

进⾏设置。

1. 在⽼年代，相当悠闲。当养⽼区内存不⾜是，再此触发GC：Major GC，进⾏⽼年代的内存清理。
2. 若⽼年代执⾏了 Major GC 之后发现依然⽆法进⾏对象的保存，就会产⽣OOM异常。

java.lang.OutOfMemoryError: Java Heap Space

# 10

# 元空间和永久代有什么不⼀样，为什么要元空间替换永 久代？

Java7及以前版本的细化JVM结构图

从图中可以看出，在7以及之前堆和⽅法区连在了⼀起，但这并不能说堆和⽅法区是⼀起的，它们在逻 辑上依旧是分开的。但在物理上来说，它们⼜是连续的⼀块内存，下⾯的图可能可以帮助我们更好的理 解。

什么是永久代

⾸先我们来认识⼀下永久代的概念

“永久代(Permanet Generation，也称PermGen)”。对于习惯了在HotSpot虚拟机上开发、部署的程序员来说，很多⼈都愿意将⽅法区称作永久代。

本质上来讲两者并不等价，仅因为Hotspot将GC分代扩展⾄⽅法区，或者说使⽤永久代来实现⽅法区。 在其他虚拟机上是没有永久代的概念的，永久代是Hotspot针对该规范进⾏的实现。

再重复⼀遍就是，**Java7\****及以前版本的***\*Hotspot\****中⽅法区位于永久代中**。同时，永久代和堆是相互隔离的，但它们使⽤的物理内存是连续的。

然后，在Java8中，时代变了，Hotspot取消了永久代。

永久代真的成了永久的记忆。永久代的参数-XX:PermSize和-XX:MaxPermSize也随之失效。对于

Java8，HotSpots取消了永久代，那么是不是就没有⽅法区了呢？

当然不是，⽅法区只是⼀个规范，只不过它的实现变了。

### 同时，元空间不再与堆连续，⽽且是存在于本地内存（Native memory）。

针对Java8的调整，我们再次对内存结构图进⾏调整。

元空间存在于本地内存，意味着只要本地内存⾜够，它不会出现像永久代中的

“java.lang.OutOfMemoryError: PermGenspace”

默认情况下元空间是可以⽆限使⽤本地内存的，但为了不让它如此膨胀，JVM同样提供了参数来限制它 使⽤的使⽤。

-**XX:MetaspaceSize**，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进⾏类型卸载，同时GC会对该值进⾏调整：如果释放了⼤量的空间，就适当的降低该值；如 果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提⾼该值。

-**XX:MaxMetaspaceSize**，可以为class metadata分配的最⼤空间。默认是没有限制的。

-**XX:MinMetaspaceFreeRatio**，在GC之后，最⼩的Metaspace剩余空间容量的百分⽐

-**XX:MaxMetaspaceFreeRatio**，在GC之后，最⼤的Metaspace剩余空间容量的百分⽐

表⾯上看是为了避免OOM异常。因为通常使⽤PermSize和MaxPermSize设置永久代的⼤⼩就决定了永 久代的上限，但是不是总能知道应该设置为多⼤合适, 如果使⽤默认值很容易遇到OOM错误。

**当使⽤元空间时，可以加载多少类的元数据就不再由\****MaxPermSize***\*控制\****,** **⽽由系统的实际可⽤空间来控制。**

# 11 堆外内存是什么？它有什么样的作⽤？

Java中的对象都是在JVM堆中分配的，其好处在于开发者不⽤关⼼对象的回收。但有利必有弊，堆 内内存主要有两个缺点：

1. GC是有成本的，堆中的对象数量越多，GC的开销也会越⼤。
   1. 使⽤堆内内存进⾏⽂件、⽹络的IO时，JVM会使⽤堆外内存做⼀次额外的中转，也就是会多⼀次 内存拷⻉。

和堆内内存相对应，堆外内存就是**把内存对象分配在\****Java***\*虚拟机堆以外的内存**，这些内存直接受操 作系统管理（⽽不是虚拟机），这样做的结果就是能够在⼀定程度上减少垃圾回收对应⽤程序造成的影 响。

HeapByteBuffer与DirectByteBuffer，在原理上，前者可以看出分配的buffer是在heap区域的， 其实真正flush到远程的时候会先拷⻉得到直接内存，再做下⼀步操作（考虑细节还会到OS级别的内核 区直接内存），其实发送静态⽂件最快速的⽅法是通过OS级别的send_file，只会经过OS⼀个内核拷

⻉，⽽不会来回拷⻉；在NIO的框架下，很多框架会采⽤DirectByteBuffer来操作，这样分配的内存不 再是在java heap上，⽽是在C heap上，经过性能测试，可以得到⾮常快速的⽹络交互，在⼤量的⽹络交互下，⼀般速度会⽐HeapByteBuffer要快速好⼏倍。

直接内存（Direct Memory）并不是虚拟机运⾏时数据区的⼀部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使⽤，⽽且也可能导致OutOfMemoryError 异常出现，所以我们放到这⾥⼀起讲解。 在JDK 1.4 中新加⼊了NIO（New Input/Output）类，引⼊了⼀种基于通道

（Channel）与缓冲区（Buffer）的I/O ⽅式，它可以使⽤Native 函数库直接分配堆外内存，然后通过

⼀个存储在Java 堆⾥⾯的DirectByteBuffer 对象作为这块内存的引⽤进⾏操作。这样能在⼀些场景中显著提⾼性能，因为避免了在Java 堆和Native 堆中来回复制数据。

堆外内存的实现

Java中分配堆外内存的⽅式有两种，⼀是通过ByteBuffer.java#allocateDirect 得到以⼀个DirectByteBuffer对象，⼆是直接调⽤ Unsafe.java#allocateMemory 分配内存，但Unsafe只能在JDK的代码中调⽤，⼀般不会直接使⽤该⽅法分配内存。

堆外内存的优点和缺点

堆外内存，其实就是不受JVM控制的内存。相⽐于堆内内存有⼏个优势：

- 减少了垃圾回收的⼯作，因为垃圾回收会暂停其他的⼯作（可能使⽤多线程或者时间⽚的⽅式， 根本感觉不到）
- 加快了复制的速度。因为堆内在flush到远程时，会先复制到直接内存（⾮堆内存），然后在发 送；⽽堆外内存相当于省略掉了这个⼯作。

⽽福之祸所依，⾃然也有不好的⼀⾯：

1 堆外内存难以控制，如果内存泄漏，那么很难排查

2 堆外内存相对来说，不适合存储很复杂的对象。⼀般简单的对象或者扁平化的⽐较适合。

优点概述为：

1、减少GC时间

2、进程间可以共享,减少虚拟机间的复制

堆外内存的使⽤场景

**适合⻓期存在或能复⽤的场景** : 堆外内存分配回收也是有开销的，所以适合⻓期存在的对象

**适合注重稳定的场景** : 堆外内存能有效避免因GC导致的暂停问题。

**适合简单对象的存储**:因为堆外内存只能存储字节数组，所以对于复杂的DTO对象，每次存储/读取都需 要序列化/反序列化，

**适合注重\****IO***\*效率的场景**:⽤堆外内存读写⽂件性能更好

# 12 逃逸分析有⼏种类型？

逃逸分析(Escape Analysis)是⽬前Java虚拟机中⽐较前沿的优化技术。这是⼀种可以**有效减少\****Java** **程序\****中同步负载和内存堆分配压⼒的跨函数全局数据流分析算法**。通过**逃逸分析**，Java Hotspot编译器能够分析出⼀个**新的对象的引⽤的使⽤范围**从⽽决定是否要**将这个对象分配到堆上**。

逃逸分析的基本⾏为就是分析对象动态作⽤域当⼀个对象在⽅法中被定义后，它可能被外部⽅法所引

⽤，例如作为调⽤参数传递到其他地⽅中，称为⽅法逃逸

逃逸分析包括：

全局变量赋值逃逸

⽅法返回值逃逸实例引⽤发⽣逃逸

线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量

# 13

# 为什么要使⽤双亲委托这种模型呢？为什么需要破坏双 亲委派？

**启动类加载器\****(Bootstrap ClassLoader)**： 负责加载 JAVA_HOME\lib ⽬录中的，

或通过-Xbootclasspath参数指定路径中的，

且被虚拟机认可（按⽂件名识别，如rt.jar）的类。 由C++实现，不是ClassLoader⼦类

### 扩展类加载器(Extension ClassLoader)：

负责加载 JAVA_HOME\lib\ext ⽬录中的，

或通过java.ext.dirs系统变量指定路径中的类库。

### 应⽤程序类加载器(Application ClassLoader)：

负责加载⽤户路径（classpath）上的类库。

采⽤双亲委派的⼀个好处是：

⽐如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶 层的启动类加载器进⾏加载，这样就保证了使⽤不同的类加载器最终得到的都是同样⼀个Object对 象。

### 为什么要使⽤双亲委托这种模型呢？

因为这样可以避免重复加载，当⽗亲已经加载了该类的时候，就没有必要⼦ClassLoader再加载⼀

次。

考虑到安全因素，我们试想⼀下，如果不使⽤这种委托模式，那我们就可以随时使⽤⾃定义的String来动态替代java核⼼api中定义的类型，这样会存在⾮常⼤的安全隐患，⽽双亲委托的⽅式，就可 以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以⽤户⾃定义的ClassLoader永远也⽆法加载⼀个⾃⼰写的String，除⾮你改变JDK中ClassLoader搜索类的 默认算法。

### 为什么需要破坏双亲委派？

因为在某些情况下⽗类加载器需要加载的class⽂件由于受到加载范围的限制，⽗类加载器⽆法加 载到需要的⽂件，这个时候就需要委托⼦类加载器进⾏加载。

⽽按照双亲委派模式的话，是⼦类委托⽗类加载器去加载class⽂件。这个时候需要破坏双亲委派 模式才能加载成功⽗类加载器需要的类。也就是说⽗类会委托⼦类去加载它需要的class⽂件。

以Driver接⼝为例，由于Driver接⼝定义在jdk当中的，⽽其实现由各个数据库的服务商来提供，

⽐如mysql的就写了MySQL Connector，这些实现类都是以jar包的形式放到classpath⽬录下。

# 14 OSGi类加载机制类加载机制是如何实现

为了实现**代码热替换，模块化和动态化**，就像⿏标⼀样即插即⽤，双亲委派这种树状的加载器就难 以胜任，于是出现了 OSGI 加载模型，OSGI ⾥每个程序模块（Bundle，就是普通的 jar 包, 只是加⼊了特殊的头信息，是最⼩的部署模块）都会有⾃⼰的类加载器，当需要更换程序时，就连同 Bundle 和类加载器⼀起替换，是⼀种⽹状的加载模型，Bundle 间互相委托加载，并不是层次化的。

Java 类加载机制的隔离是通过不同类加载器加载指定⽬录来实现的，类加载的共享机制是通过双亲委派模型来实现，⽽ OSGI 实现隔离靠的是每个 Bundle 都⾃带⼀个独⽴的类加载器 ClassLoader。

OSGI 加载 Bundle 模块的顺序

1. ⾸先检查包名是否以 * 开头，或者是否在⼀个特定的配置⽂件

（org.osgi.framework.bootdelegation）中定义。如果是，则 bundle 类加载器⽴即委托给⽗类加载器（通常是 Application 类加载器），如果不是则进⼊ 2

1. 检查是否在 Import-Package、Require-Bundle 委派列表⾥，如果是委托给对应 Bundle 类加载器，如果不是，进⼊ 3
   1. 检查是否在当前 Bundle 的 Classpath ⾥，如果是使⽤⾃⼰的类加载器加载，如果不是，进⼊ 4
2. 搜索可能附加在当前 bundle 上的 fragment 中的内部类，找到则委派给 Fragment bundle 类加载器加载，如果找不到，进⼊ 5
   1. 查找动态导⼊列表⾥的 Bundle，委派给对应的类加载器加载，否则类加载失败

如果⽤ Java 的结构的项⽬去部署，当项⽬复杂度提升时，每次上线，代码只是增加或者修改了部分功能，但都得关掉服务，重新部署所有的代码和配置，管理沟通成本都很⾼，很容产⽣线上事 故，⽽ OSGI 的应⽤是⼀个模块化的系统，避免了部署时 jar 或 classpath 错综复杂依赖管理，发布应⽤和更新应⽤都很强⼤，可以热替换特定的 Bundle 模块，提⾼部署可靠性。

# 15 Java内存模型是什么

Java的内存模型( Java Memory Model )简称**JMM**，**JMM\****定义了***\*Java\****虚拟机（***\*JVM\****）在计算机内存***\*(RAM)\****中的⼯作⽅式。**

⾸先应该明⽩，Java内存模型是⼀个规范，主要规定了以下两点：

**1)**规定了⼀个线程如何以及何时可以看到其他线程修改过后的共享变量的值，即**线程之间共享变量的可**

**⻅性**。

### 2) 如何在需要的时候对共享变量进⾏同步。

⽽在并发编程中，我们所要处理的两个关键问题就是这两条标准的体现：**线程之间如何通信以及线 程之间如何同步**。通信是指线程之间以何种机制来交换信息。在命令式的编程中，线程之间的通信机制 有两种：**共享内存和消息传递。**

在共享内存并发的模型⾥，线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态 来隐式进⾏通信。典型的共享内存通信⽅式就是通过共享对象进⾏通信。

在消息传递的并发模型⾥，线程之间没有公共状态，线程之间必须通过明确的发送消息来显示进⾏ 通信，在java中典型的消息传递⽅式就是wait()和notify()。

**Java\****的并发采⽤的就是共享内存模型**，Java线程之间的通信总是隐式进⾏的，整个通信过程对程序 员是完全透明的。

上⾯讲到了Java线程之间的通信采⽤的是过共享内存模型，这⾥提到的共享内存模型指的就是Java内存模型(简称JMM)，**JMM\****决定⼀个线程对共享变量的写⼊何时对另⼀个线程可⻅**。从抽象的⻆度 来看，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存（***\*main memory\****）中，每个线程都有⼀个私有的本地内存（***\*local memory\****），本地内存中存储了该线程以读***\*/\****写共享变量的副本**。本地内存是JMM的⼀个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区， 寄存器以及其他的硬件和编译器优化。

从上图来看，线程A与线程B之间如要通信的话，必须要经历下⾯2个步骤：

- ⾸先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
- 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 下⾯通过示意图来说明这两个步骤：

如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执⾏时，把更新后的x值（假设值为1）临时存放在⾃⼰的本地内存A中。当线程A和线程B 需要通信时，线程A⾸先会把⾃⼰本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了 1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。

从整体来看，这两个步骤实质上是线程A在向线程B发送消息，⽽且这个通信过程必须要经过主内 存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可⻅性保证。

# 16 垃圾回收中检测垃圾的算法有哪些？

### 1 引⽤计数算法（Reference Counting）

引⽤计数算法：通过判断对象的引⽤数量来决定对象是否可以被回收。

引⽤计数算法是垃圾收集器中的早期策略。在这种⽅法中，堆中的每个对象实例都有⼀个引⽤计数。当⼀个对象被创建时，且将该对象实例分配给⼀个引⽤变量，该对象实例的引⽤计数设置为 1。当任何其它变量被赋值为这个对象的引⽤时，对象实例的引⽤计数加 1（a = b，则b引⽤的对象实例的计数器加 1），但当⼀个对象实例的某个引⽤超过了⽣命周期或者被设置为⼀个新值时，对象实例的引⽤计数减 1。特别地，当⼀个对象实例被垃圾收集时，它引⽤的任何对象实例的引⽤计数器均减 1。任何

引⽤计数为0的对象实例可以被当作垃圾收集。

引⽤计数收集器可以很快的执⾏，并且交织在程序运⾏中，对程序需要不被⻓时间打断的实时环境

⽐较有利，但其很难解决**对象之间相互循环引⽤**的问题。

### 2 可达性分析算法（Rearchability Analysis）

可达性分析算法是通过判断对象的引⽤链是否可达来决定对象是否可以被回收。

可达性分析算法是从离散数学中的图论引⼊的，程序把所有的引⽤关系看作⼀张图，通过⼀系列的 名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所⾛过的路径称为引⽤链

（Reference Chain）。当⼀个对象到 GC Roots 没有任何引⽤链相连（⽤图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可⽤的，如下图所示。

# 17 可作为 GC Root 的对象包括哪些？

在java中，可作为 GC Root 的对象包括以下⼏种：

- 虚拟机栈(栈帧中的局部变量表)中引⽤的对象；

⽐如:各个线程被调⽤的⽅法中使⽤的参数、局部变量等。

- ⽅法区中类静态属性引⽤的对象；

⽐如:java类的引⽤类型静态变量

3) ⽅法区中常量引⽤的对象；

⽐如:字符串常量池(String Table)⾥的引⽤4)本地⽅法栈中Native⽅法引⽤的对象；

5) 所有被同步锁synchronized持有的对象；

- java虚拟机内部的引⽤；

⽐如:基本数据类型对应的Class对象，⼀些异常对象(如:NullPointerException、

OutOfMemoryError)，系统类加载器

- 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

由于Root采⽤栈⽅式存放变量和指针，所以如果⼀个指针，它**保存了堆内存⾥⾯的对象地址，但是**

**⾃⼰⼜不存放在堆内存⾥⾯**，那它就是⼀个Root。

# 18 垃圾收集算法有哪些？以及各⾃的特点是什么？

### 对⽐三种算法

**标记\****-***\*清除**

**标记\****-***\*压缩**

**复制算法**

速度

中等

最慢

最快

空间开销

少(但会堆积碎⽚)

少(不堆积碎⽚)

通常需要活对象的2倍⼤⼩(不堆积碎⽚)

移动对象

否

是

是

效率上来说，复制算法是最快的，但是却浪费了太多的内存。

⽽为了兼顾上⾯提到的三个指标，**标记\****-***\*整理算法相对来说更平滑⼀些**，但是效率上不尽如⼈意， 它⽐复制算法多了⼀个标记的阶段，⽐标记-清除多了⼀个整理内存的阶段。

# 19

# 常⻅的垃圾收集器有哪些？以及他们之间可以怎样搭 配？

如果说垃圾收集算法是内存回收的⽅法论，那么垃圾收集器就是内存回收的具体实现。下图展示 了7种作⽤于不同分代的收集器，其中⽤于回收新⽣代的收集器包括Serial、PraNew、Parallel Scavenge，回收⽼年代的收集器包括Serial Old、Parallel Old、CMS，还有⽤于回收整个Java堆的G1 收集器。不同收集器之间的连线表示它们可以搭配使⽤。

GC 发展阶段

Serial => Parallel（并⾏) => CMS（并发) => G1 => ZGC

截⽌jdk1.8 ，⼀共有7款不同垃圾收集器。每⼀款不同的垃圾收集器都有不同的特点，在具体使⽤的时候，需要根据具体的情况选择不同的垃圾回收器

**垃圾收集器**

**分类**

**作⽤位置**

**使⽤算法**

**特点**

**使⽤场景**

Serial

串⾏

新⽣代

复制算法

响应速度优先

适⽤于单CPU环境下client模式

ParNew

并⾏

新⽣代

复制算法

响应速度优先

多CPU环境下Server模式下与

CMS配合使⽤

Parallel

并⾏

新⽣代

复制算法

吞吐量优先

适⽤于后台运算⽽不需要太多交互的场景

Serial Old

串⾏

⽼年代

标记-压缩

响应速度优先

适⽤于单CPU环境下client模式

Parallel Old

并⾏

⽼年代

标记-压缩

吞吐量优先

适⽤于后台运算⽽不需要太多交互的场景

CMS

并发

⽼年代

标记-清除

响应速度优先

适⽤于互联⽹或B/S业务

G1

并发、并⾏

新、

⽼

复制;标记- 清除

响应速度优先

⾯向服务端应⽤

# 20 G1垃圾收集器有什么样的特点以及在什么场景使⽤？

从JDK(1.3)开始，HotSpot团队⼀直努⼒朝着⾼效收集、减少停顿(STW: Stop The World)的⽅向努

⼒，也贡献了从串⾏Serial收集器、到并⾏收集器Parallerl收集器，再到CMS并发收集器，乃⾄如今的

G1在内的⼀系列优秀的垃圾收集器。

G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之⼀。早在JDK7就已加⼊JVM的收集器⼤家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器⼀样，G1也是关注最

⼩时延的垃圾回收器，也同样适合⼤尺⼨堆内存的垃圾收集，官⽅也推荐使⽤G1来代替选择CMS。

### 1. G1收集器的最⼤特点

G1最⼤的特点是引⼊分区的思路，弱化了分代的概念。

合理利⽤垃圾收集各个周期的资源，解决了其他收集器甚⾄CMS的众多缺陷。

### 2. G1相⽐较CMS的改进

算法： G1基于标记-整理算法, 不会产⽣空间碎⽚，分配⼤对象时不会⽆法得到连续的空间⽽提前触发⼀次FULL GC。

停顿时间可控： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应⽤雪崩现象。

并⾏与并发：G1能更充分的利⽤CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。

### 3. G1收集器的应⽤场景

G1垃圾收集算法主要应⽤在多CPU⼤内存的服务中，在满⾜⾼吞吐量的同时，尽可能的满⾜垃圾回收时 的暂停时间。

就⽬前⽽⾔、CMS还是默认⾸选的GC策略、可能在以下场景下G1更适合： 服务端多核CPU、JVM内存占⽤较⼤的应⽤（⾄少⼤于4G）

应⽤在运⾏过程中会产⽣⼤量内存碎⽚、需要经常压缩空间

想要更可控、可预期的GC停顿周期，防⽌⾼并发下应⽤雪崩现象

可以⽤ -XX:+UseG1GC 使⽤ G1 收集器，jdk9 默认使⽤ G1 收集器。

# 21 怎么理解G1可预测的停顿时间模型

G1会通过⼀个合理的计算模型，计算出每个Region的收集成本并量化，这样⼀来，收集器在给定了“停顿”时间限制的情况下，总是能选择⼀组恰当的Regions作为收集⽬标，让其收集开销满⾜这个限制 条件，以此达到实时收集的⽬的。**G1\****收集器之所以能建⽴可预测的停顿时间模型，是因为它可以有计划** **地避免在整个\****java***\*堆中进⾏全区域的垃圾收集**。

由于分区原因，G1可以只选取部分区域进⾏内存回收，这样缩⼩了回收的范围，因此对于全局停 顿的发⽣也能得到较好的控制。

G1跟踪各个Reion⾥⾯的垃圾堆积的价值⼤⼩(回收所获得的空间⼤⼩以及回收所需的时间的经验 值)，在后台维护⼀个优先列表，每次根据允许的收集时间，优先回收价值最⼤的Region。保证了 G1收集器在优先的时间内可以获取尽可能⾼的收集效率。

相⽐于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

### 如何建⽴可靠的停顿预测模型（满⾜⽤户设定的期望停顿时间）？

G1 收集器的停顿模型是以衰减均值（Decaying Average）为理论基础来实现的：垃圾收集过程中，G1 收集器会根据每个 Region 的**回收耗时、记忆集中的脏卡数量**等，分析得出平均值、标准偏差等。

“衰减平均值”⽐普通的平均值更能准确地代表“最近的”平均状态，通过这些信息预测现在开始回收 的话，由哪些 Region 组成回收集才能在不超期望停顿时间的约束下获得最⾼收益。

# 22 G1主要回收环节

G1 GC的垃圾回收过程主要包含以下三个环节:

### 年轻代GC (Young GC)

**⽼年代并发标记过程\****(Concurrent Marking)**

### 混合回收(Mixed GC)

(如果需要，单线程、独占式、⾼强度的Full GC还是继续存在的。Full GC针对GC 的评估失败提供了⼀种失败的保护机制，即强⼒回收。)

### Young GC -> Young GC + concurrent mark -> mixed GC 顺序，进⾏垃圾回收。

**年轻代\****GC**

应⽤程序分配内存，当年轻代的Eden区⽤尽时开始年轻代回收过程；G1的年轻代收集阶段是⼀个 **并⾏的独占式收集器**。在年轻代回收期，G1 GC暂停所有的应⽤程序线程，启动多线程执⾏年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者⽼年代区间，也有可能是两个区间都会涉及。

### ⽼年代并发标记(Concurrent Marking)

当堆内存使⽤达到⼀定值(默认是45%)时，开始⽼年代并发标记过程。

### 混合回收(Mixed GC)

标记完成⻢上开始混合回收过程。对于⼀个混合回收期，G1 GC从⽼年代移动存活对象到空闲区间，这些空闲区间也就成为了⽼年代的⼀部分。和年轻代不同，⽼年代的G1回收器和其他GC不同，G1 的⽼年代回收器不需要整个⽼年代被回收，⼀次主要扫描/回收⼀⼩部分⽼年代Region就可以了。同 时，这个⽼年代Region是和年轻代⼀起被回收的。

# 23 JVM调优指标有哪些？

吞吐量:运⾏⽤户代码的时间占总运⾏时间的⽐例 （总运⾏时间=程序的运⾏时间+内存回收的时间）；

暂停时间:执⾏垃圾收集时，程序的⼯作线程被暂停的时间； 内存占⽤:java堆区所占的内存⼤⼩；

吞吐量就是CPU⽤于运⾏⽤户代码的时间与CPU总消耗的时间的⽐值，即吞吐量=运⾏⽤户代码时 间/(运⾏⽤户代码时间+垃圾收集时间)。⽐如：虚拟机总共运⾏了100分钟，其中垃圾收集花掉1分钟， 那么吞吐量就是99%。这种情况下，应⽤程序能容忍较⾼的暂停时间，因此，⾼吞吐量的应⽤程序有更

⻓的时间基准，快速响应是不必考虑的。

暂停时间是指⼀个时间段内应⽤程序线程暂停，让GC线程执⾏的状态。⽐如：GC期间100毫秒的 暂停时间意味这在这100毫秒期间内没有应⽤程序线程是活动的。

**注重吞吐量**：吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2= 0.4 s

**注重低延迟**：暂停时间优先，意味这尽可能让单次STW的时间最短:0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5 s

这三者共同构成⼀个”不可能三⻆“。三者总体的表现会随着技术进步⽽越来越好。⼀款优秀的收集 器通常最多同时满⾜其中的两项。

简单来说，主要抓住两点:

### 吞吐量暂停时间

在设计(或使⽤)GC算法时，必须确定我们的⽬标:⼀个GC算法只可能针对两个⽬标之⼀(即只专注 于较⼤吞吐量或最⼩暂停时间)，或尝试找⼀个⼆者的折衷。

现在标准，**在最⼤吞吐量优先的情况下，降低停顿时间。**

# 24 使⽤过哪些jdk命令，并说明各⾃的作⽤是什么

## 1 jps

jps:Java Virtual Machine Process Status Tool

查看Java进程 ，相当于Linux下的ps命令，只不过它只列出Java进程。

## 2 jstat

jstat:JVM Statistics Monitoring Tool

jstat可以查看Java程序运⾏时相关信息，可以通过它查看堆信息的相关情况

## 3 jinfo

jinfo：Java Configuration Info

jinfo可以⽤来查看正在运⾏的java程序的扩展参数，甚⾄⽀持运⾏时，修改部分参数

## 4 jmap

jmap:Memory Map

jmap⽤来查看堆内存使⽤状况，⼀般结合jhat使⽤。jmap语法格式如下：

**参数：**

## 5 jhat

jhat:Java Heap Analysis Tool，jhat 命令解析Java堆转储⽂件,并启动⼀个 web server. 然后⽤浏览器来查看/浏览 dump 出来的 heap. jhat 命令⽀持预先设计的查询, ⽐如显示某个类的所有实例. 还⽀持对象查询语⾔(OQL, Object Query Language)。 OQL有点类似SQL,专⻔⽤来查询堆转储。 OQL相关的帮助信息可以在 jhat 命令所提供的服务器⻚⾯最底部. 如果使⽤默认端⼝, 则OQL帮助信息⻚⾯为: http:

//localhost:7000/oqlhelp/ Java⽣成堆转储的⽅式有多种:

使⽤ 选项可以在JVM运⾏时获取 heap dump.

使⽤ 选项通过 HotSpotDiagnosticMXBean 从运⾏时获得堆转储。

在虚拟机启动时如果指定了

**OutOfMemoryError** 时, 会⾃动执⾏堆转储。

选项, 则抛出

使⽤ 命令。

## 6 jstack

jstack：Java Stack Trace，jstack是java虚拟机⾃带的⼀种堆栈跟踪⼯具。jstack⽤于⽣成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每⼀条线程正在执⾏的⽅法堆栈的集合，⽣成线 程快照的主要⽬的是定位线程出现⻓时间停顿的原因，如**线程间死锁、死循环、请求外部资源导致的⻓ 时间等待**等。 线程出现停顿的时候通过jstack来查看各个线程的调⽤堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃⽣成core⽂件，jstack⼯具可以⽤来获得core⽂件的java stack和native stack的信息，从⽽可以轻松地知道java程序是如何崩溃和在程序何处发⽣问题。另外，jstack⼯具还可以附属到正在运⾏的java程序中，看到当时运⾏的java程序的java stack和native stack的信息, 如果现在运⾏的java程序呈现hung的状态，jstack是⾮常有⽤的。

在thread dump中，要留意下⾯⼏种状态死锁，Deadlock（重点关注）

等待资源，Waiting on condition（重点关注）

等待获取监视器，Waiting on monitor entry（重点关注） 阻塞，Blocked（重点关注）

执⾏中，Runnable 暂停，Suspended

对象等待中，Object.wait() 或 TIMED_WAITING

停⽌，Parked

### 使⽤⽅式

**可选参数说明**

## 7 jconsole

Jconsole:Java Monitoring and Management Console，Java 5引⼊，⼀个内置 Java 性能分析器， 可以从命令⾏或在 GUI shell 中运⾏。您可以轻松地使⽤ JConsole来监控 Java 应⽤程序性能和跟踪Java 中的代码。

### 如何启动JConsole

如果是从命令⾏启动，使 JDK 在 PATH 上，运⾏ jconsole 即可。

如果从 GUI shell 启动，找到 JDK 安装路径，打开 bin ⽂件夹，双击 jconsole 。

# 25 使⽤过哪些JVM性能监控⼯具，并简述各⾃的作⽤是什么

## 1 VisualVM

开发⼤型 Java 应⽤程序的过程中难免遇到内存泄露、性能瓶颈等问题，⽐如⽂件、⽹络、数据库的连接未释放，未优化的算法等。随着应⽤程序的持续运⾏，可能会造成整个系统运⾏效率下降，严重 的则会造成系统崩溃。为了找出程序中隐藏的这些问题，在项⽬开发后期往往会使⽤性能分析⼯具来对 应⽤程序的性能进⾏分析和优化。

VisualVM 是⼀款免费的性能分析⼯具。它通过 jvmstat、JMX、SA（Serviceability Agent）以及Attach API 等多种⽅式从程序运⾏时获得实时数据，从⽽进⾏动态的性能分析。同时，它能⾃动选择更快更轻量级的技术尽量减少性能分析对应⽤程序造成的影响，提⾼性能分析的精度。

### 性能分析的主要⽅式

- 监视：监视是⼀种⽤来查看应⽤程序运⾏时⾏为的⼀般⽅法。通常会有多个视图（View）分别 实时地显示 CPU 使⽤情况、内存使⽤情况、线程状态以及其他⼀些有⽤的信息，以便⽤户能很快地发现问题的关键所在。
- 转储：性能分析⼯具从内存中获得当前状态数据并存储到⽂件⽤于静态的性能分析。Java 程序是通过在启动 Java 程序时添加适当的条件参数来触发转储操作的。它包括以下三种：

系统转储：JVM ⽣成的本地系统的转储，⼜称作核⼼转储。⼀般的，系统转储数据量⼤，需要平台相关的⼯具去分析，如 Windows 上的 windbg 和 Linux 上的 gdb。

Java 转储：JVM 内部⽣成的格式化后的数据，包括线程信息，类的加载信息以及堆的统计数据。通常也⽤于检测死锁。

堆转储：JVM 将所有对象的堆内容存储到⽂件。

- 快照：应⽤程序启动后，性能分析⼯具开始收集各种运⾏时数据，其中⼀些数据直接显示在监 视视图中，⽽另外⼤部分数据被保存在内部，直到⽤户要求获取快照，基于这些保存的数据的统计 信息才被显示出来。快照包含了应⽤程序在⼀段时间内的执⾏信息，通常有 CPU 快照和内存快照两种类型。

CPU 快照：主要包含了应⽤程序中函数的调⽤关系及运⾏时间，这些信息通常可以在 CPU 快照视图中进⾏查看。

内存快照：主要包含了内存的分配和使⽤情况、载⼊的所有类、存在的对象信息及对象间的引⽤关 系等。这些信息通常可以在内存快照视图中进⾏查看。

- 性能分析：性能分析是通过收集程序运⾏时的执⾏数据来帮助开发⼈员定位程序需要被优化的 部分，从⽽提⾼程序的运⾏速度或是内存使⽤效率，主要有以下三个⽅⾯：

CPU 性能分析：CPU 性能分析的主要⽬的是统计函数的调⽤情况及执⾏时间，或者更简单的情况就是统计应⽤程序的 CPU 使⽤情况。通常有 CPU 监视和 CPU 快照两种⽅式来显示 CPU 性能分析结果。

内存性能分析：内存性能分析的主要⽬的是通过统计内存使⽤情况检测可能存在的内存泄露问题及 确定优化内存使⽤的⽅向。通常有内存监视和内存快照两种⽅式来显示内存性能分析结果。

线程性能分析：线程性能分析主要⽤于在多线程应⽤程序中确定内存的问题所在。⼀般包括线程的 状态变化情况，死锁情况和某个线程在线程⽣命期内状态的分布情况等

## 2 MAT

### 介绍

MAT是⼀个强⼤的内存分析⼯具，可以快捷、有效地帮助我们找到**内存泄露**，减少内存消耗分析⼯

具，下⽂将进⾏讲解。

MAT是Memory Analyzer tool的缩写，是⼀种快速，功能丰富的Java堆分析⼯具，能帮助你查找内存泄漏和减少内存消耗。很多情况下，我们需要处理测试提供的hprof⽂件，分析内存相关问题，那么MAT也绝对是不⼆之选。

使⽤MAT，可以轻松实现以下功能：

找到最⼤的对象，因为MAT提供显示合理的累积⼤⼩（retained size）

探索对象图，包括inbound和outbound引⽤，即引⽤此对象的和此对象引出的 查找⽆法回收的对象，可以计算从垃圾收集器根到相关对象的路径

找到内存浪费，⽐如冗余的String对象，空集合对象。

### 安装

MAT安装有两种⽅式，⼀种是以eclipse插件⽅式安装，⼀种是独⽴安装。在MAT的官⽅⽂档中有相

应的安装⽂件下载，下载地址为：https://www.eclipse.org/mat/downloads.php

[若使⽤eclipse插件安装，help -> install new soft点击ADD，在弹出框中添加插件地址：http://do wnload.eclipse.org/mat/1.9.0/update-site/，也可以直接在下载⻚⾯下载离线插件包，以离线⽅](http://download.eclipse.org/mat/1.9.0/update-site/) 式安装。

独⽴安装，选择如下的版本，进⾏安装。

## 3 GCViewer

GCViewer是⼀款开源的GC⽇志分析⼯具。项⽬的 GitHub 主⻚对各个指标提供了完整的描述信息需要安装jdk才能使⽤。https://github.com/chewiebug/GCViewer

下载https://github.com/chewiebug/GCViewer/releases，

借助GCViewer⽇志分析⼯具，可以⾮常直观地分析出待调优点。可从以下⼏⽅⾯来分析：

Memory,分析Totalheap、Tenuredheap、Youngheap内存占⽤率及其他指标，理论上内存占⽤率 越⼩越好；

Pause,分析Gc pause、Fullgc pause、Total pause三个⼤项中各指标，理论上GC次数越少越好， GC时⻓越⼩越好；

## 4 Arthas

[Arthas是Alibaba开源的Java诊断⼯具，深受开发者喜爱。⽤户⽂档：https://alibaba.github.io/art](https://alibaba.github.io/arthas/)

[has/](https://alibaba.github.io/arthas/)

当你遇到以下类似问题⽽束⼿⽆策时，Arthas可以帮助你解决：

1. 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？
2. 我改的代码为什么没有执⾏到？难道是我没 commit？分⽀搞错了？
3. 遇到问题⽆法在线上 debug，难道只能通过加⽇志再重新发布吗？
4. 线上遇到某个⽤户的数据处理有问题，但线上同样⽆法 debug，线下⽆法重现！
5. 是否有⼀个全局视⻆来查看系统的运⾏状况？
6. 有什么办法可以监控到JVM的实时运⾏状态？
7. 怎么快速定位应⽤的热点，⽣成⽕焰图？

Arthas⽀持JDK 6+，⽀持Linux/Mac/Winodws，采⽤命令⾏交互模式，同时提供丰富的

⾃动补全功能，进⼀步⽅便进⾏问题的定位和诊断。

## 5 IBM HeapAnalyzer

IBM HeapAnalyzer是⽤于发现可能的Java堆泄漏的图形⼯具。

### 下载

[Download: https://public.dhe.ibm.com/software/websphere/appserv/support/tools/HeapAna lyzer/ha457.jar](https://public.dhe.ibm.com/software/websphere/appserv/support/tools/HeapAnalyzer/ha457.jar)

### 启动

java -Xmx2g -jar ha457.jar

# 26 JVM参数主要有⼏种分类

## 1 标准参数

标准参数，顾名思义，标准参数中包括功能以及输出的结果都是很稳定的，基本上**不会随着\****JVM***\*版本的变化⽽变化**。标准参数以-开头，如：java -version、java -jar等，通过java -help可以查询所有的标准参数，

## 2 ⾮标准参数

**⾮标准参数以\****-X***\*开头**，是标准参数的扩展。对应前⾯讲的标准化参数，这是⾮标准化参数。表示在 将来的JVM版本中可能会发⽣改变，但是这类以-X开始的参数变化的⽐较⼩。

我们可以通过设置⾮标准参数来配置堆的内存分配，常⽤的⾮标准参数有：

-Xmn新⽣代内存的最⼤值，包括Eden区和两个Survivor区的总和，写法如：-Xmn1024，- Xmn1024k，-Xmn1024m，-Xmn1g 。

-Xms堆内存的最⼩值，默认值是总内存/64（且⼩于1G），默认情况下，当堆中可⽤内存⼩于40% (这个值可以⽤-XX: MinHeapFreeRatio 调整，如-X:MinHeapFreeRatio=30)时，堆内存会开始增加，⼀直增加到-Xmx的⼤⼩。

-Xmx堆内存的最⼤值，默认值是总内存/64（且⼩于1G），如果Xms和Xmx都不设置，则两者⼤⼩ 会相同，默认情况下，当堆中可⽤内存⼤于70%时，堆内存会开始减少，⼀直减⼩到-Xms的⼤⼩；

整个堆的⼤⼩=年轻代⼤⼩+年⽼代⼤⼩，堆的⼤⼩不包含持久代⼤⼩，如果增⼤了年轻代，年⽼代 相应就会减⼩，官⽅默认的配置为年⽼代⼤⼩/年轻代⼤⼩=2/1左右；

建议在开发测试环境可以⽤Xms和Xmx分别设置最⼩值最⼤值，但是在线上⽣产环境，Xms和Xmx 设置的值必须⼀样，原因与年轻代⼀样——防⽌抖动；

-Xss每个线程的栈内存，默认1M，⼀般来说是不需要改的。

## 3 不稳定参数

这是我们⽇常开发中接触到最多的参数类型。这也是⾮标准化参数，相对来说不稳定，随着JVM版 本的变化可能会发⽣变化，主要⽤于JVM调优和debug。

不稳定参数以-XX 开头，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极⼤的不稳定性。如果此类参数设置合理将⼤⼤提⾼JVM的性能及稳定性。

不稳定参数分为三类：

性能参数：⽤于JVM的性能调优和内存分配控制，如内存⼤⼩的设置；

⾏为参数：⽤于改变JVM的基础⾏为，如GC的⽅式和算法的选择； 调试参数：⽤于监控、打印、输出jvm的信息；

### 不稳定参数语法规则：

布尔类型参数值：

-XX:+

-XX:-

示例：-XX:+UseG1GC：表示启⽤G1垃圾收集器

数字类型参数值：

-XX:

示例：-XX:MaxGCPauseMillis=500 ：表示设置GC的最⼤停顿时间是500ms

字符串类型参数值：

-XX:

示例：-XX:HeapDumpPath=./dump.core

# 27 如何设置参数⽣成GC⽇志

### 设置JVM GC格式⽇志的主要参数包括如下8个：

1. -XX:+PrintGC 输出简要GC⽇志
2. -XX:+PrintGCDetails 输出详细GC⽇志
3. -Xloggc:gc.log 输出GC⽇志到⽂件
4. -XX:+PrintGCTimeStamps 输出GC的时间戳（以JVM启动到当期的总时⻓的时间戳形式）
5. -XX:+PrintGCDateStamps 输出GC的时间戳（以⽇期的形式，如 2020-04- 26T21:53:59.234+0800）
6. -XX:+PrintHeapAtGC 在进⾏GC的前后打印出堆的信息
7. -verbose:gc : 在JDK 8中， -verbose:gc 是-XX:+PrintGC ⼀个别称，⽇志格式等价与： - XX:+PrintGC 。不过在JDK 9中 -XX:+PrintGC被标记为deprecated。

-verbose:gc是⼀个标准的选项，-XX:+PrintGC是⼀个实验的选项，建议使⽤-verbose:gc 替代 - XX:+PrintGC

1. -XX:+PrintReferenceGC 打印年轻代各个引⽤的数量以及时⻓

### 开启GC⽇志

多种⽅法都能开启GC的⽇志功能，其中包括：使⽤-verbose:gc或-XX:+PrintGC这两个标志中的任 意⼀个能创建基本的GC⽇志（这两个⽇志标志实际上互为别名，默认情况下的GC⽇志功能是关闭的） 使⽤-XX:+PrintGCDetails标志会创建更详细的GC⽇志

推荐使⽤-XX:+PrintGCDetails标志（这个标志默认情况下也是关闭的）；通常情况下使⽤基本的

GC⽇志很难诊断垃圾回收时发⽣的问题。

### 开启GC时间提示

除 了 使 ⽤ 详 细 的 GC ⽇ 志 ， 我 们 还 推 荐 使 ⽤ -XX:+PrintGCTimeStamps 或 者 - XX:+PrintGCDateStamps，便于我们更精确地判断⼏次GC操作之间的时间。这两个参数之间的差别在 于时间戳是相对于0（依据JVM启动的时间）的值，⽽⽇期戳（date stamp）是实际的⽇期字符串。由于⽇期戳需要进⾏格式化，所以它的效率可能会受轻微的影响，不过这种操作并不频繁，它造成的影响 也很难被我们感知。

### 指定GC⽇志路径

默认情况下GC⽇志直接输出到标准输出，不过使⽤-Xloggc:filename标志也能修改输出到某个⽂ 件。除⾮显式地使⽤-PrintGCDetails标志，否则使⽤-Xloggc会⾃动地开启基本⽇志模式。

使⽤⽇志循环（Log rotation）标志可以限制保存在GC⽇志中的数据量；

对于需要⻓时间运⾏的服务器⽽⾔，这是⼀个⾮常有⽤的标志，否则累积⼏个⽉的数据很可能会耗尽服 务器的磁盘。

### 开启⽇志滚动输出

通过-XX:+UseGCLogfileRotation -XX:NumberOfGCLogfiles=N -XX:GCLogfileSize=N标志可以控制

⽇志⽂件的循环。

默认情况下，UseGCLogfileRotation标志是关闭的。它负责打开或关闭GC⽇志滚动记录功能的。 要求必须设置 -Xloggc参数

开启UseGCLogfileRotation标志后，默认的⽂件数⽬是0（意味着不作任何限制），默认的⽇志⽂件⼤

⼩是0（同样也是不作任何限制）。

因此，为了让⽇志循环功能真正⽣效，我们必须为所有这些标志设定值。 需要注意的是：

The size of the log file at which point the log will be rotated, must be >= 8K. 设置滚动⽇志⽂件的⼤⼩，必须⼤于8k。

当前写⽇志⽂件⼤⼩超过该参数值时，⽇志将写⼊下⼀个⽂件

设置滚动⽇志⽂件的个数，必须⼤于等于1 必须设置 -Xloggc 参数

### 开启语句

**其他有⽤参数**

-XX:+PrintGCApplicationStoppedTime

打印GC造成应⽤暂停的时间

-XX:+PrintTenuringDistribution

在每次新⽣代 young GC时,输出幸存区中对象的年龄分布

# 28 什么是内存溢出？什么是内存泄漏？

内存溢出：**程序没有⾜够的内存使⽤时，就会发⽣内存溢出**。内存溢出后程序基本上就⽆法正常运⾏ 了。JVM的堆分配空间不⾜，需要检查堆设置⼤⼩（-Xmx与-Xms），代码是否存在对象⽣命周期太

⻓、持有状态时间过⻓的情况。

内存泄漏：**当程序不能及时释放内存，导致占⽤内存逐渐增加，就是内存泄漏**。内存泄漏⼀般不会导致 程序⽆法运⾏。不过持续的内存泄漏，累积到内存上限时，就会发⽣内存溢出。⽆法通过垃圾收集器进

⾏⾃动回收，需要通过找出泄漏的代码位置和原因，才好确定解决⽅案。在Java中，如果发⽣内存泄 漏，会导致GC回收不彻底，每次GC后，堆内存使⽤率逐渐增⾼。

# 29 Shallow Heap 和 Retained Heap的区别

### Shallow Size

shallow heap中⽂意思是浅堆，Shallow Size是对象本身占据的内存的⼤⼩，不包含其引⽤的对象。对于常规对象（⾮数组）的Shallow Size由其成员变量的数量和类型来定，⽽数组的ShallowSize由数组类型和数组⻓度来决定，它为数组元素⼤⼩的总和。

### Retained Size

Retained Size=当前对象⼤⼩+当前对象可直接或间接引⽤到的对象的⼤⼩总和。(间接引⽤的含义：A-

> B->C,C就是间接引⽤) ，并且排除被GC Roots直接或者间接引⽤的对象

# 30 outgoing references与incoming references的区别

outgoing references ：表示该对象的出节点（被该对象引⽤的对象）。

incoming references ：表示该对象的⼊节点（引⽤到该对象的对象）。

**拥有对象** **C** **的引⽤的所有对象都称为** **Incoming references**。在此示例中，对象 C 的“Incoming references”是对象 A、对象 B 和 C 的类对象 。

**对象** **C** **引⽤的所有对象都称为** **Outgoing References\****。**在此示例中，对象 C 的“outgoing references”是对象 D、对象 E 和 C 的类对象。

# 31 JVM 类加载机制

**加载**（将⽂件加载到内存中）

**验证**（确保class⽂件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机⾃身的安全） **准备** (准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在⽅法区中分配这些变量所使

⽤的内存空间)

**解析** (解析阶段是指虚拟机将常量池中的符号引⽤替换为直接引⽤的过程。)

**初始化** (开始真正执⾏类中定义的Java程序代码)

# 32 java 虚拟机是如何判定两个 java 类是相同的？

Java 虚拟机**不仅要看类的全名是否相同**，还要看**加载此类的类加载器是否⼀样**。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也 是不同的。⽐如⼀个 Java 类 com.example.Sample，编译之后⽣成了字节代码⽂件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class⽂件，并定义出两个java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进⾏相互赋值，会抛出运⾏时异常 **ClassCastException**。

# 33 JIT优化有哪些⼿段

公共⼦表达式的消除

⽅法内联逃逸分析

对象的栈上内存分配标量替换

同步锁消除

# 34 介绍下强引⽤、软引⽤、弱引⽤、虚引⽤

Strong Ref(强引⽤):强可达性的引⽤，对象保存在内存中，只有去掉强可达，对象才被回收，通常我们编写的代码都是Strong Ref。

Soft Ref(软引⽤):对应软可达性，只要有⾜够的内存，就⼀直保持对象，直到发现内存吃紧且没有Strong Ref时才回收对象。⼀般可⽤来实现缓存，通过java.lang.ref.SoftReference类实现。Weak Ref(弱引⽤):⽐Soft Ref更弱，当发现不存在Strong Ref时，⽴刻回收对象⽽不必等到内存吃紧的时候。通过java.lang.ref.WeakReference和java.util.WeakHashMap类实现。

Phantom Ref(虚引⽤):根本不会在内存中保持任何对象，你只能使⽤Phantom Ref本身。⼀般⽤于在进⼊finalize()⽅法后进⾏特殊的清理过程，通过 java.lang.ref.PhantomReference实现。

### java中4种引⽤的级别和强度由⾼到低依次为：强引⽤ -> 软引⽤ -> 弱引⽤ -> 虚引⽤

通过表格来说明⼀下，如下：

**引⽤类型**

**被垃圾回收时间**

**⽤途**

**⽣存时间**

强引⽤

从来不会

对象的⼀般状态

JVM停⽌运⾏时终⽌

软引⽤

当内存不⾜时

对象缓存

内存不⾜时终⽌

弱引⽤

正常垃圾回收时

对象缓存

垃圾回收后终⽌

虚引⽤

正常垃圾回收时

跟踪对象的垃圾回收

垃圾回收后终⽌

# 35 不同区域的可能异常信息

- **指针碰撞与空闲列表**

# 37 对象的finalization机制

当垃圾回收器发现没有引⽤指向⼀个对象，即:垃圾回收次对象之前，总会先调⽤这个对象的

finalize()⽅法。

finalize()⽅法允许在⼦类中被重写，**⽤于在对象被回收时进⾏资源释放**。通常在这个⽅法张中进⾏

⼀些资源释放和清理的⼯作，⽐如关闭⽂件、套接字和数据库连接等。

**永远不要主动调⽤某个对象的\****finalize()***\*⽅法**，应该交给垃圾回收机制调⽤。理由也包含下⾯三点:

在finalize()时可能会导致对象复活

finalize()⽅法的执⾏时间是没有保障的，它完全由GC线程决定，极端情况下，若不发⽣GC，则finalize()⽅法将没有执⾏机会

⼀个糟糕的finalize()会严重影响GC的性能

由于finalize()⽅法的存在，**虚拟机中的对象⼀般处于三种可能的状态。**

如果从所有的根节点都⽆法访问到某个对象，说明对象已经不再使⽤了。⼀般来说，该对象需要备 回收。但事实上，也并⾮是"⾮死不可"的。这时候他们暂时处于"缓刑"阶段。⼀个⽆法触及的对象有可 能在某⼀条件下"复活"⾃⼰，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可 能的三种状态。如下：

**可触及的**:从根节点开始，可以到达这个对象。

**可复活的\****:**对象的所有引⽤都被释放，但是对象有可能在finalize()中复活。

**不可触及的\****:**对象的finalize()被调⽤，并且没有复活，那么就会进⼊不可触及的状态。不可触及的 对象不可能被复活，因为**finalize()***\*只会被调⽤⼀次**。

以上3种状态中，是由于finalize()⽅法的存在，进⾏的区分。只有在对象不可触及是才可以被回收。