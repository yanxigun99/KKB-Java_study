开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
1
快速开发框架Spring Cloud
知识点暨面试题总结
第1次直播课
【Q-01】你曾阅读过Spring Cloud的源码吗？我们知道，Spring Cloud是通过Spring Boot集成了很多第三方框架构成的。现在准备解析Spring Cloud中某子框架的源码，若还没有找到合适的入手位置，那么从哪里开始解析可能是一个不错的选择？
【RA】我自己曾阅读过Spring Cloud中的Eureka、OpenFeign、Ribbon等的源码。对于一个未曾阅读过的子框架源码，我认为从自动配置类开始解析可能是一个不错的选择。
我们知道Spring Cloud是通过Spring Boot将其它第三方框架集成进来的。Spring Boot最大的特点就是自动配置，我们可以通过导入相关Starter来实现需求功能的自动配置、相关核心业务类实例的创建等。也就是说，核心业务类都是集中在自动配置类中的。所以从这里下手分析应该是个不错的选择。
那么从哪里可以找到这个自动配置类呢？从导入的starter依赖工程的META-INF目录中的spring.factory文件中可以找到。该文件的内容为key-value对，查找EnableAutoConfiguration的全限定性类名作为key的value，这个value就是我们要找到的自动配置类。
【Q-02】@EnableConfigurationProperties注解对于Starter的定义很重要，请谈一上你对这个注解的认识。
【RA】@EnableConfigurationProperties注解在Starter定义时主要用于读取application.yml配置文件中相关的属性，并封装到指定类型的实例中，以备Starter中的核心业务实例使用。
具体来说，它就是开启了对@ConfigurationProperties注解的Bean的自动注册，注解到Spring容器中。这种Bean有两种注册方式：在配置类使用@Bean方法注册，或直接使用该注解的value属性进行注册。若在配置类中使用@Bean注册，则需要在配置类中定义一个@Bean方法，该方法的返回值为“使用@ConfigurationProperties注解标注”的类。若直接使用该注解的value属性进行注册，则需要将这个“使用@ConfigurationProperties注解标注”的类作为value属性值出现即可。
【Q-03】Spring Boot中定义了很多条件注解，这些注解一般用于对配置类的控制。在这些条件注解中有一个@ConditionalOnMissingBean注解，你了解过嘛？请谈一下你对它的认识。
【RA】@ConditionalOnMissingBean注解是Spring Boot提供的众多条件注册中的一个。其表示的意义是，当容器中没有指定名称或指定类型的Bean时，该条件为true。不过，这里需要强调一点的是，这里要查找的“容器”是可以指定的。通过search属性指定。其search的范围有三种：仅搜索当前配置类容器；搜索所有层次的父类容器，但不包含当前配置类容器；搜索当前配置类容器及其所有层次的父类容器，这个是默认搜索范围。
【Q-04】Spring Cloud中默认情况下对于Eureka Client实例的创建中，@RefreshScope注解是比较重要的，请谈一下你对这个注解的认识。
【RA】@RefreshScope注解是Spring Cloud中定义的一个注解。该注解用于配置类，可以添
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
2
加在配置类上，也可以添加在@Bean方法上。其表示的意思是，该@Bean方法会以多例的形式生成会自动刷新的Bean实例。这种方式就等价于在Spring的xml配置文件中指定<bean/>标签的scope属性值为refresh。当然，若一个配置类上添加了该注解，则表示该配置类中的所有@Bean方法创建的实例都是@RefreshScope的。
【Q-05】Spring Cloud中默认情况下对于Eureka Client实例的创建是在EurekaClient的自动配置类中通过@Bean方法完成的。但在源码中，这个@Bean方法上同时出现了@RefreshScope、@ConditionalOnMissionBean，与@Lazy注解，从这些注解的意义来分析，是否存在矛盾呢？它们联合使用又是什么意思呢？请谈一下你的看法。
【RA】首先来说，这三个注解的意义都是比较复杂的。
@RefreshScope注解是Spring Cloud中定义的一个注解。其表示的意思是，该@Bean方法会以多例的形式生成会自动刷新的Bean实例。
@ConditionalOnMissionBean注解表示的意思是，只有当容器中没有@Bean要创建的实例时才会创建新的实例，即这里创建的@Bean实例是单例的。
@Lazy注解表示延迟实例化。即在当前配置类被实例化时并不会调用这里的@Bean方法去创建实例，而是在代码执行过程中，真正需要这个@Bean方法的实例时才会创建。
这三个注解的联用不存在矛盾，其要表达的意思是，这个@Bean会以延迟实例化的形式创建一个单例的对象，而该对象具有自动刷新功能。
【Q-06】Spring Cloud中大量地使用了条件注解，其中@ConditionalOnRefreshScope注解对于Eureka Client的创建非常重要。请谈一下你对这个注解的认识。
【RA】首先，关于条件注解，实际是Spring Boot中出现的内容，其一般应用于配置类中。表示只有当该条件满足时才会创建该实例。而您提到的@ConditionalOnRefreshScope注解，其实际是Eureka Client的自动配置类中的一个内部注解。该注解不同于Spring Boot中的一般性注解的是，其是一个复合条件注解，其复合的条件有三个：
 在当前类路径下具有RefreshScope类
 在容器中要具有RefreshAutoConfiguration类的实例
 指定的eureka.client.refresh.enable属性值为true。不过，其缺省值就是true。这也就是为什么我们的配置文件默认支持自动更新的原因。
只有当这个复合注解中的三个条件均成立时，@ConditionalOnRefreshScope注解才满足条件。此时才有可能会调用创建Eureka Client的@Bean方法。所以，该注解对于Eureka Client的创建非常重要。
【Q-07】你刚才已经谈过了对@ConditionalOnRefreshScope注解的认识，非常不错。不过，与这个注解相对应的另一个注解@ConditionalOnMissingRefreshScope，你是否了解？若关注过，谈一下你的认识。（不将面试者问死誓不罢休）
【RA】@ConditionalOnMissingRefreshScope我也曾了解过（看来这个面试者很厉害）。这个注解就像@ConditionalOnRefreshScope注解一样，也是一个复合条件注解，其也包含了三个条件。不同的是，这个注解中的条件是或的关系，只要满足其中一条这个注解就匹配上了。而@ConditionalOnRefreshScope注解中的三个条件是与的关系，必须所有条件均满足其才能匹配上。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
3
这个或的关系是通过让一个复合条件类继承自一个能够表示或关系的复合条件父类AnyNestedCondition实现的。这样的话，这个复合条件类中定义的多个内部条件类中，只要有一个匹配上，那么这个复合条件类就算匹配上了。
【Q-08】Spring Cloud中Eureka Client的源码中有一个非常重要的类Applications，其被称为客户端注册表。请谈一下你对它的认识。
【RA】Applications类实例中封装了来自于Eureka Server的所有注册信息，通常称其为“客户端注册表”。只所以要强调“客户端”是因为，服务端的注册表不是这样表示的，是一个Map。
该类中封装着一个非常重要的Map集合，key为微服务名称，而Value则为Application实例。Application类中封装了一个Set集合，集合元素为“可以提供该微服务的所有主机的InstanceInfo”。也就是说，Applications中封装着所有微服务的所有提供者信息。
【Q-09】Eureka源码中InstanceInfo类中具有两个最终修改时间戳，这两个时间戳对于Eureka的Server端与Client端源码的理解都比较重要。这两个时间戳你了解过吗？若了解过，请谈一下你对它们的认识。
【RA】InstanceInfo实例中封装着一个Eureka Client的所有信息，其就可以代表了一个Eureka Client。其封装的两个最终修改时间戳分别为lastDirtyTimestamp与lastUpdatedTimestamp。这两个时间戳的区别是：
 lastDirtyTimestamp：记录intance在Client被修改的时间。该修改会被传递到Server端。
 lastUpdatedTimestamp：记录intance状态在Server端被修改的时间。
【Q-10】Eureka源码中InstanceInfo类中具有两个状态属性，是哪两个，你了解过它们吗？
【RA】Eureka源码中InstanceInfo类具有两个状态属性，分别是status与overriddenStatus。下面我依次谈一下我对它们的了解。
status就是当前Instance的工作状态，其初值为UP，表示可以正常提供服务。
overriddenStatus用于记录外部对当前instance修改的状态，初值为UNKNOWN。这个状态仅在Server端是有意义的。其意义就是通过修改Server端instanceInfo的overriddenStatus的值来达到修改Server端对应instanceInfo的status的值的目的。
若要深入了解overriddenStatus的意义，就需要了解其被修改的过程。当用户通过Actuator的service-registry监控终端向某个Client提交POST状态修改请求后，该请求会被Client接收并直接再以PUT请求的方式提交给Server。Server在接收到这个请求后，会从注册表中找到该Client对应的InstanceInfo，修改其overriddenStatus，、status为指定状态。注意，用户请求提交到Client后，Client并未修改当前Client的InstanceInfo的任何状态。即Client端的该InstanceInfo的状态一直为UP状态。
那么这个overriddenStatus有什么用呢？当Server端注册表中某instanceInfo的status为UP时，其是可以被其它instance服务发现的。相反，若其status为非UP，其它instance是无法发现和使用该instance提供的服务的。Server端InstanceInfo的status是可以通过用户提交状态修改请求修改overriddenStatus而达到修改status的目的的。
例如，一旦将某InstanceInfo的overriddenStatus修改为了OUT_OF_SERVICE，则其Server端的status也就成了OUT_OF_SERVICE，此时Consumer是无法调用到该InstanceInfo对应的Provider的服务的。不过需要注意，若直接从浏览器访问该Provider，其是可以正常给出响应结果的，并且，此时查看Provider中的InstanceInfo的status，仍为UP。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
4
【Q-11】Spring Cloud中Eureka Client与Eureka Server的通信，及Eureka Server间的通信是如何实现的？请简单介绍一下。
【RA】Spring Cloud中Eureka Client与Eureka Server的通信，及Eureka Server间的通信，均采用的是Jersey框架。
Jersey框架是一个开源的RESTful框架，实现了JAX-RS规范。该框架的作用与SpringMVC是相同的，其也是用户提交URI后，在处理器中进行路由匹配，路由到指定的后台业务。这个路由功能同样也是通过处理器完成的，只不过这里的处理器不叫Controller，而叫Resource。
第2次直播课
【Q-01】Spring Cloud中Eureka Client在启动时需要从Eureka Server中下载注册表到本地进行缓存，以备进行负载均衡调用。请谈一下你对这个启动时下载注册表过程的认识。
【RA】Spring Cloud中Eureka Client在启动时需要从Eureka Server中下载注册表到本地进行缓存。这次下载属于全量下载，即要将Server端所有注册信息Applicaitons全部下载到本地并缓存。当然，若指定可以从远程Region获取，其也会通过其所连接的这个Server，将远程Region中的注册信息也全部获取到。这个过程称为获取客户端注册表。
获取“客户端注册表”最终执行的操作是，通过Jersey框架提交了一个GET请求，然后获取到的Applications实例结果。
若获取失败，其会从本地备用注册表中获取并缓存。
【Q-02】Spring Cloud中Eureka Client需要定时从Eureka Server中获取注册表信息，这个过程称为服务发现。请谈一下你对这个获取过程的认识。
【RA】Eureka Client从Eureka Server中获取注册表分为两种情况，一种是将Server中所有注册信息全部下载到当前客户端本地并进行缓存，这种称为全量获取；一种是仅获取在Server中发生变更的注册信息到本地，然后根据变更修改本地缓存中的注册信息，这种称为增量获取。当Client在启动时第一次下载就属于全量获取，而后期每30秒从Server下载一次的定时下载属于增量下载。无论是哪种情况，Client都是通过Jersey框架向Server发送了一个GET请求。只不过是，不同的获取方式，提交请求时携带的参数是不同的。
【Q-03】Spring Cloud中Eureka Client需要注册到Eureka Server中，请谈一下你对这个注册过程的认识。
【RA】Eureka Client向Eureka Server提交的注册请求，实际是通过Jersey框架完成的一次POST提交，将当前Client的封装对象intanceInfo提交到Server端，写入到Server端的注册表中。
但这个注册请求在默认情况下并不是在Client启动时直接提交的，而是在Client向Server发送续约信息时，由于其未在Server中注册，所以Server会中其返回404，在这种情况下，而引发的Client注册。当然，若Client的续约信息发生了变更Client也会提交注册请求。
【Q-04】Spring Cloud中Eureka Client需要定时从Eureka Server中更新注册信息。对于这个定时器及其执行过程，请谈一下你的看法。
【RA】Spring Cloud中Eureka Client需要定时从Eureka Server中更新注册信息。但这里是使用了one-shot action的一次性定时器实现的repeated定时执行。这个repeated过程是通过其一次性的定时任务实现的：当这个一次性定时任务执行完毕后，会调用启动下一次的定时任务。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
5
【Q-05】Spring Cloud中Eureka Client需要定时从Eureka Server中更新注册信息。这个定时任务是通过一个one-shot action的定时器完成的。其为什么不直接使用一个repeated的定时器呢？请谈一下你的看法。
【RA】Spring Cloud中Eureka Client需要定时从Eureka Server中更新注册信息。这个定时任务是通过一个one-shot action的定时器完成的。只所以选择one-shot action的定时器来完成一个repeated的事情，其主要目的就是方便控制delay，保证任务顺利完成。
定时器要执行的任务是通过网络从Server下载注册信息。而我们知道，网络传输存在不稳定性，不同的传输数据可能走的网络链路是不同的，而不同的链路的传输时间可能也是不同的。本次传输超时，下次重试可能走的链路不同就不超时了。
repeated定时器的执行原理是，本次任务的开始，必须在上一次的任务完成后，不存在超时。即只要没完成就不会通过执行下次任务进行重试。
使用one-shot action定时器完成repeated定时任务时，若本次定时任务出现了超时，则可以在下次任务执行之前增大定时器的delay。当然，若下载速率都很快，也可将已经增大的delay再进行减小。方便控制delay，保证任务的顺利完成。
【Q-06】Futue是JDK5中提供的一个接口。其方法cancel()是一个经常被用到的方法，请谈一下你对这个方法的认识。
【RA】Futue是JDK5中提供的一个JUC的接口，其用于执行一些异步任务。对于其执行的异步任务，可以通过cancel()方法尝试着进行取消。其用法为：
 若任务已经完成或已经取消，则本次取消失败。
 若任务在启动之前就调用了cancel()，则这个任务将不会再执行。
 若任务已经启动，此时再执行cancel()，那么这个执行的任务是否立即被中断，取决于cancel()方法的参数。若参数为true，则会立即中断任务的执行；若参数为false，则会让正在执行中的任务执行完毕，然后再中断。
 若cancel()方法执行完毕后，顺序执行isDone()或isCancelled()方法，这些方法均返回true。
【Q-07】Futue是JDK5中提供的一个接口。其方法get()是一个经常被用到的方法，请谈一下你对这个方法的认识。
【RA】Futue是JDK5中提供的一个JUC的接口，其用于执行一些异步任务，并通过get()方法可以获得该异步任务的结果。get()方法是一个阻塞的方法，可以为其指定阻塞的最长时长。
 若在指定时长内异步操作完成，则阻塞会被立即唤醒；
 若在指定时长内该异步操作被cancel()，则阻塞也会被立即唤醒，并抛出一个CancellationException；
 若在指定时长内未发生任务事情，则阻塞也会被唤醒，并抛出一个TimeoutException；
 若get()方法没有指定阻塞时长，则其会一直阻塞下去，直到任务完成或取消。
【Q-08】Spring Cloud中Eureka Client向Eureka Server发送增量获取注册表请求，Server会返回给Client一个delta，关于这个返回值delta，请谈一下你的看法。
【RA】Spring Cloud中Eureka Client向Eureka Server发送增量获取注册表请求，Server会返回给Client一个delta，这个delta是一个Applications类型的变量。
 Server返回的这个delta值若为null，则表示Server端基于安全考虑，禁止增量下载，其会自动进行全量下载。
 Server返回的这个delta值不为null，但其包含的application数量为0，则表示没有更新内容。若数量大于0，则表示有更新内容。有更新内容，则需要将更新添加到本地缓存
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
6
的注册表applications中。
【Q-09】Spring Cloud中Eureka Client向Eureka Server发送增量获取注册表请求，Server端是如何知道哪些intance对这个Client来说是变更过的？请谈一下你的看法。
【RA】当Eureka Server接收到Eureka Client发送的增量获取注册表请求后，其并不知道哪些instance对于这个Client来说是更新过的。但是在Server中维护着一个“最近变更队列”，无论对于哪个Client的增量请求，Server端都是将该队列中的instance变更信息发送给了Client。当然，Server中有一个定时任务，当这个instance的变更信息不再属于“最近”时，会将该instance变更信息从队列中清除。
当Client接收到Server发送的增量变更信息后，Client端有一种判断机制，可以判断出其接收到这个增量信息对它自己来说是否出现了更新丢失。即出现了队列中清除掉的变更信息，并没有更新到当前Client本地。若发生更新丢失，Client会再发起全量获取，以保证Client获取到的注册表是最完整的注册表。
【Q-10】Spring Cloud中Eureka Client从Eureka Server中增量获取到的注册信息，都是在Server端发生了变更的instanceInfo信息。这些变更信息中包含变更的类型。其中对于ADDED与MODIFIED这两种类型的变更，我们发现处理方式是相同的，为什么？请谈一下你的看法。
【RA】Eureka Client接收到的来自Server的增量注册信息后，对于添加变更与修改变更的处理方式的确是相同的，都是采用了添加变更的处理方式。其实，无论是添加的InstanceInfo还是修改的InstanceInfo，Client首先都是根据该InstanceInfo的id，从本地InstanceInfo的Set集合中将其删除，然后再将新来的变更的InstanceInfo加入Set集合。只不过，对于添加变更，其在原来的Set集合中找不到其要删除的InstanceInfo而已。
只所以能够被根据InstanceId在Set集合中进行删除，是因为Set集合的元素InstanceInfo重写了equals()方法——根据instanceId进行元素相等判断。
【Q-11】Spring Cloud中Eureka Client会向Eureka Server进行定时续约，请谈一下你对这个定时续约的认识。
【RA】Eureka Client会向Eureka Server进行定时续约，即会进行定时心跳。其最终就是通过Jersey框架向Eureka Server提交一个PUT请求。该PUT请求没有携带任何请求体，而Eureka Server仅仅就是接收到一个PUT请求。但通过请求，Server能够知道这个请求的发送者instanceId。而Eureka Server就是通过这个发送者instanceId从注册表中查找其instance信息的。当然，Server也给Client发送来了响应信息：若从Server的注册表中找到了该续约的instance，则返回该instanceInfo实例；若没有找到，则返回404。
第3次直播课
【Q-01】Spring Cloud中Eureka Client会定时检测Client的instanceInfo是否发生了变更。请谈一下你对这个定时任务的认识。
【RA】Eureka Client会定时检测Client的instanceInfo是否发生了变更，其主要是检测了两样内容：一个是检测数据中心中的关于当前instanceInfo的信息是否变更，一个是检测配置文件中当前instanceInfo中的续约信息是否变更。只要发生了变更，则将变化后的信息发送给Server，这个发送执行的是register()注册。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
7
【Q-02】Spring Cloud中Eureka Client向Eureka Server提交registrer()注册请求的时机较多，请简单总结一下。
【RA】Eureka Client向Eureka Server提交的register()注册请求的情况有三种：
 在Client实例初始化时直接提交register()注册请求
 定时发送心跳时，服务端返回404，此时Client会发出registrer()注册请求
 定时更新Client续约信息给Server时，只要Client续约信息发生变更，其提交的就是register()注册请求
【Q-03】Spring Cloud中Eureka Client在做定时更新续约信息给Server时有一个定时任务，定时查看本地配置文件中的instanceInfo是否发生了变更。这个定时任务在Eureka Client启动时通过start()启动了定时任务，该定时器是一个one-shot action定时器，其会调用InstanceInfoReplicator的run()方法。而该方法会再次启动一个one-shot action的定时任务，实现了repeated定时执行。然而，当instanceInfo的状态发生变更后会调用一个按需更新方法onDemandUpdate()，该方法同样会调用InstanceInfoReplicator的run()方法，再次启动一个one-shot action的定时任务，实现了repeated定时执行。这样的话，只要发生一次状态变更，就会启动一个repeated的定时任务持续执行下去。那么若InstanceInfo的状态多次发生变更，是否就会启动很多的一直持续执行的该定时任务了？请谈一下你的看法。
【RA】答案当然是否定的。关键就在于两点：一个是，前面题目中无论是start()方法还是InstanceInfoReplicator的run()方法，在启动了定时任务后，都会将定时任务实例future写入到一个原子引用类型的缓存中，且后放入的会将先放入的覆盖，即这个缓存中存放的始终为最后一个定时任务。第二个关键点是这个onDemandUpdate()方法。其在调用InstanceInfoReplicator的run()方法之前首先将这个缓存中的异步操作cancel()，即将最后一个定时任务结束，然后才会再启动一个新的定时任务。所以，只会同时存在一个该定时任务。
【Q-04】Spring Cloud中Eureka Client的续约配置信息默认情况下是允许动态变更的。为了限制变更的频率，Eureka Client使用了一种限流策略，是什么策略？请谈一下你对这种策略的认识。
【RA】Spring Cloud中Eureka Client的续约配置信息默认情况下是允许动态变更的。为了限制变更的频率，Eureka Client使用了令牌桶算法。
该算法实现中维护着一个队列，首先所有元素需要进入到队列中，当队列满时，未进入到队列的元素将丢弃。进入到队列中的元素是否可以被处理，需要看其是否能够从令牌桶中拿到令牌。一个元素从令牌桶中拿到一个令牌，那么令牌桶中的令牌数量就会减一。若元素生成速率较快，则其从令牌桶中获取到令牌的速率就会较大。一旦令牌桶中没有了令牌，则队列很快就会变满，那么再来的元素将被丢弃。
【Q-05】Spring Cloud中Eureka Client的哪些操作会引发客户端InstanceInfo的最新修改时间戳lastDirtyTimestamp的变化？请谈一下你的认识。
【RA】Spring Cloud中Eureka Client的操作中有两处操作可以引发客户端InstanceInfo的最新修改时间戳lastDirtyTimestamp的变化。
 在进行第一次心跳发送时，由于Server中没有发现该InstanceInfo而向其返回了404。此时的Client会修改lastDirtyTimestamp的值。
 在续约信息发生更新时修改lastDirtyTimestamp的值。
【Q-06】Spring Cloud中Eureka Client通过Actuator提交的POST请求的shutdown进行服务
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
8
下架时，其调用的下架处理方法我们从哪里找到它？请谈一下你的思路。
【RA】Spring Cloud中Eureka Client通过Actuator提交的POST请求的shutdown进行服务下架，就是要销毁Eureka Client实例。而该Eureka Client实例是在EurekaClient的自动配置类中通过@Bean方法创建的。所以，这个下架处理方法应该是@Bean注解的destroyMethod属性指定的方法。
【Q-07】Spring Cloud中Eureka Client通过Actuator提交的POST请求的shutdown进行服务下架时，其Client内部都做了些什么重要工作？请谈一下你对这个服务下架的认识。
【RA】Eureka Client通过Actuator提交的POST请求的shutdown进行服务下架时，其内部主要完成了四样工作：
 将状态变更监听器删除
 停止了一堆定时任务的执行，并关闭了定时器
 通过Jersey框架向Eureka Server提交了一个DELETE请求
 关闭了一些其它相关工作
【Q-08】对于Spring Cloud中的Eureka，用户通过平滑上下线方式进行Client状态的修改。这个状态修改请求是被客户端的哪个类处理的，这个类实例是在何时创建的？请谈一下你的认识。
【RA】对于Spring Cloud中的Eureka，用户通过平滑上下线方式进行Client状态的修改。这个状态修改请求是被客户端的ServiceRegistryEndpoint类实例的setStatus()方法处理的。这个类实例是在Spring Cloud应用启动时被加载创建的。具体来说，spring-cloud-starter依赖于spring-cloud-common，而该common依赖加载并实例化了ServiceRegistryAutoConfigration配置类。在该配置类中实例化了ServiceRegistryEndpoint类。
【Q-09】对于Spring Cloud中的Eureka，用户通过Actuator的service-registry监控终端提交状态修改请求，请谈一下你对这个请求处理过程的认识。
【RA】对于Spring Cloud中的Eureka，用户通过Actuator的service-registry监控终端提交状态修改请求，服务平滑上下线就属于这种情况，但这种情况不仅限于服务平滑上下线。
当Client提交的状态为UP或OUT_OF_SERVICE时，属于平滑上下线场景。该请求会被Client接收并直接再以PUT请求的方式提交给Server，在Client端并未修改Client的任何状态。Server在接收到这个请求后，会从注册表中找到该Client对应的InstanceInfo，修改其overriddenStatus、status为指定状态。
当Client提交的状态为CANCEL_OVERRIDE时，是要将Server端当前Client对应InstanceInfo的overriddenStatus从一个缓存map中删除，并将其overriddenStatus与status修改为UNKNOWN状态。这个缓存map中记录着注册到当前Server中的每一个instanceInfo对应的overriddenStatus，这个map中的状态值对于其它Client发现一个InstanceInfo的对外表现状态status非常重要。当服务端的某InstanceInfo的overriddenStatus变为UNKNOWN时，该Client发送的心跳Server是不接收的。Server会向该Client返回404。
【Q-10】对于Spring Cloud中的Eureka，用户通过Actuator的service-registry监控终端提交状态修改请求，如果用户提交的状态是一个非法状态会怎么样？请谈一下你的认识。
【RA】对于Spring Cloud中的Eureka，用户通过Actuator的service-registry监控终端提交状态修改请求，这个状态值一般为五个标准状态UP、DOWN、OUT_OF_SERVICE、STARTING、UNKNOWN中的UP或OUT_OF_SERVICE，也可以是CANCEL_OVERRIDE。但若用户提交的不
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
9
是这六种情况之一，系统会将其最终归结为UNKNOWN状态。
【Q-11】Spring Cloud中EurekaServerAutoConfiguration自动配置类被实例化的一个前提条件是，容器中要有一个Marker实例，这个Marker实例是在哪被添加到了容器？
【RA】Spring Cloud中关于Eureka Server的这个Marker实例，就是Eureka Server的一个标识，一个开关。该实例被添加到了容器，Eureka Server就开启了。其是在Eureke Server启动类上的@EnableEurekaServer注解中被实例化并添加到的容器。所以，若没有添加该注解，Eureka Server启动类的启动是不会创建启动Eureka Server的。
【Q-12】Spring Cloud中Eureka Client会注册到Eureka Server的注册表中，在Server中这个注册表是以怎样的形式存在的？当Eureka Client将Eureke Server中的注册信息下载到本地后，这个注册表又是以怎样的形式存在的？请谈一下你的认识。
【RA】Spring Cloud的Eureka Server中的这个注册表是一个双层Map，外层map的key为微服务名称，value为内层map。内层map的key为instanceId，value为Lease对象。Lease对象中包含一个执有者Holder属性，表示该Lease对象所属的InstanceInfo。
当Eureka Client将Server端的注册表下载到了本地，该注册表是以Applications形式出现的。Applications中维护着一上Map集合，key为微服务名称，value为Application实例。该Application实例中包含了所有提供该微服务名称的InstanceInfo信息。因为Application中也维护着一个Map，key为instanceId，value为InstanceInfo。
【Q-13】Eureka Client提交的状态修改请求，Eureka Server是如何处理的，Server端都做了哪些变更？请谈一下你的认识。
【RA】Eureka Client提交的状态修改请求，Eureka Server在接收到后，首先根据该Client的微服务名称及instanceId在Server端注册表中进行了查找。若没有找到，则直接返回404；若找到了，其会执行两大任务：
 任务一：将客户端修改请求中的新状态写入到注册表中。
 任务二：将写入到当前server注册表中新的状态同步到其它server。
而在第一项任务中完成的重要工作有如下几项：
 使用新状态替换缓存overriddenInstanceStatusMap中的老状态
 修改instanceInfo的overriddenStatus状态为新状态
 修改instanceInfo的status状态为新状态
 更新来自于请求参数的客户端修改时间戳lastDirtyTimestamp
 将本次修改形为记录到instanceInfo的行为类型中
 修改服务端修改时间戳lastUpdatedTimestamp
 将本次修改记录到最近更新队列recentlyChanngeQueue中
【Q-14】Eureka Server中的注册表发生了变更，其是怎样将变更同步到其它Server的？请谈一下你的看法。
【RA】Eureka Server中的注册表发生了变更，并不是一定要同步给其它Server的，需要分情况处理。
若这个变更是由Client端直接引发，则当前Server会遍历所有其它Server，通过Jersey框架向每一个其它Server发送变更请求。这样就实现了同步。
若这个变更是由其它Server端发送的变更，则其仅仅会在本地变更一下即可，不会再
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
10
向其它Server发送变更请求，以防止出现无限递归。
第4次直播课
【Q-01】Eureka Client提交的CANCEL_OVERRIDE状态修改请求，Eureka Server是如何处理的，Server端都做了哪些变更？请谈一下你的认识。
【RA】Eureka Client提交的CANCEL_OVERRIDE状态修改请求，Eureka Server在接收到后，首先根据该Client的微服务名称及instanceId在Server端注册表中进行了查找。若没有找到，则直接返回404；若找到了，其会执行两大任务：
 任务一：将Server端删除overridden状态。
 任务二：将此变更同步到其它server。
删除overridden状态，从哪里删除呢？这个删除处理，在Server端主要完成了三样工作：
 将该instanceInfo在缓存集合overriddenInstanceStatusMap中的Entry删除。
 将instanceInfo中的overridden状态变更为UNKNOWN。
 将instanceInfo中的status状态变更为UNKNOWN。
overriddenInstanceStatusMap中的缓存的instanceInfo的overridden状态，对于后续注册、续约等请求处理时instanceInfo的状态判断起很大作用。另外此时，该Client发送的心跳Server是不接收的。Server会向该Client返回404。
【Q-02】Eureka Client的注册请求被Server接收到后，会首先判断该Client在注册表中是否存在。按理说，这里是注册处理，注册表中应该是不存在该Client的lease信息的，但的确会出现新注册的Client在注册表中存在的情况，这是为什么？请谈一下你的看法。
【RA】Eureka Client的注册请求被Server接收到后，注册表中可能会出现新注册的Client在注册表中已经存在的情况。这是因为，当Client的instanceInfo的续约信息发生了变更，Client的“定时更新InstanceInfo信息给Server”的定时任务发出的是register()请求，但该客户端其实在之前已经注册过了。此时就会出现注册表中已经存在该instanceId的情况。
【Q-03】Eureka Server在处理新注册的Client在注册表中已经存在的情况时会出现一种比较奇怪的情况：当前新注册的InstanceInfo中的lastDirtyTimestamp，比注册表中缓存的当前这个InstanceInfo中的lastDirtyTimestamp小。即后注册的反而过时，这是为什么？请谈一下你的看法。
【RA】ureka Server在处理新注册的Client在注册表中已经存在的情况时会出现，当前新注册的InstanceInfo中的lastDirtyTimestamp，比注册表中缓存的当前这个InstanceInfo中的lastDirtyTimestamp小的情况，即后注册的反而过时。这是因为，若Client的instanceInfo的续约信息相继发生了两次变更，Client就提交了两次register()请求。但是由于网络原因，第二次注册请求先到达Server。当第一次注册请求到达后就会出现“后到达的注册请求中携带的instanceInfo的最后修改时间反而过时”的情况。
【Q-04】Eureka Server在处理Client的注册时请求时，是否可能出现新注册的registrant的OverriddenStatus状态不是UNKNOWN的场景呢？为什么？请谈一下你的看法。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
11
【RA】这种场景是可能会出现的。且只有一种情况：当前注册的registrant是由于其续约信息发生了变更而引发的注册，且在续约信息变更之前用户通过Actuator修改过状态。
当然，这种通过Actuator修改的状态仅仅修改的是Server端注册表中的状态，并没有修改客户端的任何状态。这个修改的结果实际是通过客户端定时更新客户端注册表时，将所有变更信息下载到的客户端，其中就包含它自己状态的修改信息。
【Q-05】Eureka Server会根据Client请求中携带的状态信息、该Client在Server的注册表的InstanceInfo中的状态信息，及缓存map中的OverriddenStatus状态信息根据指定规则计算出当前Client的status。请问，Eureka Server中使用的是哪种状态计算规则？请谈一下你对这个规则的认识。
【RA】Eureka Server中使用的状态计算规则为FirstMatchWinsCompositeRule。该规则是一个复合规则，具有一个包含了三条子规则的有序列表：DownOrStartingRule、OverrideExistsRule与LeaseExistsRule。其会依次逐个尝试着去匹配其所包含的子规则，并返回第一个匹配上的结果。若都没有匹配上，则返回AlwaysMatchInstanceStatusRule规则的结果。这个规则能够匹配上任意InstanceInfo的状态。
【Q-06】请谈一下你对Eureka Server中的DownOrStartingRule状态匹配规则的认识。
【RA】DownOrStartingRule是计算instanceInfo状态的一种规则，该规则的执行原则是：只要参数的instance的status是STARTING或DOWN状态，那么这个状态是可信的，即可以直接将这个状态值作为计算出的intance的真正服务状态结果返回。若是参数的instance的服务状态为UP或OUT_OF_SERVICE状态，那么，这个状态是不可靠的。因为该instance在服务端的状态可能已经被Actuator给改了。所以需要再查看该instance的状态是否在服务端也被修改了。所以这个状态是不可靠的，需要对其进行再次确认。所以返回“不匹配”的结果，以进行下一个规则的匹配。从代码可以看出，只有UP与OUT_OF_SERVICE状态是匹配不上这个规则的。也就是说，能进入下一个规则判断，一定是UP或OUT_OF_SERVICE状态。
【Q-07】请谈一下你对Eureka Server中的OverrideExistsRule状态匹配规则的认识。
【RA】OverrideExistsRule是计算instanceInfo状态的一种规则。在进行该规则之前是先进行了DownOrStartingRule规则匹配的，所以能走到这里，说明参数的intance的服务状态是UP或OUT_OF_SERVICE。该规则的执行原则是：查看服务端缓存overriddenInstanceStatusMap中是否有其对应的可覆盖状态overriddenStatus。若有，则直接将这个状态作为计算结果返回。若没有，则该规则未被匹配上。进入下一个规则进行匹配。
【Q-08】请谈一下你对Eureka Server中的LeaseExistsRule状态匹配规则的认识。
【RA】LeaseExistsRule是计算instanceInfo状态的一种规则。在进行该规则之前是先进行
了OverrideExistsRule规则匹配的，所以能走到这里，说明参数的intance的服务状态是UP或OUT_OF_SERVICE。该规则的执行原则是：查看服务端注册表中该instance对应的服务状态是否也是UP或OUT_OF_SERVICE。若是，则直接将这个状态作为计算出的intance的真正服务状态结果返回。若注册表中没有对应的instance，或注册表中对应instance的状态不是OUT_OF_SERVICE与UP，则返回“不匹配”结果，以进行下一个规则的匹配。
【Q-09】请谈一下你对Eureka Server中的AlwaysMatchInstanceStatusRule状态匹配规则的认识。
【RA】AlwaysMatchInstanceStatusRule是计算instanceInfo状态的一种规则。首先，从这个类
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
12
名可以看出，该规则可以匹配上任意状态，最终都会给出一个当前instance服务状态的计算结果的。只所以可以匹配任意状态，是因为其是直接返回参数给的的instance的status状态，无论是什么状态。
第5次直播课
【Q-01】Eureka Client提交的续约请求，Eureka Server是如何处理的？请谈一下你的认识。
【RA】客户端续约请求，即客户端向服务端发送心跳。客户端的心跳提交的是一个没有携带任何请求体的PUT请求，不过其在请求URI中携带了心跳的发出者的InstanceId，及当前心跳发出者的状态。Server端对于续约请求，主要完成了两若项任务：
 当Server接收到Client发送的续约信息后，根据注册表中当前InstanceInfo的状态信息计算出其状态，然后更新为新的status。
 将心跳同步到其它server。
 在Server间的同步过程可能会导致Server间overridden状态的不一致。所以又进行了该状态的统一。
【Q-02】Eureka Server间进行续约同步过程中可能会导致overridden状态的不一致，为什么？请谈一下你的看法。
【RA】首先要清楚一点，Eureka是AP的，是允许出现Server间数据不一致的。例如，当前Eureka中由于客户端下架请求而从注册表中删除了某Client，在进行Server间同步时，由于另一个Server处于自我保护模式，所以其是不能删除Client的。此时就出现了Server间数据的不一致。
下面再来说续约。无论是直接处理Client的续约请求，还是处理Server间续约同步，Server端对于续约的处理，根本不涉及lastDirtyTimestamp时间戳，及overridden状态。这一点从续约的源码中是可以看出来的。那么有可能会出现以下场景：Client通过Actuator修改了状态，而这个状态修改操作在Server间同步时并没有同步成功，出现了Server间对于同一个InstanceInfo中overridden状态的不一致。
虽然Eureka本身是AP的，但其仍是尽量想让Eureka间实现同步，所以在其发生最频繁的续约中解决了这个问题。只不过，由于续约本身根本不涉及overridden状态，仅靠续约是解决不了的。所以需要在Eureka Server的配置文件中添加专门的配置解决这个问题。不过，这个属性设置默认是开启的。
【Q-03】Eureka Server在进行续约处理时，若发现其计算的当前isntanceInfo的status状态为UNKNOWN，说明什么？请谈一下你的看法。
【RA】Eureka Server在进行续约处理时，若发现其计算的当前instanceInfo的status状态为UNKNOWN，说明这个计算结果是在OverrideExistsRule规则中计算出的结果，即当前instanceInfo的overridden状态为UNKNOWN。对于一个InstanceInfo来说，可以从缓存map中读取到其overridden状态为UNKNOWN，只能有一种情况：这个UNKNOWN的overridden状态是通过Actuator的CANCEL_OVERRIDE修改的状态，即用户取消了该InstanceInfo的overridden状态。
那么也就是说，Eureka Server在进行续约处理时，若发现其计算的当前instanceInfo的status状态为UNKNOWN，则说明该InstanceInfo已经不对外提供服务了。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
13
【Q-04】Eureka Client提交的下架请求，Eureka Server是如何处理的？请谈一下你的认识。
【RA】Eureka Server在接收到Client的下架请求后，主要完成了两项任务：
 从注册表中将该提交请求的intanceInfo删除，并将其overridden状态从缓存map中删除，记录的删除时间戳，最后修改时间戳lastUpdatedTimestamp等。
 将下架请求同步到其它server。
【Q-05】Eureka Server在处理Client的全量下载注册信息请求时可以设置从自己的只读缓存readOnlyCacheMap中获取到所有注册到自己的注册信息，而readOnlyCacheMap中的数据是定时同步的读写缓存readWriteCacheMap的。这样的话就存在一个问题：这个定时更新无论更新频率多么高，一定存在用户从readOnlyCacheMap中读取的数据与readWriteCacheMap中不一致的情况，为什么不直接从readWriteCacheMap中读取？也就是说，这样的设计好处是什么？请谈一下你的认识。
【RA】这样设计的目的是为了保证在并发环境下“集合迭代的稳定性”。集合迭代的稳定性指的是，当一个共享变量是集合且存在并发读写操作时，要保证在对共享集合进行读操作时能够读取到稳定的数据，即在读取时不能对其执行写操作，但又不能妨碍了写操作的执行。此时就可以将集合的读写功能进行分离，创建出两个共享集合：一个专门用于处理写功能，外来的数据写入到这个集合；一个专门用于处理读功能，定时同步写集合的数据。这种方案存在的弊端是，无法保证只读集合中的数据与读写集合中数据的随时完全一致。当然，这种不一致在下一次定时同步时就会达到一致。所以这种方案的应用场景是对数据的实时性要求不是很高的情况。
【Q-06】Eureka Server在处理Client的全量下载注册信息请求与处理增量下载请求有什么不同？请谈一下你的认识。
【RA】Eureka Server在处理Client的全量下载注册信息请求时，其读取的是当前Server注册表registry中的注册信息，而处理增量下载请求时根本就没有操作注册表registry，而是直接读取了最近更新队列recentlyChangeQueue中的信息。这两种请求的处理方式，操作了两上不同的共享集合。
【Q-07】Eureka Server在处理Client的增量下载注册信息请求时是从recentlyChangeQueue最近更新队列中直接获取的数据，这个recently是多久？如果超过了这个recently时间又是如何处理的？请谈一下你的认识。
【RA】最近更新队列recentlyChangeQueue中的recently是可能通过配置文件属性指定的，默认为3分钟。当recentlyChangeQueue中的元素超过了3分钟，那么系统会自动将这些过期的元素删除。只不过这个删除操作是一个repeated定时任务，在AbstractInstanceRegistry类的构造器中被创建并启动，默认每30秒执行一次。
【Q-08】Eurek Server对于像Client注册、状态修改等写操作添加的都是读锁，而对于像增量下载请求添加的是写锁，为什么？为什么对于续约请求这种写操作处理中没有添加读锁？为什么全量下载中没有添加写锁？对于Eureka Server中添加锁的方式，请谈一下你的认识。
【RA】总体来说，这种读/写锁的添加方式就是为了解决两个共享集合recentlyChangedQueue 与注册表registry 的“集合迭代稳定性”问题。即增加读锁是为了限制其增加写锁，而增加写锁也是为了限制其增加读/写锁。若仅是考虑到recentlyChangedQueue集合的迭代稳定性问题，完全可以在处理注册、状态修改、删除overridden状态、下架、续约等写操作请求时添加写锁，而在处理全量下载、增量下载请求时添加读锁。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
14
但这样做对于注册表registry集合来说就会出现问题。由于续约请求是一个发生频率非常高的写操作处理，若为其添加了写锁，则意味着在进行续约处理时，其它任何对registry的读/写操作均将阻塞。所以，续约处理是不能加写锁的。那为其添加读锁是否可以呢？也不行。因为对于这么一个发生频率很高的处理，若添加了读锁，那么，几乎这个registry就会被读锁给锁定，其它任何写操作均将被阻塞。所以，续约处理不能加锁。
处理注册、状态修改、删除overridden状态、下架等写操作请求时，为什么要添加读锁呢？添加写锁不行吗？若添加写锁，则意味着，任意一个对registry的写操作请求处理，均将阻塞所有其它对registry的读/写操作，效率非常低。而若这些写操作添加的是共享锁读锁，则意味着，这些写操作可以同时进行。即使可能会出现对这些写操作同时操作同一个registry中的相同instanceInfo的情况，也不会出现问题。因为registry及recentlyChangedQueue都是JUC的，是线程安全的。
由于那些写操作添加了读锁，所以增量下载这种读操作添加了写锁，以保证对共享集合读/写操作的互斥。
为什么增量下载添加了写锁，而全量下载没有添加呢？因为增量下载中没有涉及对共享集合注册表registry的操作，而全量下载读取了registry。若为全量下载添加写锁，则必然会导致其在读取期间出现续约请求处理被阻塞的情况。对于这种频率非常高的续约处理是不能停止的。
第6次直播课
【Q-01】Eurek Server对于续约过期的Client会定期进行清除，这个定时任务是何时启动的？由谁来完成的？又做了些什么？请谈一下你的认识。
【RA】Eurek Server对于续约过期的Client的定时清除任务是在Eureka Server启动时专门创建了一个新的线程来执行的。确切地说，是EurekaServerAutoConfiguration在做实例化过程中完成的该定时任务线程的创建、执行。
这个定时任务首先查看了自我保护模型是否已经开启，若已经开启则不进行清除。若没有开启，则首先会将所有失联的instance集中到一个集合中，然后再计算“为了不启动自我保护模型，最多只能清除多少个instance”，在进行清除时不能越过此最大值。
【Q-02】Eurek Server对于续约过期的Client会定期进行清除时有一个“补偿时间”概念。什么是补偿时间，请谈一下你的认识。
【RA】对于“补偿时间”的理解，首先要清楚repeated定时器的执行原理。本次任务的执行条件有两个，这两个条件必须同时满足才会执行任务。一是，上次任务执行完毕，二是，按照配置文件中设置的清除间隔，本次任务的执行时间点也已经到了或过了。
那么什么是“补偿时间”呢？举例来说。
例如，正常情况下，若每5s清除一次过期对象，而清除一次需要2s，则在第5s时开始清除0s-5s期间的过期对象。第10s开始清除5s-10s期间的过期对象。
若清除操作需要6s，则在第5s时会开始清除，其清除的是0s-5s期间的过期对象。然而这次清除用时6s，也就是说，在第11s时才清除完毕0s-5s期间的过期对象。按理说应该在第10s时开始清除5s-10s期间的过期对象，但由于上次的清除任务还未结束，所以在第10s时不能开始清除，而在第11s时开始清除操作。因为已经过了10s这个时间点。此时要清除的对象就应该是5s-11s期间过期的，而多出的那1s就是需要补偿的时间。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
15
【Q-03】Eurek Server对于续约过期的Client会定期进行清除，而这个清除过程中，系统会从过期对象数量expiredLeases.size，与开启自我保护的阈值数量evictionLimit两个数值中选择一个最小的数进行清除。根据这个最小值进行清除，是不是会导致自我保护模式永远无法启动的情况？若出现了很多的过期对象，即这个expiredLeases.size很大，而evictionLimit是固定的。那么其清除的一定是evictionLimit个过期对象。这样的话是否自我保护模型永远无法启动？
【RA】答案是否定的。自我保护模式的启动并不是由这个清除任务决定的，而是由其它线程决定。只要发现收到的续约数据低于阈值了，那么就会启动自我保护模式。这里选择最少的进行清除，是为了尽量少些清除，给那些没有被清除的对象以“改过自新，浪子回头”的机会。可能由于网络抖动导致的失联，网络现在好了，其还可以恢复。若直接清除掉，那么就没有这个恢复的机会了。
【Q-04】Spring Cloud中OpenFeign的@EnableFeignClients与@FeignClient两个注解有怎样的区别与联系。请谈一下你的认识。
【RA】@EnableFeignClients注解主要用于查找所有的@FeignClient接口，并为这些Feign Client设置一些默认的配置。而@FeignClient则是就某一个特定的Feign Client进行配置。一个Consumer中只能有一个@EnableFeignClients，但可以有多个@FeignClient。
【Q-05】Spring Cloud中OpenFeign中@FeignClient注解中有一个name属性与path属性。这两个属性是什么意思？请谈一下你的认识。
【RA】Spring Cloud中OpenFeign中@FeignClient注解中的name属性用于指定当前Feign Client的名称，这个名称为其要消费的提供者微服务名称。消费者对提供者的负载均衡就是通过这个名称实现的。而path属性用于指定直连方式的连接的提供者的ip与port。一旦指定了path属性，就不再使用负载均衡方式来选择提供者了。
【Q-06】Spring Cloud中OpenFeign中有一个FeignClientSpecification类，这个类是干嘛的？请谈一下你的认识。
【RA】FeignClientSpecification是一个Feign Client的生成规范。所谓生成规范就是该实例中定义了生成Feign Client的各种配置信息，在动态生成Feign Client时需要按照这些配置信息来生成。具体的规范存放在configuration属性中。
【Q-07】Spring Cloud中OpenFeign中有一个FeignContext类，这个类是干嘛的？请谈一下你的认识。
【RA】FeignContext是一个为Feign Client创建所准备的上下文对象，从这个对象中可以获取到每一个要创建的Feign Client所需要的Spring子容器，而在这些子容器中存放着创建每一个不同的Feign Client所需要的“原材料”bean。一个应用只会有一个FeignContext实例。
第7次直播课
【Q-01】Spring Cloud中OpenFeign中对于Feign Client的创建源码解析，从哪里下手开始呢？请谈一下你的思路。
【RA】对于Feign Client的创建源码解析从@EnableFeignClients着手分析是比较好的。该注解中@Import了一个FeignClientsRegistrar类。该类实现了ImportBeanDefinitionRegistrar接口，
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
16
即实现了该接口的registerBeanDefinitions()方法。这个接口就是专门处理配置类的。而@EnableFeignClients注解的的defaultConfiguration与@FeignClient注解中的configuration属性都是配置类，就是由这个接口方法处理的。所以就从FeignClientsRegistrar类的方法registerBeanDefinitions()入手分析。
【Q-02】关于volatile与synchronized，很多时候会一起使用，为什么？请谈一下你的认识。
【RA】首先要清楚，在系统中存在这样的两类内存。一类是为每个线程单独分配的工作内存，即高速缓存。一类是为当前应用（进程）分配的主内存。对于共享变量，其是同时存在于每个线程的工作内存与主内存中的。一个线程若要修改共享变量的值，其首先需要从主内存中将共享变量值读取到自己的工作内存，然后在自己的工作内存中进行修改。即对于共享变量的修改是在各个线程的工作内存中进行的。而对于共享变量的读取，则是从主内存中读取的。
为了使共享变量在线程的工作内存中修改后的值能够立即更新到进程主内存，就需要为共享变量添加volitile修饰符，即volitile可以保证共享变量值对所有线程的“可见性”。
但在并发环境下对于共享变量的修改“有序性”就需要使用synchronized了。将对共享变量的修改代码放入到synchronized语句块中，就可以保证了对共享变量修改的“有序性”。
将synchronized与volatile联合使用就可以保证了“我在修改时，你们都不能改。但我改过了，你们都可以看到”。当然，若对主内存中的共享变量的某个时刻的值，同时有多个线程读取到了各自的工作内存，其是通过“乐观锁”机制解决版本冲突问题的。
【Q-03】什么是迭代稳定性问题？请谈一下你的认识。
【RA】迭代稳定性问题其实就是共享集合迭代稳定性问题。其描述的问题是，在并发处理的场景下，对某实例中共享集合的访问中，若在对该集合进行写操作的同时，又有线程对其执行迭代访问，此时迭代访问的结果可能会出现稳定性问题。
为了解决这个问题，可以采用以下三种方案：
 读/写操作均添加读/写锁
 引入专门的只读集合
 集合替换
【Q-04】Spring Cloud中OpenFeign的@EnableFeignClients注解中value、basePackages与basePackageClasses属性均可以用于指定要扫描Feign Client的基本包。这三个属性值是什么关系？请谈一下你的认识。
【RA】Spring Cloud中OpenFeign的@EnableFeignClients注解中value、basePackages与basePackageClasses属性均可以用于指定要扫描Feign Client的基本包，只要这三个属性都指定了值，那么，这些指定的包均会扫描。
【Q-05】Spring Cloud中OpenFeign的@EnableFeignClients注解中value、basePackages、basePackageClasses属性与clients属性均可以用于指定要扫描Feign Client的位置。这五个属性值是什么关系？请谈一下你的认识。
【RA】Spring Cloud中OpenFeign的@EnableFeignClients注解中value、basePackages、basePackageClasses属性与clients属性均可以用于指定要扫描Feign Client的位置。其中value、basePackages、basePackageClasses属性用于指定要扫描的基本包，而clients属性用于指定与Feign Client同包的类或接口。若指定了clients属性，则用于指定基本包的属性将不起作用。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
17
【Q-06】Spring Cloud中OpenFeign的@FeignClient注解中value、contextId、name与serviceId属性均可以用于指定要生成的Feign Client的名称。这四个属性值是什么关系？请谈一下你的认识。
【RA】Spring Cloud中OpenFeign的@FeignClient注解中value、contextId、name与serviceId属性均可以用于指定要生成的Feign Client的名称。这四个属性值若都指定了不同的值，那么只会有一个起作用，它们的优先级由高到低分别是contextId、value、name、serviceId。
【Q-07】对于共享集合，为何有的需要考虑迭代稳定性而有的不需要？请谈一下你的看法。
【RA】对于共享集合，在并发环境下，若存在某些线程对其进行修改时，其它线程可能会对其进行遍历迭代访问的情况，那么就需要考虑迭代稳定性问题。若不存在遍历迭代的情况，就无需考虑。
【Q-08】Spring Cloud中OpenFeign的FeignContext对于Feign Client的创建非常的重要。其中维护着一个重要集合contexts，该集合中都保存了什么内容？请谈一下你的认识。
【RA】Spring Cloud中OpenFeign的FeignContext中维护着一个重要集合contexts，该集合是一个线程安全的map。其key为每个@FeignClient的name属性，即微服务名称，而value则为该@FeignClient所对应的一个Spring子容器对象，该容器中存放着该Feign Client创建所需要的所有对象。
【Q-09】Spring Cloud中OpenFeign的FeignContext对于Feign Client的创建非常的重要。其中维护着一个重要集合configurations，该集合中都保存了什么内容？请谈一下你的认识。
【RA】Spring Cloud中OpenFeign的FeignContext中维护着一个重要集合configurations，其是一个线程安全的map。其key-value分为两类：
 第一类只有一个，key是字符串“default + 当前启动类的全限定性类名”，而value为@EnableFeignClients中configuration的值；
 第二类可以有多个，key为当前@FeignClient的name属性名，即微服务名称，value则为每个@FeignClient的configuration的属性值。这一类key-value对会有很多，有多少的@FeignClient就会有多少的这类key-value。
【Q-10】在一个类或方法上出现的synthetic是什么意思？请谈一下你的认识。
【RA】synthetic，合成的。当一个类或方法前出现了该关键字，则说明该类或方法是由编译器自动生成的。这个关键字一般不是我们人为写到代码中的，而是由编译器编译生成的字节码文件中。
例如，当一个内部类中的方法要访问外部类的private成员时，编译器会为该内部类方法前自动添加上synthetic修饰符，表示该类中的方法可以访问到那个private成员。
编译器为什么要为其添加这个修饰符呢？因为对于编译器来说，无论是内部类还是外部类，其编译出的字节码文件都是一个独立的文件。为了标识出这个内部类文件的方法与其它类文件的方法的不同，编译器会为该类自动添加上这个修饰符，以使其可以访问到另一个类的private成员。
当然，若一个方法是由编译器内部生成的，那么这个编译器生成的这个方法前也会自动添加上synthetic关键字的。
【Q-11】Spring Cloud中OpenFeign中创建的Feign Client是一个什么对象？请谈一下你的看法。
开课吧 Reythor 雷课程知识点暨面试题总结
讲师：Reythor 雷
18
【RA】Spring Cloud中OpenFeign中创建的Feign Client是一个JDK的Proxy动态代理对象。确切地说，这个proxy并不是Feign Client的代理对象，而是Feign Client与当前被调用的Feign方法结合体的代理对象。即当前Feign Client有多个Feign方法被调用，就会创建出多个proxy代理对象。当然，若当前某一个Feign方法同时被多个线程调用，那么就会创建出多个proxy代理对象。
【Q-12】Spring Cloud中OpenFeign中Feign Client的一个方法调用是如何发出去的？如果查看这个源码？请谈一下你的思路。
【RA】Spring Cloud中OpenFeign中创建的Feign Client是一个JDK的Proxy动态代理对象，所以若要解析Feign方法的调用，可以找到JDK的Proxy生成时的InvocationHandler实例的invoke()方法，该方法是Feign方法执行后系统立即调用的方法。