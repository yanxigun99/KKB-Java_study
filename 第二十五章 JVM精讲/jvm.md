# 一、初始JVM

## 学习JVM的目的

面试重灾区，我们必须搞懂它。

生产过程中，肯定会面临JVM调优相关问题，需要也必须搞懂它。

打基础，想搞懂我们java赖以生存的环境长什么样子，提升对Java知识点的理解。

## JVM基本常识

#### 程序的执行方式

主要有三种：静态编译执行、动态编译执行和动态解释执行。

注意：此处所说的编译指的是编译成可让操作系统直接执行的机器码。

为什么使用JVM

#### 字节码和机器码的区别

机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到。

字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。

JDK、JRE与JVM的关系

##### OracleJDK和OpenJDK

查看JDK的版本

- 如果是SUN/OracleJDK， 显示信息为：

说明:

表明， 此JDK的JVM是Oracle的64位HotSpot虚拟

机， 运行在Server模式下(虚拟机有Server和Client两种运行模式).

是Java运行时环境(即JRE)的

版本信息.

- 如果OpenJDK， 显示信息为：

OpenJDK 的来历

Java由SUN公司(Sun Microsystems， 发起于美国斯坦福大学， SUN是Stanford University Network的缩写)发明， 2006年SUN公司将Java开源， 此时的JDK即为OpenJDK.

也就是说， OpenJDK是Java SE的开源实现， 它由SUN和Java社区提供支持， 2009年Oracle收购了Sun公司， 自此Java的维护方之一的SUN也变成了Oracle .

大多数JDK都是在OpenJDK的基础上编写实现的， 比如IBM J9， Azul Zulu， Azul Zing和Oracle JDK. 几乎现有的所有JDK都派生自OpenJDK， 它们之间不同的是许可证:

OpenJDK根据许可证GPL v2发布;

Oracle JDK根据Oracle二进制代码许可协议获得许可。

Oracle JDK的来历

Oracle JDK之前被称为SUN JDK， 这是在2009年Oracle收购SUN公司之前， 收购后被命名为Oracle JDK。

实际上， Oracle JDK是基于OpenJDK源代码构建的， 因此Oracle JDK和OpenJDK之间没有重大的技术差异。

Oracle的项目发布经理Joe Darcy在OSCON 2011 上对两者关系的介绍也证实了OpenJDK 7和Oracle JDK 7在程序上是非常接近的， 两者共用了大量相同的代码(如下图)

注意: 图中提示了两者共同代码的占比要远高于图形上看到的比例， 所以我们编译的OpenJDK基本上可以认为性能、功能和执行逻辑上都和官方的Oracle JDK是一致的.

Oracle JDK与OpenJDK的区别

OpenJDK使用的是开源免费的FreeType， 可以按照GPL v2许可证使用.GPL V2允许在商业上使用;

Oracle JDK则采用JRL(Java Research License，Java研究授权协议) 放出.JRL只允许个人研究使用，要获得Oracle JDK的商业许可证， 需要联系Oracle的销售人员进行购买。

## JVM和Hotspot的关系

JVM是《JVM虚拟机规范》中提出来的规范。 Hotspot是使用JVM规范的商用产品，除此之外还有Oracle JRockit、IBM的J9也是JVM产品

JRockit是Oracle的JVM， 从Java SE 7开始， HotSpot和JRockit合并为一个JVM。

JVM和Java的关系

JVM的运行模式 JVM有两种运行模式：Server模式与Client模式。两种模式的区别在于：

Client模式启动速度较快，Server模式启动较慢；

但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。

因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化；而Client模式 启动的JVM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。

JVM架构理解

# JVM程序执行流程

#### 执行流程图

Java编译成字节码、动态编译和解释为机器码的过程分析：

编译器和解释器的协调工作流程：

在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的， 当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层 次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文统称JIT编译

器）。

由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与 虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内 的即时编译器，虚拟机也是特指HotSpot虚拟机。

我们的JIT是属于动态编译方式的，动态编译（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation）。

JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。

#### 热点代码

程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是热点代码呢？ 运行过程中会被即时编译器编译的“热点代码”有两类：

1. 被多次调用的方法。
2. 被多次执行的循环体。

两种情况，编译器都是以整个方法作为编译对象。 这种编译方法因为编译发生在方法执行过程之中， 因此形象的称之为栈上替换（On Stack Replacement，OSR），即方法栈帧还在栈上，方法就被替换了。

#### 热点检测方式

要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。

目前主要的热点探测方式有以下两种： 基于采样的热点探测

采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这

个方法就是“热点方法”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别 的外界因素的影响而扰乱热点探测。

基于计数器的热点探测

采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执 行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。

在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计 数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的 阈值，当计数器超过阈值溢出了，就会触发JIT编译。

方法调用计数器

顾名思义，这个计数器用于统计方法被调用的次数。

在JVM client模式下的阀值是1500次，Server是10 000次。可以通过虚拟机参数： -XX： CompileThreshold设置。但是JVM还存在热度衰减，时间段内调用方法的次数较少，计数器就减 小。

回边计数器

它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称 为“回边”。

# JIT使用

为何HotSpot需要使用解释器和编译器并存的架构？ JVM为什么要实现两个不同的即时编译器？

程序何时会使用解释器执行？何时会使用编译器执行？ 哪些程序代码会被编译成为本地代码？如何编译？

JAVA代码的执行效率就一定比C，C++静态执行的执行差？JAVA代码解析执行有何优势？

#### 为什么要使用解释器与编译器并存的架构

尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机（如HotSpot），都同时包含解释器和编译器。

解释器与编译器特点

当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在 程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可 以获取更高的执行效率。

当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释器执行节约内存， 反之可以使用编译执行来提升效率。

编译的时间开销

解释器的执行，抽象的看是这样的：

输入的代码 -> [ 解释器 解释执行 ] -> 执行结果

而要JIT编译然后再执行的话，抽象的看则是：

输入的代码 -> [ 编译器 编译 ] -> 编译后的代码 -> [ 执行 ] -> 执行结果

说JIT比解释快，其实说的是“执行编译后的代码”比“解释器解释执行”要快，并不是说“编译”这 个动作比“解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个“执行编译后的代码”的过程。所以，对“只执行一次”的代码而言，解释执 行其实总是比JIT编译执行要快。

怎么算是“只执行一次的代码”呢？粗略说，下面两个条件同时满足时就是严格的“只执行一次” 1、只被调用一次，例如类的构造器（class initializer，()）

2、没有循环

对只执行一次的代码做JIT编译再执行，可以说是得不偿失。

对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。

只有对频繁执行的代码，JIT编译才能保证有正面的收益。

编译的空间开销

对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面 说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译 则会显著增加代码所占空间，导致“代码爆炸”。

这也就解释了为什么有些JVM会选择不总是做JIT编译，而是选择用解释器+JIT编译器的混合执行引 擎。

#### 为何要实现两个不同的即时编译器

HotSpot虚拟机中内置了两个即时编译器：Client Complier和Server Complier，简称为C1、C2编译器，分别用在客户端和服务端。

目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。程序使用哪个 编译器，取决于虚拟机运行的模式。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运 行模式，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在Client模式或 Server模式。

用Client Complier获取更高的编译速度，用Server Complier 来获取更好的编译质量。为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。

#### 如何编译为本地代码？

Server Compiler和Client Compiler两个编译器的编译过程是不一样的。

对Client Compiler来说，它是一个简单快速的编译器，主要关注点在于局部优化，而放弃许多耗时较长的全局优化手段。

而Server Compiler则是专门面向服务器端的，并为服务端的性能配置特别调整过的编译器，是一个充分优化过的高级编译器。

# JIT优化

HotSpot 虚拟机使用了很多种优化技术，这里只简单介绍其中的几种，完整的优化技术介绍可以参考官网内容。

#### 公共子表达式的消除

公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，他的含义是：如果一个表达式E已经 计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共 子表达式。对于这种表达式，没有必要花时间再对他进行计算，只需要直接用前面计算过的表达式结果 代替E就可以了。

如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除（Local Common Subexpression Elimination）

如果这种优化范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination） 。

举个简单的例子来说明他的优化过程，假设存在如下代码：

如果这段代码交给Javac编译器则不会进行任何优化，那生成的代码如下所示，是完全遵照Java源码的 写法直译而成的。

当这段代码进入到虚拟机即时编译器后，他将进行如下优化：编译器检测到”cb“与”bc“是一样的表达式，而且在计算期间b与c的值是不变的。因此，这条表达式就可能被视为：

这时，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化：代数化 简（Algebraic Simplification），把表达式变为：

表达式进行变换之后，再计算起来就可以节省一些时间了。

#### 方法内联

在使用JIT进行即时编译时，将方法调用直接使用方法体中的代码进行替换，这就是方法内联，减少了 方法调用过程中压栈与入栈的开销。同时为之后的一些优化手段提供条件。如果JVM监测到一些小方法 被频繁的执行，它会把方法的调用替换成方法体本身。

比如说下面这个：

可以肯定的是运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成：

逃逸分析

逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用 ，例如作为调用参数传递到其他地方中，称为方法逃逸。

逃逸分析包括：

全局变量赋值逃逸方法返回值逃逸实例引用发生逃逸

线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量

例如：

使用方法逃逸的案例进行分析：

StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称 其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程 中访问的实例变量，称为线程逃逸。

上述代码如果想要StringBuffer sb不逃出方法，可以这样写：

不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法。使用逃逸分析，编译器可以对代码做如下优化：

在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，

从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis

#### 对象的栈上内存分配

我们知道，在一般情况下，对象和数组元素的内存分配是在堆内存上进行的。但是随着JIT编译器的日 渐成熟，很多优化使这种分配策略并不绝对。JIT编译器就可以在编译期间根据逃逸分析的结果，来决 定是否可以将对象的内存分配从堆转化为栈。

我们来看以下代码：

其实代码内容很简单，就是使用for循环，在代码中创建100万个User对象。

我们在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并 不会逃逸到alloc外部。经过JIT的逃逸分析之后，就可以对其内存分配进行优化。

我们指定以下JVM参数并运行：

在程序打印出 少个User对象：

后，代码运行结束之前，我们使用jmap命令，来查看下当前堆内存中有多

1

~ jps

2

2809 StackAllocTest

3

2810 Jps

4

~ jmap -histo 2809

5

num #instances

\#bytes

class name

6

7

1: 524

87282184

[I

8

2: 1000000

16000000

StackAllocTest$User

9

3: 6806

2093136

[B

10

4: 8006

1320872

[C

11

5: 4188

100512

java.lang.String

12

6: 581

66304

java.lang.Class

从上面的jmap执行结果中我们可以看到，堆中共创建了100万个StackAllocTest$User 实例。

在关闭逃避分析的情况下（-XX:-DoEscapeAnalysis），虽然在alloc方法中创建的User对象并没有逃逸到方法外部，但是还是被分配在堆内存中。也就说，如果没有JIT编译器优化，没有逃逸 分析技术，正常情况下就应该是这样的。即所有对象都分配到堆内存中。

接下来，我们开启逃逸分析，再来执行下以上代码。

在程序打印出

多少个User对象：

后，代码运行结束之前，我们使用jmap 命令，来查看下当前堆内存中有

1

~ jps

2

709

3

2858 Launcher

4

2859 StackAllocTest

5

2860 Jps

6

~ jmap -histo 2859

7

num #instances

\#bytes

class name

8

9

1: 524

101944280

[I

10

2: 6806

2093136

[B

11

3: 83619

1337904

StackAllocTest$User

12

4: 8006

1320872

[C

13

5: 4188

100512

java.lang.String

14

6: 581

66304

java.lang.Class

从以上打印结果中可以发现，开启了逃逸分析之后（-XX:+DoEscapeAnalysis），在堆内存中只 有8万多个StackAllocTest$User 对象。也就是说在经过JIT优化之后，堆内存中分配的对象数量，从100万降到了8万。

除了以上通过jmap验证对象个数的方法以外，还可以尝试将堆内存调小，然后执行以上代码，根 据GC的次数来分析，也能发现，开启了逃逸分析之后，在运行期间，GC次数会明显减少。正是 因为很多堆上分配被优化成了栈上分配，所以GC次数有了明显的减少。

总结

所以，如果以后再有人问你：是不是所有的对象和数组都会在堆内存分配空间？

那么你可以告诉他：不一定，随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。就像我 们前面看到的一样，在开启逃逸分析之后，也并不是所有User对象都没有在堆上分配。

#### 标量替换

标量（Scalar）是指一个无法再分解成更小的数据的数据 。

在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对 象拆解成若干个其中包含的若干个成员变量来代替。

#### 同步锁消除

同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。 在JIT编译时期就可以将同步锁去掉，以减少加锁与解锁造成的资源开销。

getString()方法中的StringBuffer数以函数内部的局部变量，进作用于方法内部，不可能逃逸 出该方法，因此他就不可能被多个线程同时访问，也就没有资源的竞争，但是StringBuffer的append操作却需要执行同步操作，代码如下:

逃逸分析和锁消除分别可以使用参数-XX:+DoEscapeAnalysis 和-XX:+EliminateLocks (锁消除必须在-server模式下)开启。使用如下参数运行上面的程序：

-XX:+DoEscapeAnalysis -XX:-EliminateLocks 得到如下结果：

使用如下命令运行程序：

-XX:+DoEscapeAnalysis -XX:+EliminateLocks 得到如下结果：

# 二、带你认识一下class文件

## class文件概述

我们可任意打开一个Class文件（使用Hex Editor等工具打开），内容如下（内容是16进制）：

十六进制转字符串：http://www.bejson.com/convert/ox2str/

进制转换网址（十六进制转十进制）：http://tool.oschina.net/hexconvert/

参考下图去阅读上面的十六进制文档：

据上述的叙述，我们可以将class的文件组织结构概括成以下面这个表格（其中u表示u4表示4个无符号 字节，u2表示2个无符号字节）：

### 魔数

所有的由Java编译器编译而成的class文件的前4个字节都是“0xCAFEBABE”。

它的作用在于：当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为 可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。

### 版本号

随着Java本身的发展，Java语言特性和JVM虚拟机也会有相应的更新和增强。目前我们能够用到的JDK 版本如：1.5，1.6，1.7，还有现如今的1.8及更高的版本。发布新版本的目的在于：在原有的版本上增加新特性和相应的JVM虚拟机的优化。而随着主版本发布的次版本，则是修改相应主版本上出现的 bug。我们平时只需要关注主版本就可以了。

主版本号和次版本号在class文件中各占两个字节，副版本号占用第5、6两个字节，而主版本号则占用 第7，8两个字节。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在 使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51，对应的7，8个字节的十六进制的 值应该是 0x33。

一个 JVM实例只能支持特定范围内的主版本号 （Mi 至Mj） 和 0 至特定范围内 （0 至 m） 的副版本号。假设一个 Class 文件的格式版本号为 V， 仅当Mi.0 ≤ v ≤ Mj.m成立时，这个 Class 文件才可以被此 Java 虚拟机支持。不同版本的 Java 虚拟机实现支持的版本号也不同，高版本号的 Java 虚拟机实现可以支持低版本号的 Class 文件，反之则不成立。

JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版 本号，如果JVM本身的版本号 < class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的" java.lang.UnsupportedClassVersionError: Bad version number in .class

" Error 错误；反之，JVM会认为可以加载此class文件，继续加载此class文件。

小贴士：

1. 有时候我们在运行程序时会抛出这个Error 错

误 ："java.lang.UnsupportedClassVersionError: Bad version number in .class file"。上面已经揭示了出现这个问题的原因，就是在于当前尝试加载class文件的JVM虚拟 机的版本 低于class文件的版本。

解决方法：

a). 重新使用当前jvm编译源代码，然后再运行代码； b). 将当前JVM虚拟机更新到class文件的版本。

1. 怎样查看class文件的版本号？可以借助于文本编辑工具，直接查看该文件的7，8个字节的 值，确定class文件是什么版本的。

当然快捷的方式使用JDK自带的javap工具，如当前有Math.class 文件，进入此文件所在的目录，然后执行 ”javap -v Math“，结果会类似如下所示：

## 常量池计数器

常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。常量池是由一组constant_pool结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器constant_pool_count 的值 =constant_pool表中的成员数+ 1。constant_pool表的索引值只有在大于 0 且小于constant_pool_count时才会被认为是有效的。

注意事项：

常量池计数器默认从1开始而不是从0开始：

当constant_pool_count = 1时，常量池中的cp_info个数为0；当constant_pool_count为n时，常量池中的cp_info个数为n-1。

原因：

在指定class文件规范的时候，将索引#0项常量空出来是有特殊考虑的，这样当：某些数据在特定的情 况下想表达“不引用任何一个常量池项”的意思时，就可以将其引用的常量的索引值设置为#0来表示。

### 常量池数据区

访问标志

### 类索引

父类索引

### 接口计数器

接口信息数据区

### 字段计数器

字段信息数据区

### 方法计数器

方法信息数据区

### 属性计数器

属性信息数据区

## class常量池理解

### 常量池在class文件的什么位置？

### 1. 常量池的里面是怎么组织的？

cp_info：常量池项constant_pool_count：常量池计算器

### 常量池项 (cp_info) 的结构是什么？

JVM虚拟机规定了不同的tag值和不同类型的字面量对应关系如下：

所以根据cp_info中的tag 不同的值，可以将cp_info 更细化为以下结构体：

现在让我们看一下细化了的常量池的结构会是类似下图所示的样子：

1. int和float数据类型的常量在常量池中是怎样表示和存储的？

Java语言规范规定了 int类型和Float 类型的数据类型占用 4 个字节的空间。那么存在于class字节码文件中的该类型的常量是如何存储的呢？

举例：建下面的类 IntAndFloatTest.java，在这个类中，我们声明了五个变量，但是取值就两种int 类型的10 和Float类型的11f。

然后用编译器编译成IntAndFloatTest.class字节码文件，我们通过javap -v IntAndFloatTest 指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了两次10 和三次11f，但是常量池中，就只有一个常量10 和一个常量11f，如下图所示:

从结果上可以看到常量池第#8 个常量池项(cp_info) 就是CONSTANT_Integer_info，值为10；第#23个常量池项(cp_info) 就是CONSTANT_Float_info，值为11f。(常量池中其他的东西先别纠结啦，我们后面会一一讲解的哦)。

代码中所有用到 int 类型 10 的地方，会使用指向常量池的指针值#8 定位到第#8 个常量池项(cp_info)，即值为 10的结构体CONSTANT_Integer_info，而用到float类型的11f时，也会指向常量池的指针值#23来定位到第#23个常量池项(cp_info) 即值为11f的结构体CONSTANT_Float_info。如下图所示：

1. long和 double数据类型的常量在常量池中是怎样表示和存储的？

Java语言规范规定了 long 类型和 double类型的数据类型占用8 个字节的空间。那么存在于class 字节码文件中的该类型的常量是如何存储的呢？

举例：建下面的类 LongAndDoubleTest.java，在这个类中，我们声明了六个变量，但是取值就两种

Long 类型的-6076574518398440533L 和Double 类型的10.1234567890D。

然后用编译器编译成 LongAndDoubleTest.class 字节码文件，我们通过javap -v LongAndDoubleTest指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了三 次-6076574518398440533L 和三次10.1234567890D，但是常量池中，就只有一个常量-6076574518398440533L 和一个常量10.1234567890D，如下图所示:

从结果上可以看到常量池第 #18 个常量池项(cp_info) 就是CONSTANT_Long_info，值

为-6076574518398440533L ；第 #26个常量池项(cp_info) 就是CONSTANT_Double_info，值为

10.1234567890D。(常量池中其他的东西先别纠结啦，我们会面会一一讲解的哦)。

代码中所有用到 long 类型-6076574518398440533L 的地方，会使用指向常量池的指针值#18 定位到第 #18 个常量池项(cp_info)，即值为-6076574518398440533L 的结构体CONSTANT_Long_info，而用到double类型的10.1234567890D时，也会指向常量池的指针值#26来定位到第 #26 个常量池项(cp_info) 即值为10.1234567890D的结构体CONSTANT_Double_info。如下图所示：

1. String类型的字符串常量在常量池中是怎样表示和存储的？

对于字符串而言，JVM会将字符串类型的字面量以UTF-8 编码格式存储到在class字节码文件中。这么说可能有点摸不着北，我们先从直观的Java源码中中出现的用双引号"" 括起来的字符串来看，在编译器编译的时候，都会将这些字符串转换成CONSTANT_String_info结构体，然后放置于常量池中。其结 构如下所示：

如上图所示的结构体，CONSTANT_String_info结构体中的string_index的值指向了CONSTANT_Utf8_info结构体，而字符串的utf-8编码数据就在这个结构体之中。如下图所示：

请看一例，定义一个简单的StringTest.java类，然后在这个类里加一个"JVM原理" 字符串，然后， 我们来看看它在class文件中是怎样组织的。

将Java源码编译成StringTest.class文件后，在此文件的目录下执行 javap -v StringTest 命令， 会看到如下的常量池信息的轮廓：

(PS :使用javap -v 指令能看到易于我们阅读的信息，查看真正的字节码文件可以使用HEXWin、NOTEPAD++、UtraEdit 等工具。)

在面的图中，我们可以看到CONSTANT_String_info结构体位于常量池的第#15个索引位置。而存

放"Java虚拟机原理" 字符串的 UTF-8编码格式的字节数组被放到CONSTANT_Utf8_info结构体中，该结构体位于常量池的第#16个索引位置。上面的图只是看了个轮廓，让我们再深入地看一下它们的组织 吧。请看下图：

由上图可见：“JVM原理”的UTF-8编码的数组是：4A564D E5 8E 9FE7 90 86，并且存入了

CONSTANT_Utf8_info结构体中。

### 5. 类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？

JVM会将某个Java 类中所有使用到了的类的完全限定名 以二进制形式的完全限定名 封装成

CONSTANT_Class_info结构体中，然后将其放置到常量池里。CONSTANT_Class_info 的tag值为 7

。其结构如下：

Tips：类的完全限定名和二进制形式的完全限定名

在某个Java源码中，我们会使用很多个类，比如我们定义了一个 ClassTest的类，并把它放到com.kkb.jvm 包下，则 ClassTest类的完全限定名为com.kkb.jvm.ClassTest，将JVM编译器将类编译成class文件后，此完全限定名在class文件中，是以二进制形式的完全限定名存储的，即它会把完全限定符的"."换成"/" ，即在class文件中存储的 ClassTest类的完全限定名称是"com/kkb/jvm/ClassTest"。因为这种形式的完全限定名是放在了class二进制形式的字 节码文件中，所以就称之为 二进制形式的完全限定名。

举例，我们定义一个很简单的ClassTest类，来看一下常量池是怎么对类的完全限定名进行存储的。

将Java源码编译成ClassTest.class文件后，在此文件的目录下执行 javap -v ClassTest 命令， 会看到如下的常量池信息的轮廓：

如上图所示，在ClassTest.class文件的常量池中，共有 3 个CONSTANT_Class_info结构体，分别表示ClassTest 中用到的Class信息。 我们就看其中一个表示com/jvm.ClassTest的CONSTANT_Class_info 结构体。它在常量池中的位置是#1，它的name_index值为#2，它指向了常量池的第2 个常量池项，如下所示:

注意：

除此之外，如果在类中使用到了其他的类，只有真正使用到了相应的类，JDK编译器才会将类的信息组 成CONSTANT_Class_info常量池项放置到常量池中。如下图：

上述的Other的类，在JDK将其编译成class文件时，常量池中并没有java.util.Date对应的CONSTANT_Class_info常量池项，为什么呢?

在Other类中虽然定义了Date类型的两个变量date、da，但是JDK编译的时候，认为你只是声明

了“Ljava/util/Date”类型的变量，并没有实际使用到Ljava/util/Date类。将类信息放置到常量 池中的目的，是为了在后续的代码中有可能会反复用到它。很显然，JDK在编译Other类的时候，会解 析到Date类有没有用到，发现该类在代码中就没有用到过，所以就认为没有必要将它的信息放置到常量 池中了。

将上述的Other类改写一下，仅使用new Date()，如下图所示：

这时候使用javap -v Other ，可以查看到常量池中有表示java/util/Date的常量池项：

总结：

1. 对于某个类或接口而言，其自身、父类和继承或实现的接口的信息会被直接组装成CONSTANT_Class_info常量池项放置到常量池中；
   1. 类中或接口中使用到了其他的类，只有在类中实际使用到了该类时，该类的信息才会在常量池中有 对应的CONSTANT_Class_info常量池项；
2. 类中或接口中仅仅定义某种类型的变量，JDK只会将变量的类型描述信息以UTF-8字符串组成CONSTANT_Utf8_info常量池项放置到常量池中，上面在类中的private Date date;JDK编译器只会将表示date的数据类型的“Ljava/util/Date”字符串放置到常量池中。

### 6. 哪些字面量会进入常量池中？

结论：

测试代码：

使用javap命令打印的结果如下：

## class文件中的引用和特殊字符串

### 符号引用

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定 位到目标即可。

例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。

符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。

在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。

比如org.simple.People类 引用了org.simple.Language类 ，在编译时People类并不知道Language 类的实际内存地址，因此只能使用符号org.simple.Language （假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。

各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字 面量形式明确定义在Java虚拟机规范的Class文件格式中。

### 直接引用

直接引用可以是：

1. 直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
2. 相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
3. 一个能间接定位到目标的句柄

直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引 用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

### 引用替换的时机

符号引用替换为直接引用的操作发生在类加载过程(加载 -> 连接(验证、准备、解析) -> 初始化)中的解析阶段，会将符号引用转换(替换)为对应的直接引用，放入运行时常量池中。

后面我们会通过一些问题，来更深入的了解class常量池相关的知识点！！！

### 特殊字符串字面量

特殊字符串包括三种： 类的全限定名， 字段和方法的描述符， 特殊方法的方法名。 下面我们就分别介绍这三种特殊字符串。

类的全限定名

Object类，在源文件中的全限定名是java.lang.Object 。

而class文件中的全限定名是将点号替换成“/” 。 也就是java/lang/Object 。源文件中一个类的名字， 在class文件中是用全限定名表述的。

描述符

各类型的描述符

对于字段的数据类型，其描述符主要有以下几种

基本数据类型（byte、char、double、float、int、long、short、boolean）：除 long 和boolean，其他基本数据类型的描述符用对应单词的大写首字母表示。long 用 J 表示， boolean 用 Z 表 示 。

void：描述符是 V。

对象类型：描述符用字符L 加上对象的全限定名表示，如 类型的描述符为

数组类型：每增加一个维度则在对应的字段描述符前增加一个，如一维数组的描述符为 [I ，二维数组 的描述符为 。

对象类型

“L” + 类型的全限定名 + “;”。如 Ljava/lang/String; 表示 String 类型

数组类型

若干个“[” + 数组中元素类型的对应字符串，如一维数组 int[] 的描述符为

[I ，二维数组 String[][] 的描述符为 [[java/lang/String;

字段描述符

字段的描述符就是字段的类型所对应的字符或字符串。如：

方法描述符

方法的描述符比较复杂， 包括所有参数的类型列表和方法返回值。 它的格式是这样的：

注意事项：

不管是参数的类型还是返回值类型， 都是使用对应字符和对应字符串来表示的， 并且参数列表使用小括号括起来， 并且各个参数类型之间没有空格， 参数列表和返回值类型之间也没有空格。

方法描述符举例说明如下：

方法描述符

方法声明

特殊方法的方法名

首先要明确一下， 这里的特殊方法是指的类的构造方法和类型初始化方法。

构造方法就不用多说了， 至于类型的初始化方法， 对应到源码中就是静态初始化块。 也就是说， 静态初始化块， 在class文件中是以一个方法表述的， 这个方法同样有方法描述符和方法名，具体如下：

类的构造方法的方法名使用字符串 表示

静态初始化方法的方法名使用字符串 表示。

除了这两种特殊的方法外， 其他普通方法的方法名， 和源文件中的方法名相同。

### 总结

1. 方法和字段的描述符中， 不包括字段名和方法名， 字段描述符中只包括字段类型， 方法描述符中只包括参数列表和返回值类型。
2. 无论method()是静态方法还是实例方法，它的方法描述符都是相同的。尽管实例方法除了传递 自身定义的参数，还需要额外传递参数this，但是这一点不是由方法描述符来表达的。参数this 的传递，是由Java虚拟机实现在调用实例方法所使用的指令中实现的隐式传递。

# 通过javap命令分析java指令

javap命令简述

javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区

（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。

当然这些信息中，有些信息（如本地变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等 等）需要在使用javac编译成class文件时，指定参数才能输出，比如，你直接javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息了。如果你使用的eclipse，则默认情况下，eclipse在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。

通过反编译生成的汇编代码，我们可以深入的了解java代码的工作机制。比如我们可以查看i++；这行 代码实际运行时是先获取变量i的值，然后将这个值加1，最后再将加1后的值赋值给变量i。

通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信 息。

javap的用法格式：

其中classes就是你要反编译的class文件。

在命令行中直接输入javap或javap -help可以看到javap的options有如下选项：

一般常用的是-v -l -c三个选项。

javap -v classxx，不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息。

javap -l 会输出行号和本地变量表信息。

javap -c 会对当前class字节码进行反编译生成汇编代码。

查看汇编代码时，需要知道里面的jvm指令，可以参考官方文档： https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html

另外通过jclasslib工具也可以看到上面这些信息，而且是可视化的，效果更好一些。

javap测试及内容详解

前面已经介绍过javap输出的内容有哪些，东西比较多，这里主要介绍其中code区(汇编指令)、局部变 量表和代码行偏移映射三个部分。

如果需要分析更多的信息，可以使用javap -v进行查看。

另外，为了更方便理解，所有汇编指令不单拎出来讲解，而是在反汇编代码中以注释的方式讲解。

下面写段代码测试一下：

例子1：分析一下下面的代码反汇编之后结果：

上面代码通过JAVAC -g 生成class文件，然后通过javap命令对字节码进行反汇编：

得到下面内容(指令等部分是我参照着官方文档总结的)：

## 总结

1、通过javap命令可以查看一个java类反汇编、常量池、变量表、指令代码行号表等等信息。

2、平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行 的，可以参考官方文档查看每个指令的含义，很简单：

https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.areturn

3、通过对前面两个例子代码反汇编中各个指令操作的分析，可以发现，一个方法的执行通常会涉及下 面几块内存的操作：

（1） java栈：局部变量表、操作数栈。这些操作基本上都值操作。

（2） java堆：通过对象的地址引用去操作。

（3） 常量池。

- 其他如帧数据区、方法区（8之前，常量池也在方法区）等部分，测试中没有显示出来，这 里说明一下。

在做值相关操作时：

一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可 能是指，可能是对象的引用）被压入操作数栈。

一个指令，也可以从操作数数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系 统调用等等操作。

## 案例分析

class文件解读

javap显示结果解读

# 三、看清楚类加载子系统

类加载的过程

#### 加载

“加载”是“类加载”(Class Loading)过程的第一步。这个加载过程主要就是靠类加载器实现的， 包括用户自定义类加载器。

加载的过程

在加载的过程中，JVM主要做3件事情

通过一个类的全限定名来获取定义此类的二进制字节流(class文件)

在程序运行过程中，当要访问一个类时，若发现这个类尚未被加载，并满足类初始化的条件时，就 根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程

将这个字节流的静态存储结构转化为方法区的运行时数据结构

在内存中创建一个该类的java.lang.Class对象，作为方法区该类的各种数据的访问入口

加载源

JVM规范对于加载过程给予了较大的宽松度.一般二进制字节流都从已经编译好的本地class文件中读 取，此外还可以从以下地方读取。

zip 包 Jar、War、Ear等其它文件生成

由JSP文件中生成对应的Class类.

数据库中

将二进制字节流存储至数据库中，然后在加载时从数据库中读取.有些中间件会这么做，用来实现 代码在集群间分发

网络

从网络中获取二进制字节流.典型就是Applet.

运行时计算生成

动态代理技术，用ProxyGenerator.generateProxyClass为特定接口生成形式为"*$Proxy"的代 理类的二进制字节流.

类和数组加载的区别

数组也有类型，称为“数组类型”.如:

这个数组的数组类型是[Ljava.lang.String ，而String只是这个数组的元素类型。数组类和非数组类的类加载是不同的，具体情况如下：

非数组类：是由类加载器来完成。

数组类：数组类本身不通过类加载器创建，它是由java虚拟机直接创建，但数组类与类加载器有 很密切的关系，因为数组类的元素类型最终要靠类加载器创建。

加载过程的注意点

JVM规范并未给出类在方法区中存放的数据结构

类完成加载后，二进制字节流就以特定的数据结构存储在方法区中，但存储的数据结构是由虚拟机 自己定义的，虚拟机规范并没有指定。

JVM规范并没有指定Class对象存放的位置

在二进制字节流以特定格式存储在方法区后，JVM会创建一个java.lang.Class类的对象，作为本类的外部访问接口。

既然是对象就应该存放在Java堆中，不过JVM规范并没有给出限制，不同的虚拟机根据自己的需求存放这个对象。

HotSpot将Class对象存放在方法区。

加载阶段和链接阶段是交叉的

类加载的过程中每个步骤的开始顺序都有严格限制，但每个步骤的结束顺序没有限制。也就是说，

类加载过程中，必须按照如下顺序开始:

但结束顺序无所谓，因此由于每个步骤处理时间的长短不一就会导致有些步骤会出现交叉。

#### 验证

验证阶段比较耗时，它非常重要但不一定必要(因为对程序运行期没有影响)，如果所运行的代码已经被 反复使用和验证过，那么可以使用-Xverify:none 参数关闭，以缩短类加载时间。

验证的目的

保证二进制字节流中的信息符合虚拟机规范，并没有安全问题。

验证的必要性

虽然Java语言是一门安全的语言，它能确保程序猿无法访问数组边界以外的内存、避免让一个对象转换 成任意类型、避免跳转到不存在的代码行.也就是说，Java语言的安全性是通过编译器来保证的.

但是我们知道，编译器和虚拟机是两个独立的东西，虚拟机只认二进制字节流，它不会管所获得的二进制 字节流是哪来的，当然，如果是编译器给它的，那么就相对安全，但如果是从其它途径获得的，那么无 法确保该二进制字节流是安全的。

通过上文可知，虚拟机规范中没有限制二进制字节流的来源，在字节码层面上，上述Java代码无法做到 的都是可以实现的，至少语义上是可以表达出来的，为了防止字节流中有安全问题，需要验证！

验证的过程

文件格式验证

验证字节流是否符合Class文件格式的规范，并且能被当前的虚拟机处理.

本验证阶段是基于二进制字节流进行的，只有通过本阶段验证，才被允许存到方法区 后面的三个验证阶段都是基于方法区的存储结构进行，不会再直接操作字节流。

印证【加载和验证】是交叉进行的：

元数据验证

对字节码描述信息进行语义分析，确保符合Java语法规范.

字节码验证

本阶段是验证过程的最复杂的一个阶段。

本阶段对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。

字节码验证将对类的方法进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机的事，一 个类方法体的字节码没有通过字节码验证，那一定有问题，但若一个方法通过了验证，也不能说明 它一定安全。

符号引用验证

发生在JVM将符号引用转化为直接引用的时候，这个转化动作发生在解析阶段，对类自身以外的信息进行匹配校验，确保解析能正常执行。

#### 准备

仅仅为类变量（即static修饰的字段变量）分配内存并且设置该类变量的初始值即零值，这里不包含用final修饰的static，因为final在编译的时候就会分配了（编译器的优化），同时这里也不会为实例变量 分配初始化。类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

准备阶段主要完成两件事情：

为已在方法区中的类的静态成员变量分配内存

为静态成员变量设置初始值，初始值为0、false、null等

比如：

注意：

但是如果声明为：

#### 解析

解析是虚拟机将常量池的符号引用替换为直接引用的过程。

解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的

CONSTANT_Class_info

、

CONSTANT_Fieldref_info

、

CONSTANT_Methodref_info

、

`CONSTANT\_InterfaceMethodref\_info`四种常量类型。

1. 类或接口的解析：

判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。

1. 字段解析：

对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段， 如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它 们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束(优先从接口来， 然后是继承的父类.理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现 可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同 时在自己或父类的接口中出现，编译器可能会拒绝编译）.

1. 类方法解析：

对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步 骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。

1. 接口方法解析：

与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。

#### 初始化

初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码(初始化成为 代码设定的默认值)。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是 根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始 化阶段是执行类构造器()方法的过程。

其实初始化过程就是调用类初始化方法的过程，完成对static修饰的类变量的手动赋值还有主动调用静态代码块。

初始化过程的注意点

方法是编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收 集的顺序是由语句在源文件中出现的顺序所决定的.

静态代码块只能访问到出现在静态代码块之前的变量，定义在它之后的变量，在前面的静态语句块 可以赋值，但是不能访问.

实例构造器需要显式调用父类构造函数，而类的不需要调用父类的类构造函数，虚拟机会确

保子类的方法执行前已经执行完毕父类的方法.因此在JVM中第一个被执行的方法的类肯定是java.lang.Object.

如果一个类/接口中没有静态代码块，也没有静态成员变量的赋值操作，那么编译器就不会为此类 生成方法.

接口也需要通过方法为接口中定义的静态成员变量显示初始化。

接口中不能使用静态代码块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成方法. 不同的是，执行接口的方法不需要先执行父接口的方法.只有当父接口中的静态成员变量被使用到 时才会执行父接口的方法.

虚拟机会保证在多线程环境中一个类的方法别正确地加锁，同步.当多条线程同时去初始化一个类 时，只会有一个线程去执行该类的方法，其它线程都被阻塞等待，直到活动线程执行方法完毕.其 他线程虽会被阻塞，只要有一个方法执行完，其它线程唤醒后不会再进入方法.同一个类加载器下，一个类型只会初始化一次.

使用静态内部类的单例实现：

### 类加载的时机

什么时候开始加载，虚拟机规范并没有强制性的约束，对于其它大部分阶段究竟何时开始虚拟机规范也 都没有进行规范，这些都是交由虚拟机的具体实现来把握。所以不同的虚拟机它们开始的时机可能是不 同的。但是对于初始化却严格的规定了有且只有四种情况必须先对类进行“初始化”(加载，验证，准 备自然需要在初始化之前完成)：

1. 遇到new 、 getstatic 、 putstatic 和invokestatic 这四条指令时，如果对应的类没有初始化，则要对对应的类先进行初始化。

这四个指令对应到我们java代码中的场景分别是： new关键字实例化对象的时候；

读取或设置一个类的静态字段（读取被final修饰，已在编译器把结果放入常量池的静态字段除外） ；

调用类的静态方法时。

1. 使用lang.reflect 包方法时对类进行反射调用的时候。
2. 初始化一个类的时候发现其父类还没初始化，要先初始化其父类。
3. 当虚拟机开始启动时，用户需要指定一个主类，虚拟机会先执行这个主类的初始化。

### 

# 类加载器

启动类加载器(Bootstrap ClassLoader)： 负责加载 JAVA_HOME\lib 目录中的，

或通过-Xbootclasspath参数指定路径中的，

且被虚拟机认可（按文件名识别，如rt.jar）的类。由C++实现，不是ClassLoader子类

扩展类加载器(Extension ClassLoader)：

负责加载 JAVA_HOME\lib\ext 目录中的，

或通过java.ext.dirs系统变量指定路径中的类库。

应用程序类加载器(Application ClassLoader)：

负责加载用户路径（classpath）上的类库。

JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：

加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

#### 自定义类加载器

自定义类加载器步骤

（1）继承ClassLoader

（2）重写findClass（）方法

（3）调用defineClass（）方法

实践

下面写一个自定义类加载器：指定类加载路径在D盘下的lib文件夹下。

（1） 在本地磁盘新建一个Test.java 类，代码如下：

（2） 使用javac -d . Test.java 命令，将生成的Test.class 文件放到D:/lib/jvm/classloader

文件夹下。

（3）在Eclipse中自定义类加载器，代码如下：

1 package jvm.classloader; 2

3 import java.io.ByteArrayOutputStream;

4 import java.io.File;

5 import java.io.FileInputStream;

6 import java.io.FileNotFoundException;

7 import java.io.IOException;

8 import java.io.InputStream; 9

10 public class MyClassLoader extends ClassLoader{ 11

12 private String classpath; 13

14 public MyClassLoader(String classpath) { 15

16 this.classpath = classpath; 17 }

18

- @Override
- protected Class<?> findClass(String name) throws ClassNotFoundException

{

- try {
  - byte [] classDate=getData(name);
  - if(classDate==null){}
  - else{
    - //defineClass方法将字节码转化为类
  - return defineClass(name，classDate，0，classDate.length); 27 }
  - } catch (IOException e) {
    - e.printStackTrace(); 30 }

31

32 return super.findClass(name); 33 }

- //返回类的字节码
- private byte[] getData(String className) throws IOException{
  - InputStream in = null;
  - ByteArrayOutputStream out = null;
  - String path=classpath + File.separatorChar +
    - className.replace('.'，File.separatorChar)+".class";
  - try {
    - in=new FileInputStream(path);
    - out=new ByteArrayOutputStream();
    - byte[] buffer=new byte[2048];
    - int len=0;
    - while((len=in.read(buffer))!=-1){
    - out.write(buffer，0，len); 47 }

48 return out.toByteArray(); 49 }

- catch (FileNotFoundException e) {
  - e.printStackTrace(); 52 }
- finally{
  - in.close();

测试代码如下(在Eclipse中)：

输出结果如下：

自定义类加载器的作用：

# 双亲委派模型

JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的 类加载器。

当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶 层的启动类加载器，

只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。

采用双亲委派的一个好处是：

比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。

#### 为什么要使用双亲委托这种模型呢？

因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。

考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来 动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免 这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。

但是JVM在搜索类的时候，又是如何判定两个class是相同的呢？

JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器 实例加载的。

只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。

#### 既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？

因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时。

比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的 业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader

### 破坏双亲委派模型

#### 为什么需要破坏双亲委派？

因为在某些情况下父类加载器需要加载的class文件由于受到加载范围的限制，父类加载器无法加载到 需要的文件，这个时候就需要委托子类加载器进行加载。

而按照双亲委派模式的话，是子类委托父类加载器去加载class文件。这个时候需要破坏双亲委派模式 才能加载成功父类加载器需要的类。也就是说父类会委托子类去加载它需要的class文件。

以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector ，这些实现类都是以jar包的形式放到classpath目录下。

那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类

（classpath下），然后进行管理，但是DriverManager由启动类加载器加载，只能加载JAVA_HOME的 lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托 子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。

JDBC代码：

待添加（JVM热加载技术）

# 四、认识运行时数据区

## 运行时数据区概述

## JVM运行时数据区规范

画图说明一下它们的使用顺序。

jdk1.7之前，HotSpot虚拟机对于方法区的实现称之为“永久代”， Permanent Generation 。

jdk1.8之后，HotSpot虚拟机对于方法区的实现称之为“元空间”， Meta Space 。

方法区是Java虚拟机规范中的定义，是一种规范，而永久代和元空间是 HotSpot 虚拟机不同版本的两种实现。

Hotspot运行时数据区

##### jdk1.6 jdk1.7 jdk1.8+

## 分配JVM内存空间

分配堆的大小

分配方法区的大小

除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：

分配线程空间的大小

## 方法区

### 方法区存储内容

存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等等。 存储示意图如下，下面的图片显示的是JVM加载类的时候，方法区存储的信息：

1、类型信息

类型的全限定名超类的全限定名

直接超接口的全限定名

类型标志（该类是类类型还是接口类型）

类的访问描述符（public、private、default、abstract、final、static）

2、类型的常量池

存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的常量）和对其他类 型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为 常量池中保存着所有类型使用到的类型、字段、方法的字符引用，所以它也是动态连接的主要对象（在 动态链接中起到核心作用）。

3、字段信息（该类声明的所有字段）

字段修饰符（public、protect、private、default） 字段的类型

字段名称

4、方法信息

方法信息中包含类的所有方法，每个方法包含以下信息： 方法修饰符

方法返回类型方法名

方法参数个数、类型、顺序等方法字节码

操作数栈和该方法在栈帧中的局部变量区大小异常表

5、类变量（静态变量）

指该类所有对象共享的变量，即使没有任何实例对象时，也可以访问的类变量。它们与类进行绑定。

6、指向类加载器的引用

每一个被JVM加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到。

7、指向Class实例的引用

类加载的过程中，虚拟机会创建该类型的Class实例，方法区中必须保存对该对象的引用。通过Class.forName(String className)来查找获得该实例的引用，然后创建该类的对象。

8、方法表

为了提高访问效率，JVM可能会对每个装载的非抽象类，都创建一个数组，数组的每个元素是实例可能调用的方法的直接引用，包括父类中继承过来的方法。这个表在抽象类或者接口中是没有的。

9、运行时常量池(Runtime Constant Pool)

Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编 译器生成的各种字面常量和符号引用，这部分内容被类加载后进入方法区的运行时常量池中存放。

运行时常量池相对于Class文件常量池的另外一个特征具有动态性，可以在运行期间将新的常量放入池 中（典型的如String类的intern()方法）。

## 永久代和元空间区别

永久代和元空间存储位置和存储内容的区别：

此处画图说明

通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？带着这个疑问，最后给大家总结以下几点原 因：

其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了 Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量 (class statics)转移到了java heap。

方法区异常演示类加载导致OOM异常案例代码

我们现在通过动态生成类来模拟方法区的内存溢出：

JDK1.7分析

指定的

区的大小为 8M。

绝大部分 Java 程序员应该都见过 "java.lang.OutOfMemoryError: PermGen space "这个异 常。这里的 “ PermGen space ”其实指的就是方法区。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况， 容易出现永久代内存溢出。

JDK1.8+

现在我们在 JDK 8下重新运行一下案例代码，不过这次不再指定

和 MaxPermSize 。而是

指定 和 MaxMetaSpaceSize 的大小。输出结果如下：

从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。

字符串OOM异常

案例代码

以下这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存：

JDK1.6

JDK 1.6 的运行结果：

JDK 1.6下，会出现永久代的内存溢出。

JDK1.7

JDK 1.7的运行结果：

在 JDK 1.7中，会出现堆内存溢出。结论是：JDK 1.7 已经将字符串常量由永久代转移到堆中。

JDK1.8+

JDK 1.8的运行结果：

在JDK 1.8 中，也会出现堆内存溢出，并且显示 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以验证 JDK 1.8 中已经不存在永久代的结论。

## 运行时常量池和字符串常量池

#### 存储内容

Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编 译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

字面量：

双引号引起来的字符串值，“kkb” 定义为final类型的常量的值。

符号引用：

类或接口的全限定名（包括他的父类和所实现的接口） 变量或方法的名称

变量或方法的描述信息

方法的描述：参数个数、参数类型、方法返回类型等等变量的描述信息：变量的返回值

this

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定 只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运 行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方 法。

#### 存储位置

在JDK1.6及以前，运行时常量池是方法区的一部分。

在JDK1.7及以后，运行时常量池在Java 堆（Heap）中。

运行时和class常量池一样，运行时常量池也是每个类都有一个。但是字符串常量池全只有一个

#### 常量池区别

class常量池（静态常量池）、运行时常量池、字符串常量池区别：

class常量池中存储的是符号引用，而运行时常量池存储的是被解析之后的直接引用。class常量池存在于class文件中，运行时常量池和字符串常量池是存在于JVM内存中。

运行时常量池具有动态性，java运行期间也可能将新的常量放入池中(String#intern())，

字符串常量池逻辑上属于运行时常量池的一部分，但是它和运行时常量池的区别在于，字符串常量 池是全局唯一的，而运行时常量池是每个类一个。

#### 字符串常量池如何存储数据

实际上，为了提高匹配速度，即更快的查找某个字符串是否存在于常量池，Java在设计字符串常量池的 时候，还搞了一张stringtable， stringtable 有点类似于我们的hashtable，里面保存了字符串的引用。

在jdk6中StringTable 的长度是固定的，就是1009，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长。此时当调用String.intern() 时会需要到链表上一个一个找，从而导致性能大幅度下降；

在jdk7+， StringTable 的长度可以通过一个参数指定：

stringtable是类似于hashtable的数据结构，hashtable数据结构如下：

字符串常量池查找字符串的方式：

根据字符串的hashcode 找到对应entry。如果没冲突，它可能只是一个entry，如果有冲突，它可能是一个entry链表，然后Java再遍历entry链表，匹配引用对应的字符串。

如果找得到字符串，返回引用。如果找不到字符串，会把字符串放到常量池，并把引用保存到stringtable里。

#### 字符串常量池介绍

上面我们已经稍微了解过字符串常量池了，它是java为了节省空间而设计的一个内存区域，java中所有的类共享一个字符串常量池。

比如A类中需要一个“hello”的字符串常量，B类也需要同样的字符串常量，他们都是从字符串常量池中获取的字符串，并且获得得到的字符串常量的地址是一样的。

#### 字符串常量池案例分析

String的Intern方法详解

先让大家做个面试题：

如果大家能一题不差的全做对，接下来的内容应该不用看了。如果不能并且有兴趣的话，可以稍微了解 一下以下

intern的作用

intern的作用是把new出来的字符串的引用添加到stringtable中，java会先计算string的hashcode，查找stringtable中是否已经有string对应的引用了，如果有返回引用（地址），然后没 有把字符串的地址放到stringtable中，并返回字符串的引用（地址）。

我们继续看例子：

因为有双引号括起来的字符串，所以会把ldc命令，即"haha"会被我们添加到字符串常量池，它 的引用是string的char数组的地址，会被我们添加到stringtable中。所以a.intern的时候， 返回的其实是string中的char数组的地址，和a的string实例化地址肯定是不一样的。

new String("jo") + new String("hn") 实 际 上 会 转 为 stringbuffer 的 append 然 后 tosring()出来，实际上是new 一个新的string出来。在这个过程中，并没有双引号括起john， 也就是说并不会执行ldc然后把john的引用添加到stringtable中，所以intern的时候实际就是把新的string地址（即e的地址）添加到stringtable中并且返回回来。

或许很多朋友感觉很奇怪，这跟上面的例子2基本一模一样，但是却是false呢？这是因为java在启动的时候，会把一部分的字符串添加到字符串常量池中，而这个“java”就是其中之一。所以intern回来的引用是早就添加到字符串常量池中的”java“的引用，所以肯定跟f的原地址不一 样。

JDK6中的理解

Jdk6中字符串常量池位于PermGen（永久代）中，PermGen是一块主要用于存放已加载的类信息和字符串池的大小固定的区域。

执行intern()方法时，若常量池中不存在等值的字符串，JVM就会在常量池中创建一个等值的字符串， 然后返回该字符串的引用。除此以外，JVM 会自动在常量池中保存一份之前已使用过的字符串集合。

Jdk6中使用intern()方法的主要问题就在于字符串常量池被保存在PermGen中：

首先，PermGen是一块大小固定的区域，一般不同的平台PermGen的默认大小也不相同， 大致在32M到96M之间。所以不能对不受控制的运行时字符串（如用户输入信息等）使用intern()方法，否则很有可能会引发PermGen内存溢出；

其次String对象保存在Java堆区，Java堆区与PermGen是物理隔离的，因此如果对多个不等值的字符串对象执行intern操作，则会导致内存中存在许多重复的字符串，会造成性能 损失。

JDK7+的理解

Jdk7将常量池从PermGen区移到了Java堆区。堆区的大小一般不受限，所以将常量池从PremGen区移

到堆区使得常量池的使用不再受限于固定大小。可以使用符串池的map大小。

虚拟机参数设置字

执行intern操作时，如果常量池已经存在该字符串，则直接返回字符串引用，否则复制该字符串对象的 引用到常量池中并返回。

除此之外，位于堆区的常量池中的对象可以被垃圾回收。当常量池中的字符串不再存在指向它的引用 时，JVM就会回收该字符串。

intern案例分析

打印结果是

jdk6 下 false false

jdk7 下 false true

具体为什么稍后再解释，然后将s3.intern(); 语句下调一行，放到String s4 = "11"; 后面。将

放到String s2 = "1"; 后面。是什么结果呢？

打印结果为：

jdk6 下false false

jdk7 下false false

jdk6中的解释

如上图所示。在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用String.intern 方法也是没有任何关系的。

jdk7中的解释

在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的Perm区的，Perm区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用intern 是会直接产生java.lang.OutOfMemoryError:PermGen space 错误的。

在 jdk7 的版本中，字符串常量池已经从Perm区移到正常的Java Heap区域了。为什么要移动，Perm 区域太小是一个主要原因，而且jdk8已经直接取消了Perm区域，而新建立了一个元区域。应该是jdk开 发者认为Perm区域已经不适合现在 JAVA 的发展了。正式因为字符串常量池移动到JAVA Heap区域后， 再来解释为什么会有上述的打印结果。

在 第 一 段 代 码 中 ， 先 看 s3 和 s4 字 符 串 。 String s3 = new String("1") + new String("1"); ，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap

中的 s3引用指向的对象。中间还有2个匿名的new String("1") 我们不去讨论它们。此时s3引用对象内容是”11″，但此时常量池中是没有 “11”对象的。

接下来s3.intern(); 这一句代码，是将 s3中的"11"字符串放入String 常量池中，因为此时常

量池中不存在"11"字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一

个"11"的对象，关键点是 jdk7 中常量池不在Perm区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向s3引用的对象。 也就是说引用地址是相同的。

最后String s4 = "11"; 这句代码中”11″是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向s3引用对象的一个引用。所以s4引用就指向和s3一

样了。因此最后的比较 是 true 。

再看s和 s2 对象。 String s = new String("1"); 第一句代码，生成了2个对象。常量池中

的“1” 和 JAVA Heap 中的字符串对象。 s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。

接下来String s2 = "1"; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就

是 s 和 s2 的引用地址明显不同。图中画的很清晰。

来看第二段代码，从上边第二幅图中观察。第一段代码和第二段代码的改变就是

的顺序是放在String s4 = "11"; 后了。这样，首先执行String s4 = "11"; 声明 s4 的时候常量池中是不存在“11”对象的，执行完毕后，“11“对象是 s4 声明产生的新对象。然后再执行s3.intern(); 时，常量池中“11”对象已经存在了，因此 s3 和 s4 的引用是不同的。

第二段代码中的 s 和 s2 代码中， s.intern(); ，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码String s = new String("1"); 的时候已经生成“1”对象了。下边的s2声明都是直接从常量池中取地址引用的。 s 和 s2 的引用地址是不会相等的。

小结

从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：

将String常量池从Perm区移动到了Java Heap区

方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对

象。

intern方法的好处

如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成StringBuilder.append，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。

那么，有了这个特性了，intern就有用武之地了。那就是很多时候，我们在程序中得到的字符串是只有 在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中。

这时候，对于那种可能经常使用的字符串，使用intern进行定义，每次JVM运行到这段代码的时候，就 会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了。

以上程序会有很多重复的相同的字符串产生，但是这些字符串的值都是只有在运行期才能确定的。所 以，只能我们通过intern显示的将其加入常量池，这样可以减少很多字符串的重复创建。

Jdk6 中常量池位于PremGen区，大小受限，不建议使用String.intern()方法，不过Jdk7 将常量池移到了Java堆区，大小可控，可以重新考虑使用String.intern()方法，但是由对比测试可知，使用该方法的耗时不容忽视，所以需要慎重考虑该方法的使用；

String.intern() 方法主要适用于程序中需要保存有限个会被反复使用的值的场景，这样可以减少内存消耗，同时在进行比较操作时减少时耗，提高程序性能。

## Java堆

#### 概念

Java堆被所有线程共享，在Java虚拟机启动时创建。是虚拟机管理最大的一块内存。

Java堆是垃圾回收的主要区域，而且主要采用分代回收算法。堆进一步划分主要是为了更好的回收内 存或更快的分配内存。

#### 存储内容

Java虚拟机规范的描是：所有的对象实例以及数组都要在堆上分配。

不过随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微 妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

#### 存储方式

堆内存空间在物理上可以不连续，逻辑上连续即可。

#### 堆内存划分

新生代

Eden空间[伊甸园] From Survivor 空 间To Survivor空间

老年代

堆大小 = 新生代 + 老年代。

堆的大小可通过参数–Xms（堆的初始容量）、-Xmx（堆的最大容量） 来指定。

其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。

默认的，Edem : from : to = 8 : 1 : 1 。(可以通过参数 –XX:SurvivorRatio 来设定 。即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。

JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。

新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。

#### 对象创建

内存的分配原则

序号

介绍

1

优先在Eden 分配,如果Eden 空间不足虚拟机则会进行一次MinorGC

2

大对象直接接入老年代,大对象一般指的是很长的字符串或数组

3

长期存活的对象进入老年代，每个对象都有一个age，当age到达设定的年龄的时候就会进 入老年代，默认是15岁。

#### 内存分配方式

内存分配的方法有两种:指针碰撞(Bump the Pointer)和空闲列表(Free List)

分配方法

说明

收集器

指针碰撞

内存地址是连续的

Serial 和ParNew 收集器

空闲列表

内存地址不连续

CMS 收集器和Mark-Sweep 收集器

## 内存分配安全问题

在分配内存的同时，存在线程安全的问题，即虚拟机给A线程分配内存过程中，指针未修改，B线程可能 同时使用了同样一块内存。

在JVM中有两种解决办法：

1. CAS，比较和交换（Compare And Swap）： CAS 是乐观锁的一种实现方式。所谓乐观锁就是， 每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟 机采用 CAS 配上失败重试的方式保证更新操作的原子性。
2. TLAB，本地线程分配缓冲(Thread Local Allocation Buffer即TLAB)： 为每一个线程预先分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。

#### 对象的内存布局

对象在内存中存储的布局可以分为三块区域：对象头（Header），实例数据（Instance Data）和对齐填充（Padding）。

- 对象头

对象头包括两部分信息：

一部分是用于存储对象自身的运行数据，如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的

另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪一个 类的实例。当对象是一个java数组的时候，那么对象头还必须有一块用于记录数组长度的数据，因此虚 拟机可以通过普通java对象的元数据信息确定java对象的大小，但是从数组的元数据中无法确定数组的大小。

- 实例数据

存储的是对象真正有效的信息。

- 对齐填充

这部分并不是必须要存在的，没有特别的含义，在jvm中对象的大小必须是8字节的整数倍，而对象头也 是8字节的倍数，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

#### 对象访问方式

方式

优点

句柄

稳定，对象被移动只要修改句柄中的地址

直接指针

访问速度快，节省了一次指针定位的开销

数组的内存分析

一维数组

array1.jpg

先把 arr1 压进栈，然后在堆空间中开辟一个空间，并把值初始化为0（arr1为引用变量，但是内部数据是int类型，默认值为 0），最后把 开辟的堆空间地址 赋值给arr1

把 arr1 中的 地址 赋值给 arr2，此时 arr2 和 arr1 指向同一块空间。

此时，arr1[0] 值为 20。

二维数组

这条语句会先把 array 压栈，然后在堆中开辟一个空间，初始值为 null（array为引用变量， 第一维同样是引用类型），最后把开辟的堆空间地址赋值给 array。

这条语句会在堆空间中开辟一个 只有一个 int 类型大小的空间，并初始化为 0 ，然后把自己的地址赋值给array[0][]。

这两条语句和上一条意义一样，就不再做解释

## 程序计数器

### 作用

程序计数器（Program Counter Register），也叫PC寄存器，是一块较小的内存空间，它可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器的工作就是通过改变这个计数器的值来选取下 一条需要执行的字节码指令。分支，循环，跳转，异常处理，线程回复等都需要依赖这个计数器来完成 。

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定 的时刻，一个处理器（针对多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线 程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互 不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

### 存储的数据

如果一个线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址； 如果正在执行的是一个Native方法，这个计数器的值则为空。

### 异常

此内存区域是唯一一个在Java的虚拟机规范中没有规定任何OutOfMemoryError异常情况的区域。

## Java虚拟机栈

虚拟机栈也是线程私有，而且生命周期与线程相同，每个Java方法在执行的时候都会创建一个栈帧

（Stack Frame） 。

### 栈帧

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一 个栈帧在虚拟机栈里从入栈到出栈的过程。

一个线程中方法的调用链可能会很长，很多方法都同时处于执行状态。对于JVM执行引擎来说，在在活动线程中，只有位于JVM虚拟机栈栈顶的元素才是有效的，即称为当前栈帧，与这个栈帧相关连的方法称为当前方法，定义这个方法的类叫做当前类。

执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。如果当前方法调用了其他方法，或者当前 方法执行结束，那这个方法的栈帧就不再是当前栈帧了。

调用新的方法时，新的栈帧也会随之创建。并且随着程序控制权转移到新方法，新的栈帧成为了当前栈 帧。方法返回之际，原栈帧会返回方法的执行结果给之前的栈帧(返回给方法调用者)，随后虚拟机将会 丢弃此栈帧。

关于「栈帧」，我们在看看《Java虚拟机规范》中的描述：

栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态连接、方法返回值和异常分 派。

栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法 结束。

栈帧的存储空间由创建它的线程分配在Java虚拟机栈之中，每一个栈帧都有自己的本地变量表 (局部变量表)、操作数栈和指向当前方法所属的类的运行时常量池的引用。

接下来，详细讲解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的数据结 构和作用。

局部变量表存储内容

局部变量表(Local Variable Table) 是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。

一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、reference和returnAddress类型 的数据。reference类型表示对一个对象实例的引用。returnAddress类型是为jsr、jsr_w和ret指令服务的，目前已经很少使用了。

存储容量

局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。

在Java程序编译为Class文件时，就在方法的Code属性中的max_locals数据项中确定了该方法所 需分配的局部变量表的最大容量。(最大Slot数量)

其他

虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从 0~局部变量表最大容量 。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)时，会连续使用两个连续的Slot来存 储。

操作数栈作用

操作数栈(Operand Stack)也常称为操作栈，它是一个后入先出栈(LIFO) 。

当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表 或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表 或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈 的过程。

存储内容

操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2 个栈容量。

存储容量

同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks 数据项中。且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks 中设置的最大值。

动态连接

在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的

直接引用，而符号引用存在于方法区中的运行时常量池。

Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的 目的是为了支持方法调用过程中的动态连接(Dynamic Linking)。

这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解 析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。

方法返回

当一个方法开始执行时，可能有两种方式退出该方法：

正常完成出口异常完成出口

正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能 会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将 根据该方法返回的字节码指令确定。

异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退 出。

无论是Java虚拟机抛出的异常还是代码中使用athrow指令产生的异常，只要在本方法的异常表中 没有搜索到相应的异常处理器，就会导致方法退出。

无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法 返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。

方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变 量表和操作数栈，把返回值(如果有的话)压入调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。

一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法 异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。

附加信息

虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信 息，这部分信息完全取决于不同的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其 他附加信息一起归为一类，称为栈帧信息。

### 栈异常

Java虚拟机规范中，对该区域规定了这两种异常情况：

1. 如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError 异常；
2. 虚拟机栈可以动态拓展，当扩展时无法申请到足够的内存，就会抛出OutOfMemoryError 异常。

## 本地方法栈

本地方法栈和虚拟机栈相似，区别就是虚拟机栈为虚拟机执行Java服务（字节码服务），而本地方法 栈为虚拟机使用到的Native方法（比如C++方法）服务。

#### 本地方法介绍

什么是本地方法

简单地讲，一个Native Method就是一个java调用非java代码的接口。

一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。

在定义一个native method时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。下面给了一个示例：

这些方法的声明描述了一些非java代码在这些java代码里看起来像什么样子。

标识符native可以与所有其它的java标识符连用，但是abstract除外。这是合理的，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。

native与其它java标识符连用时，其意义同非Native Method并无差别，比如native static表明这个方法可以在不产生类的实例时直接调用，这非常方便，比如当你想用一个native method去调用一个C的类库时。上面的第三个方法用到了native synchronized，JVM在进入这个方法的实现体之前会执行同步锁机制（就像java的多线程。）

一个native method方法可以返回任何java类型，包括非基本类型，而且同样可以进行异常控制。

这些方法的实现体可以制一个异常并且将其抛出，这一点与java的方法非常相似。

当一个native method接收到一些非基本类型时如Object或一个整型数组时，这个方法可以访问这些非基本型的内部，但是这将使这个native方法依赖于你所访问的java类的实现。有一点要牢牢记 住：我们可以在一个native method的本地实现中访问所有的java特性，但是这要依赖于你所访问的java特性的实现，而且这样做远远不如在java语言中使用那些特性方便和容易。

native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。需要注意当我们将一个本地方法声明为final的情况。用java实现的方法体在被编译时可能会因为内联而产生效率上的提升。但是一个native final方法是否也能获得这样的好处却是值得怀疑的，但是这只是一个代码优化方面的问题，对功能实现没有影响。

如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这 个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写。

本地方法非常有用，因为它有效地扩充了jvm。事实上，我们所写的java代码已经用到了本地方法，在 sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java 程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。

为什么要使用本地方法

java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意 时，问题就来了。

有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与 一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们 提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。

JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码） 和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法， 我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要 使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

JVM怎样使本地方法跑起来

我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个 被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。

如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时， 其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。

最后需要提示的是，使用本地方法是有开销的，它丧失了java的很多好处。如果别无选择，我们可以选 择使用本地方法。

#### 本地方法栈的使用流程

当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。本地方法可以 通过本地方法接口来访问虚拟机的运行时数据区，但不止如此，它还可以做任何它想做的事情。

本地方法本质上时依赖于实现的，虚拟机实现的设计者们可以自由地决定使用怎样的机制来让Java程序 调用本地方法。

任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压 入Java栈。然而当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新 的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。

如果某个虚拟机实现的本地方法接口是使用C连接模型的话，那么它的本地方法栈就是C栈。当C程序 调用一个C函数时，其栈操作都是确定的。传递给该函数的参数以某个确定的顺序压入栈，它的返回值 也以确定的方式传回调用者。同样，这就是虚拟机实现中本地方法栈的行为。

很可能本地方法接口需要回调Java虚拟机中的Java方法，在这种情况下，该线程会保存本地方法栈的 状态并进入到另一个Java栈。

下图描绘了这样一个情景，就是当一个线程调用一个本地方法时，本地方法又回调虚拟机中的另一个Java方法。

这幅图展示了JAVA虚拟机内部线程运行的全景图。一个线程可能在整个生命周期中都执行Java方法， 操作它的Java栈；或者它可能毫无障碍地在Java栈和本地方法栈之间跳转。

该线程首先调用了两个Java方法，而第二个Java方法又调用了一个本地方法，这样导致虚拟机使用了 一个本地方法栈。假设这是一个C语言栈，其间有两个C函数，第一个C函数被第二个Java方法当做本地方法调用，而这个C函数又调用了第二个C函数。之后第二个C函数又通过本地方法接口回调了一个Java 方法（第三个Java方法），最终这个Java方法又调用了一个Java方法（它成为图中的当前方法）。

# 八、栈顶元素数学操作及移位操作系列

## 运算指令

1、运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

2、算术指令分为两种：整型运算的指令和浮点型运算的指令。

3、无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、short、char和boolean类型的算术指令，使用操作int类型的指令代替。

## 类型转换指令

1、类型转换指令可以将两种不同的数值类型进行相互转换。

2、这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类 型相关指令无法与数据类型一一对应的问题。

#### 宽化类型转换

int类型到long、float或者double类型。long类型到float、double类型。 float类型到double类型。

#### 窄化类型转换

对象创建与访问指令

创建类实例的指令：new。

创建数组的指令：newarray、anewarray、multianewarray。

访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指 令：getfield、putfield、getstatic、putstatic。

把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。

将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。

取数组长度的指令：arraylength。

检查类实例类型的指令：instanceof、checkcast。

#### 操作数栈管理指令

直接操作操作数栈的指令：

将操作数栈的栈顶一个或两个元素出栈：pop、pop2。

复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。

将栈最顶端的两个数值互换：swap。

#### 控制转移指令

1、控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条 指令继续执行程序。

2、从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。

条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。 复合条件分支：tableswitch、lookupswitch。

无条件分支：goto、goto_w、jsr、jsr_w、ret。

在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个实体值是否null，也有专门的指令用来检测null值。

对应到执行引擎的各执行部件如图：

在开始执行方法之前，PC寄存器存储的指针是第1条指令的地址，局部变量区和操作栈都没有数据。从 第1条到第4条指令分别将a、b两个本地变量赋值，对应到局部变量区就是1和2分别存储常数1和2，如 图：

第5条和第6条指令分别是将两个局部变量入栈，然后相加，如图：

1先入栈2后入栈，栈顶元素是2，第7条指令是将栈顶的两个元素弹出后相加，结果再入栈，如图：

可以看出，变量a和b相加的结果3存在当前栈顶中，接下来第8条指令将10入栈，如图：

当前PC寄存器执行的地址是9，下一个操作是将当前栈的两个操作数弹出进行相乘并把结果压入栈中， 如图：

第10条指令是将当前的栈顶元素存入局部变量3中，如图：

第10条指令执行完后栈中元素出栈，出栈的元素存储在局部变量区3中，对应的是变量c的值。最后一条 指令是return，这条指令执行完后当前的这个方法对应的这些部件会被JVM回收，局部变量区的所有值 将全部释放，PC寄存器会被销毁，在Java栈中与这个方法对应的栈帧将消失。

## 方法调用

### 重载和重写

同一个类中，如果出现多个名称相同，并且参数类型相同的方法，将无法通过编译。因此，想要 在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这种方法上的联系就是重 载。

重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java编译器会根据所传入参数的声明 类型(有别实际类型)来选取重载方法。

选取过程如下：

1. 不考虑对基本类型自动装拆箱(auto-boxing，auto-unboxing)，以及可变长参数的情况下选取 重载方法;
   1. 如果1中未找到适配的方法，则允许自动装拆箱，但不允许可变长参数的情况下选取重载方法;
   2. 如果2中未找到适配的方法，则在允许自动装拆箱以及可变长参数的情况下选取重载方法.

那么，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么 这两个方法之间又是什么关系呢？

如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。

如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。

众所周知，Java 是一门面向对象的编程语言，它的一个重要特性便是多态。而方法重写，正是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

# JVM的静态绑定和动态绑定

Java虚拟机识别方法的关键在于【类名 + 方法名 + 方法描述符(method descriptor)】。

注：方法描述符由方法的【参数类型 + 返回类型】构成。

把一个【方法】与其所在的【类/对象】关联起来叫做方法的绑定。方法绑定分为静态绑定（前期绑 定）和动态绑定（后期绑定）。

#### 静态绑定

Java虚拟机中的静态绑定(static binding)指的是在解析时便能够直接识别目标方法的情况；在程序运行前就已经知道方法是属于那个类的，在编译的时候就可以连接到类的中，定位到这个方法。

在Java中，final、private、static修饰的方法以及构造函数都是静态绑定的，不需程序运行，不需具体的实例对象就可以知道这个方法的具体内容。

#### 动态绑定

而动态绑定(dynamic binding)则指的是需要在运行过程中根据调用者的动态类型（具体的实例对象）来识别目标方法的情况。

动态绑定是多态性得以实现的重要因素，它通过方法表来实现：每个类被加载到虚拟机时，在方法区保 存元数据，其中，包括一个叫做 方法表（method table）的东西，表中记录了这个类定义的方法的指针，每个表项指向一个具体的方法代码。如果这个类重写了父类中的某个方法，则对应表项指向新的代 码实现处。从父类继承来的方法位于子类定义的方法的前面。

动态绑定语句的编译、运行原理：我们假设Son继承自Father，重写了say()。

1：编译：我们知道，向上转型时，用父类引用指向子类对象，并可以用父类引用调用子类中重写了的 同名方法。但是不能调用子类中新增的方法，为什么呢？

因为在代码的编译阶段，编译器通过 声明对象的类型（即引用本身的类型） 在方法区中该类型的方法表中查找匹配的方法（最佳匹配法：参数类型最接近的被调用），如果有则编译通过。（这里是根据 声明的对象类型来查找的，所以此处是查找 Father类的方法表，而Father类方法表中是没有子类新增的方法的，所以不能调用。）

编译阶段是确保方法的存在性，保证程序能顺利、安全运行。

2：运行：我们又知道，ft.say()调用的是Son中的say()，这不就与上面说的，查找Father类的方法 表的匹配方法矛盾了吗？不，这里就是动态绑定机制的真正体现。

上面编译阶段在 声明对象类型 的方法表中查找方法，只是为了安全地通过编译（也为了检验方法是

否是存在的）。而在实际运行这条语句时，在执行 这一句时创建了一个Son

实例对象，然后在 调用方法时，JVM会把刚才的son对象压入操作数栈，用它来进行调用。

而用实例对象进行方法调用的过程就是动态绑定：根据实例对象所属的类型去查找它的方法表，找到 匹配的方法进行调用。我们知道，子类中如果重写了父类的方法，则方法表中同名表项会指向子类的方法代 码；若无重写，则按照父类中的方法表顺序保存在子类方法表中。

故此：动态绑定根据对象的类型的方法表查找方法是一定会匹配（因为编译时在父类方法表中以及查找 并匹配成功了，说明方法是存在的。这也解释了为何向上转型时父类引用不能调用子类新增的方法：在 父类方法表中必须先对这个方法的存在性进行检验，如果在运行时才检验就容易出危险——可能子类 中也没有这个方法）。

程序在JVM运行过程中，会把类的类型信息、static属性和方法、final常量等元数据加载到方法区， 这些在类被加载时就已经知道，不需对象的创建就能访问的，就是静态绑定的内容；需要等对象创建 出来，使用时根据堆中的实例对象的类型才进行取用的就是动态绑定的内容。

那么这些指令又是怎么来调用方法的呢？(invokedynamic和这些有点不一样，稍后单独解释下)

在编译的过程中，JVM并不知道目标方法的具体内存地址，此时编译器会用”符号引用”来表示该方法(加载阶段)。当JVM进行到“解析”阶段的时候，这些引用会被替换为直接引用，这个时候就知道需要去哪里调用到方法了！

对于静态绑定的方法，直接引用就是直接指向方法的指针，而对于动态绑定的方法，直接引用其实指向 方法表中的一个索引。

方法表是一个数组，每个数组元素指向一个当前类及其父类中非private的实例方法，样子如下所示：

由于动态绑定相比于静态绑定，在寻找方法时要出多好一个内存解析的动作，例如获取调用者类型，获 取方法表，获取方法表的索引值等等，还是有点开销的，虽然这些开销是必须的。所以JVM中引入了一 些优化的技术： 内存缓联+方法内联。

具体来说，Java字节码指令中与调用相关的指令共有五种： invokevirtual ：

用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最

常见的方法分派方式。

invokeinterface ：

用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调 用。

invokespecial ：

用于调用一些需要特殊处理的实例方法，包括实例初始化（＜init＞）方法、私有方法和父类方法。

invokestatic ：

调用静态方法（static方法）。invokedynamic ：

用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻 辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定 的。

## 调用指令的符号引用

在编译过程中，目标方法的具体内存地址尚未确定.这时，Java编译器会暂时用符号引用来表示该目标方 法.这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符.

符号引用存储在class文件的常量池中.根据目标方法是否为接口方法，又可分为接口符号引用和非接口符 号引用。

对于非接口符号引用，假定该目标方法的符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 C 中查找符合名字及描述符的方法（本类中查找）。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类（父类中查找）。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个（接口中查找）。

从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写 区分）父类中的同名、同描述符的静态方法。

对于接口符号引用，假定该目标方法的符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 I 中查找符合名字及描述符的方法（本接口查找）。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索（Object类查找）。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致（父类接口中查找）。

经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用 是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。

## 虚方法调用

所有非私有实例方法被调用-->编译-->invokevirtual指令. 接口方法调用-->编译-->invokeinterface指令.

这两种指令，均属于Java虚拟机中的虚方法调用.

多数情况下，Java虚拟机需要根据调用者的动态类型-->确定虚方法调用的目标方法。这个过程被称为 动态绑定.

相对于静态绑定的非虚方法调用，虚方法调用更加耗时.

在Java虚拟机中，静态绑定包括用于调用静态方法的invokestatic指令，和用于调用构造器/私有

（private）实例方法/超类非私有实例方法的invokespecial指令.

如果虚方法调用指向一个标记为final的方法，那么Java虚拟机也可以静态绑定该虚方法调用的目标方法 .

Java虚拟机采用了一种用空间换时间的策略来实现动态绑定.它为每个类生成一张方法表，用以快速定位 目标方法.

## 方法表

类加载的准备阶段，除了为静态字段分配内存外，还会构建与该类相关联的方法表. 方法表，是Java虚拟机实现动态绑定的关键所在.

方法表本质上是一个数组，每个数组元素指向一个当前类及其父类中非私有的实例方法.

方法表满足两个特质:

1. 子类方法表中包含父类方法表中的所有方法
2. 子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同.

方法调用指令中的符号引用会在执行之前解析为实际引用.

静态绑定的方法调用:实际引用-->具体的目标方法。

动态绑定的方法调用:实际引用-->方法表的索引值(实际上不止索引值)。

在执行过程中，Java虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引 值获得目标方法--->动态绑定的过程。

事实上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作 ： 访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对 于创建并初始化Java栈帧来说，这几个内存解引用操作的开销可以忽略不计。

但是，虚方法调用对性能仍有影响：

方法表的引入带来的优化效果仅存在于解释执行或者即时编译代码的最坏情况下。而且即时编译还拥有 两个性能更好的优化手段：内联缓存(inlining cache)和方法内联(method inlining)。

## 内联缓存

内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所 对应的目标方法。后续执行中，优先使用缓存，没有则使用基于方法表的动态绑定。

对多态的优化术语：

1. 单态(monomorphic)，指的是仅有一种状态的情况。
2. 多态(polymorphic)，指的是有限数量种状态的情况。二态(bimorphic)是多态的其中一种。
3. 超多态(megamorphic)，指的是更多种状态的情况。通常用某个阈值来区分多态和超多态。

综上，内联缓存对应单态内联缓存/多态内联缓存/超多态内联缓存。

1. 单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简 单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。
2. 多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类 型进行比较，如果命中，则调用对应的目标方法。

注：一般来说，我们会将更加热门的动态类型放在前面。在实践中，大部分的虚方法调用均是单 态的，也就是只有一种动态类型。为了节省内存空间，Java 虚拟机只采用单态内联缓存。

在选择内联缓存时，如果未命中则重新使用方法表做动态绑定。这时有两种选择：

1. 替换单态内联缓存中的纪录。这种做法就好比 CPU 中的数据缓存，它对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地 利用内联缓存。因此，在最坏情况下，用两种不同类型的调用者，轮流执行该方法调用，那么每次 进行方法调用都将替换内联缓存。也就是说，只有写缓存的额外开销，而没有使用缓存的性能提 升。
2. 劣化为超多态状态。这也是 Java 虚拟机的具体实现方式。处于这种状态下的内联缓存，实际上放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法。与替换内联缓存纪录的做法相 比，它牺牲了优化的机会，但是节省了写缓存的额外开销。

虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联 ，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方 法所使用的栈帧。

## JVM处理invokedynamic

在Java中，方法调用会编译为invokestatic/invokespecial/invokevirtual/invokeinterface四 种指令。这些类名与包含目标方法类名/方法名/方法描述符的符号引用捆绑。在实际运行之前，Java虚 拟机将根据这个符号引用链接到具体的目标方法。

Java7引入了invokedynamic指令，该指令的调用机制抽象出调用点这一概念，并允许应用程序将调用 点链接至任何符合条件的方法上。

作为invokedynamic的准备工作，Java7引入了更加底层/更加灵活的方法抽象：方法句柄(MethodHandle).

#### 方法句柄的概念

方法句柄是一种强类型的，能够被直接执行的引用。该引用可以指向常规的静态方法或者实例方法，也 可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上 等价于目标字段的getter或者setter方法。

HotSpot虚拟机中方法句柄调用的具体实现 ：

以DirectMethodHandle为例，调用方法句柄所使用的invokeExact或者invoke方法具备签名多态性的 特性。会根据具体的传入参数来生成方法描述符。其中，invokeExact要求传入的参数和所指向方法的 描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句 柄来实现的。

方法句柄的调用和反射调用一样，都是间接调用。同样都面临无法内联的问题，不过与反射调用不同的 是，方法句柄的内联瓶颈在于即时编译器能否将该方法句柄识别为常量。

##### invokedynamic指令

invokedynamic是Java7引入的一条新指令，用以支持动态语言的方法调用。具体来说，它将调用点(CallSite)抽象成一个Java类，并且将原本由Java虚拟机控制的方法调用以及方法链接暴露给了应用程序。在运行过程中，每一条invokedynamic指令将捆绑一个调用点，并会调用该调用点所链接的方法 句柄.

在第一次执行invokedynamic指令时，Java虚拟机会调用该指令所对应的启动方法(BootStrapMethod)，来生成调用点，并将之绑定至该invokedynamic指令中。在之后的运行过程中，Java虚拟机则会直接调用绑定的调用点所链接的方法句柄。

在字节码中，启动方法是用方法句柄来指定的。这个方法句柄指向一个返回类型为调用点的静态方法。 该方法必须接收三个固定的参数，分别为一个Lookup类实例，一个用来指代目标方法名字的字符串， 以及该调用点能够链接的方法句柄的类型。

除了三个必须参数外，启动方法(BootStrapMethod)还可以接收若干个其它的参数，用来辅助生成调 用点，或者定位索要链接的目标方法。

Java8的Lambda表达式

在Java8中，Lambda表达式也是借助invokedynamic来实现的。

具体来说，Java编译器利用invokedynamic指令来生成实现了函数式接口的适配器。这里的函数式接口指的是仅包括一个非default接口方法的接口，一般通过@FunctionalInterface注解。同时，该 invokedynamic指令对应的启动方法将通过ASM生成一个适配器类。

对于没有捕获其它变量的Lambda表达式，该invokedynamic指令始终返回同一个适配器类的实例。对 于捕获了其它变量的Lambda表达式，每次执行invokedynamic指令将新建一个适配器类实例。

不管是捕获型的还是未捕获型的Lambda表达式，它们的性能上限皆可以达到直接调用的性能。其中，捕 获型Lambda表达式借助了即时编译器的逃逸分析，来避免实际的新建适配器类实例的操作。

### 总结

1、Class文件的编译过程中不包含传统编译中的连接步骤，所有方法调用中的目标方法在Class文件里 面都是一个常量池中的符号引用，而不是方法在实际运行时内存布局中的入口地址。

2、在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这类方法（编译期可知，运行 期不可变）的调用称为解析（Resolution）。

主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自 的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解 析。

3、只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版 本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把 符号引用解析为该方法的直接引用。

# 六、垃圾回收

## 3.1 判断算法

主要是2种：引用计数法和根搜索算法

##### 3.1.1 引用计数法（Reference Counting）

1. 概念

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1：当引用失效时，计数器值 就减1：任何时刻计数器都为0的对象就是不可能再被使用的。

1. 优点

实现简单，判断效率高，大部分情况下都是很不错的算法

1. 缺点

Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环 引用的问题。

- 根搜索算法（GCRoots Tracing）

1. 概念

又叫可达性算法。在主流的商用程序语言中（Java和C#），都是使用根搜索算法判定对象是否存活 的。

基本思路就是通过一系列的名为“GCRoot”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GCRoot没有任何引用链相连（就是从GCRoot到这个对象不可达）时，则证明此对象是不可用的。

不可达不一定会被回收，可以用finalize()方法抢救下，但绝对不推荐

1. 可作GCRoots的对象

虚拟机栈（栈帧中的本地变量表）中的引用的对象。方法区中的类静态属性引用的对象。

方法区中的常量引用的对象。

本地方法栈中JNl（即一般说的Native方法）的引用的对象。

- 对象引用

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（StrongReference）、软引用

（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）四种，这四种引用强度依次逐渐减弱。

1. 强引用

代码中普遍存在，类似“Object obj=new Object()”这类引用，只要强引用还在，就不会被

GC。

1. 软引用

非必须引用，内存溢出之前进行回收，如内存还不够，才会抛异常。

1. 弱引用

非必须引用，只要有GC，就会被回收。

弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃 圾回收时，将返回null。

弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。

1. 虚引用

垃圾回收时回收，无法通过引用取到对象值

也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不 会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一 目的就是希望能在这个对象被收集器回收时收到一个系统通知。

虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被 成为幽灵引用。

虚引用主要用于检测对象是否已经从内存中删除。

#### 3.1.4 回收过程

即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段， 要真正宣告一个对象死亡，至少要经历两次标记过程。

第一次标记：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；

第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize() 方法。在finalize() 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。

第二次标记成功的对象将真的会被回收，如果对象在finalize() 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。

#### 3.1.5 方法区回收

1. 概念

方法区也是有垃圾回收的，主要回收废弃常量和无用的类。即使满足回收条件也不一定真得回收。主要性价比太低

1. 废弃常量

比如字符串常量，没有对象引用即可回收

常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

1. 无用的类（需要同时满足3个条件）

该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。

该类对应的java.lang.Class对象在任何地方没有被引用，也无法通过反射访问该类的方法。

在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

## 3.2 回收收集算法

- 标记-清除算法（Mark-Sweep）

1. 概念

最基本的算法，主要分为标记和清除2个阶段。首先标记出所有需要回收的对象，在标记完成后统一回 收掉所有被标记的对象

1. 缺点
   1. 效率不高，标记和清除过程的效率都不高
   2. 空间碎片，会产生大量不连续的内存碎片，会导致大对象可能无法分配，提前触发GC 。

- 复制回收算法（Copying）

1. 概念

为解决效率。它将可用内存按容量划分为相等的两块，每次只使用其中的一块。当这一块的内存用完 了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

1. 回收新生代

现在商业虚拟机都是采用这种收集算法来回收新生代，当回收时，将Eden和Survivor中还存活着的对 象拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。

HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个新 生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当Survivor空间不够用时，需要依 赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

- 标记-整理算法（Mark-Compact）

老年代没有人担保，不能用复制回收算法。可以用标记-整理算法，标记过程仍然与“标记-清除”算法一样，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

##### 3.2.4 分代回收算法（Generational Collection）

当前商业虚拟机都是采用这种算法。根据对象的存活周期的不同将内存划分为几块。 新生代，每次垃圾回收都有大量对象失去，选择复制算法。

老年代，对象存活率高，无人进行分配担保，就必须采用标记清除或者标记整理算法

内存分配担保

在现实社会中，借款会指定担保人，就是当借款人还不起钱，就由担保人来还钱。

在JVM的内存分配时，也有这样的内存分配担保机制。就是当在新生代无法分配内存的时候，把新生代的对象转移到老生代，然后把新对象放入腾空的新生代。

现在假设，我们的新生代分为三个区域，分别为eden space，from space和to space。现在是尝试分配三个2MB的对象和一个4MB的对象，然后我们通过JVM参数

然后我们通过-XX：SurvivorRatio=8 来分配新生代各区的比例，设置为8，表示eden与一个survivor 区的空间比例为8:1。

图1 新生代内存

分配

客户端内存担保

JVM参数配置：

这里我们先手动指定垃圾收集器为客户端模式下的Serial+Serial Old的收集器组合进行内存回收。

由于不同的收集器的收集机制不同，为了呈现出内存分配的担保效果，我们这里需要手动指定为Serial+Serial Old模式。

另外担保机制在JDK1.5以及之前版本中默认是关闭的，需要通过HandlePromotionFailure手动指定，JDK1.6之后就默认开启。这里我们使用的是JDK1.8，所以不用再手动去开启担保机制。

下面我们新建四个byte数组，前三个分别为2MB大小的内存分配，第四个是4MB的内存分配。代码如 下：

然后运行程序，看看GC日志：

[GC (Allocation Failure) [DefNew: 7836K->472K(9216K), 0.0120087 secs] 7836K-

> 6616K(19456K), 0.0123203 secs] [Times: user=0.01 sys=0.01, real=0.01 secs]

通过GC日志我们发现在分配allocation4的时候，发生了一次Minor GC，让新生代从7836K变为了472K，但是你发现整个堆的占用并没有多少变化。这是因为前面三个2MB的对象都还存活着，所以回收 器并没有找到可回收的对象。但为什么会出现这次GC呢？

图2 正常流程把前三个对象放入了新生代Eden区

如果你算一笔账就知道了，前面三个对象2MB+2MB+2MB=6MB。

虚拟机分配内存优先会分配到新生代的eden space，通过图1我们知道新生代可用内存一共只有9216KB，现在新生代已经被用去了6MB，还剩下9216KB-6144KB=3072KB，然而第四个对象是4MB，显然在新生代已经装不下了。

图3 第四个对象此时无法放入Eden区

于是发生了一次Minor GC！

而且本次GC期间，虚拟机发现eden space的三个对象（6MB）又无法全部放入Survivor空间(Survivor可用内存只有1MB)。

这时候该怎么办呢？第四个对象还要不要分配呢？

此时，JVM就启动了内存分配的担保机制，把这6MB的三个对象直接转移到了老年代。

此时就把新生代的空间腾出来了，然后把第四个对象（4MB）放入了Eden区中，所以你看到的结果是4096/8192=0.5，也就是约50%：

eden space 8192K, 52% used [0x00000007bec00000, 0x00000007bf0290f0, 0x00000007bf400000)

老年代则被占用了6MB，也就是前三个对象，102423=6144KB，6144KB/10240KB=0.6也就是60%：

the space 10240K, 60% used [0x00000007bf600000, 0x00000007bfc00030, 0x00000007bfc00200, 0x00000007c0000000)

图4：担保后，allocation4放入到新生代eden区

图5：担保后，之前在新生代的三个对象转移到了老生代

服务端模式下的担保机制实现**

上面我们演示的在客户端模式（Serial+Serial Old）的场景下的结果，接下来我们使用服务端模式

（Parallel Scavenge+Serial Old的组合）来看看担保机制的实现。

修改GC组合为：-XX:+UseParallelGC 然后我们运行程序看看GC日志。

第四个对象是4MB的情况下：

[GC (Allocation Failure) [PSYoungGen: 6156K->592K(9216K)] 6156K->4696K(19456K),

0.0032059 secs] [Times: user=0.01 sys=0.01, real=0.01 secs]

Heap

PSYoungGen total 9216K, used 7057K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)

eden space 8192K, 78% used [0x00000007bf600000,0x00000007bfc505f8,0x00000007bfe00000)

from space 1024K, 57% used [0x00000007bfe00000,0x00000007bfe94010,0x00000007bff00000)

to space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)

ParOldGen total 10240K, used 4104K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)

object space 10240K, 40% used [0x00000007bec00000,0x00000007bf002020,0x00000007bf600000)

Metaspace used 3299K, capacity 4494K, committed 4864K, reserved 1056768K class space used 357K, capacity 386K, committed 512K, reserved 1048576K

第四个对象是3MB的情况下：

[GC (Allocation Failure) [PSYoungGen: 8192K->544K(9216K)] 8192K->6688K(19456K),

0.0052943 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]

[Full GC (Ergonomics) [PSYoungGen: 544K->0K(9216K)] [ParOldGen: 6144K-

> 6627K(10240K)] 6688K->6627K(19456K), [Metaspace: 3286K->3286K(1056768K)],

0.0063048 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]

Heap

PSYoungGen total 9216K, used 3238K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)

eden space 8192K, 39% used [0x00000007bf600000,0x00000007bf929918,0x00000007bfe00000)

from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)

to space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)

ParOldGen total 10240K, used 6627K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)

object space 10240K, 64% used [0x00000007bec00000,0x00000007bf278f70,0x00000007bf600000)

Metaspace used 3294K, capacity 4494K, committed 4864K, reserved 1056768K class space used 356K, capacity 386K, committed 512K, reserved 1048576K

发现当我们使用Server模式下的ParallelGC收集器组合（Parallel Scavenge+Serial Old的组合）下，担保机制的实现和之前的Client模式下（SerialGC收集器组合）有所变化。在GC前还会进行一次判断，如果要分配的内存>=Eden区大小的一半，那么会直接把要分配的内存放入老年代中。否则才 会进入担保机制。

这里我们的第四个对象是4MB的时候，也就是(1024KB*4)/8192KB=0.5，刚好一半，于是就这第四个对 象分配到了老年代。

第二次，我们把第四个对象由4MB，改为3MB，此时3MB/8192KB=0.37，显然不到一半，此时发现3MB还 是无法放入，那么就执行担保机制，把前三个对象转移到老生代，然后把第四个对象（3MB）放入eden 区。

总结

内存分配是在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新 生代腾出来的空间用于为分配给最新的对象。这里老生代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。在Serial+Serial Old的情况下，发现放不下就直接启动担保机制；在Parallel Scavenge+Serial Old的情况下，却是先要去判断一下要分配的内存是不是

> =Eden区大小的一半，如果是那么直接把该对象放入老生代，否则才会启动担保机制。

## 垃圾回收器

1. 概念

垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现，不 同种类JVM所提供的垃圾收集器可能会有很大差别，HotSpot虚拟机中的7种垃圾收集器：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1

- 垃圾收集器组合

分类

新生代收集器：Serial、ParNew、Parallel Scavenge；

老年代收集器：Serial Old、Parallel Old、CMS；

整堆收集器：G1； 搭配使用

两个收集器间有连线，表明它们可以搭配使用：

Serial/Serial Old Serial/CMS ParNew/Serial Old ParNew/CMS

Parallel Scavenge/Serial Old Parallel Scavenge/Parallel Old G1

1. 并发垃圾收集和并行垃圾收集的区别并行（Parallel）

指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；

如ParNew、Parallel Scavenge、Parallel Old； 并发（Concurrent）

指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）

用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上； 如CMS、G1（也有并行）；

1. Minor GC、Major GC和Full GC之间的区别

Minor GC

新生代GC（包括 Eden 和 Survivor 区域），Minor GC非常频繁，回收速度也比较快当年轻代满时会触发Minor GC，这里年轻代满指的是Eden代满，Survivor满不会引发GC

Major GC

老年代GC

Major GC速度一般比Minor GC慢10倍以上；

Full GC

Minor GC+Major GC，清理整个堆空间—包括年轻代和永久代

1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 年轻代需要把该对象转存到老年代，且老年代的可用内存小于该对象大小

http://www.importnew.com/15820.html

https://blog.csdn.net/tjiyu/article/details/53983650

- Serial收集器

Serial（串行）垃圾收集器是最基本、发展历史最悠久的收集器；

JDK1.3.1前是HotSpot新生代收集的唯一选择；

1. 特点

采用复制算法单线程收集

Stop The World 进行垃圾收集时，必须暂停所有工作线程，直到完成；

Serial/Serial Old组合收集器运行示意图如下：

1. 应用场景

依然是HotSpot在Client模式下默认的新生代收集器； 也有优于其他收集器的地方：

简单高效（与其他收集器的单线程相比）；

对单个CPU环境，Serial收集器没有线程切换开销，可获得最高的单线程收集效率；

在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS），只要不频繁发生，这是可以接受的。

1. 设置参数

"-XX:+UseSerialGC"：添加该参数来显式的使用串行垃圾收集器；

1. Stop TheWorld说明

JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，即GC停顿；

从JDK1.3到现在，从Serial收集器-》Parallel收集器-》CMS-》G1，用户线程停顿时间不断缩短， 但仍然无法完全消除；

- ParNew收集器

ParNew垃圾收集器是Serial收集器的多线程版本。

1. 特点

除了多线程外，其余的行为、特点和Serial收集器一样

如Serial收集器可用控制参数、收集算法、Stop The World、内存分配规则、回收策略等；两个收集器共用了不少代码；

[ParNew/Serial Old组合](http://parnew/Serial Old组合)收集器运行示意图如下：

1. 应用场景

在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收 集器配合工作；

但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。

1. 设置参数

"-XX:+UseConcMarkSweepGC"：指定使用CMS后，会默认使用ParNew作为新生代收集器"-XX:+UseParNewGC"：强制指定使用ParNew

"-XX:ParallelGCThreads"：指定垃圾收集线程数量，默认收集线程与CPU数量相同

1. 为什么只有ParNew能与CMS收集器配合 CMS是HotSpot在JDK1.5第一款并发收集器，让垃圾收集线程与用户线程（基本上）同时工作； CMS作为老年代收集器，但无法与JDK1.4新生代收集器Parallel Scavenge配合工作；

因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的框架代码；

##### 3.2.7 Parallel Scavenge收集器

因为与吞吐量关系密切，也称为吞吐量收集器（Throughput Collector）。

1. 特点
2. 有一些特点与ParNew收集器相似新生代收集器

采用复制算法多线程收集

b.主要特点是：它的关注点与其他收集器不同

CMS等收集器的关注点是缩短垃圾收集时用户线程的停顿时间；

而Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput）

1. 应用场景

提高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间适用于多CPU，对停顿时间没特别要求的后台统计等运算任务

1. 设置参数

Parallel Scavenge收集器提供两个参数用于精确控制吞吐量： a "-XX:MaxGCPauseMillis"

控制最大垃圾收集停顿时间，大于0的毫秒数；

如果值过小，停顿时间会缩短，但是垃圾收集次数会更频繁，使吞吐量下降； b "-XX:GCTimeRatio"

设置垃圾收集时间占总时间的比率，0<n<100的整数；相当于设置吞吐量大小；

垃圾收集时间占应用执行时间的比例算法：1 / (1 + n)。默认值是1%--1/(1+99)，即n=99； 垃圾收集所花费的时间是年轻一代和老年代收集的总时间；

如果没有满足吞吐量目标，则增加代的内存大小以尽量增加用户程序运行的时间；

1. "-XX:+UseAdptiveSizePolicy"

开启这个参数后，就不用手工指定一些细节参数，如：

新生代的大小(-Xmn). Eden与Survivor区的比例(-XX:SurvivorRation). 晋升老年代的对象年龄(-XX:PretenureSizeThreshold）等；

JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略(GC Ergonomiscs）；

这是一种值得推荐的方式：

- 只需设置好内存数据大小(如"-Xmx"设置最大堆）；
- 然后使用"-XX:MaxGCPauseMillis"或"-XX:GCTimeRatio"给JVM设置一个优化目标；
- 那些具体细节参数的调节就由JVM自适应完成；

这也是Parallel Scavenge收集器与ParNew收集器一个重要区别

1. 吞吐量与收集器关注点说明
2. 吞 吐 量 (Throughput） CPU用于运行用户代码的时间与CPU总消耗时间的比值；

即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间）；

高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间；

1. 垃圾收集器期望的目标(关注点）

\1. 停顿时间

停顿时间越短就适合需要与用户交互的程序； 良好的响应速度能提升用户体验；

\2. 吞吐量

高吞吐量则可以高效率地利用CPU时间，尽快完成运算的任务； 主要适合在后台计算而不需要太多交互的任务；

\3. 覆盖区(Footprint）

在达到前面两个目标的情况下，尽量减少堆的内存空间； 可以获得更好的空间局部性；

- Serial Old收集器

Serial Old是 Serial收集器的老年代版本；

1. 特点

针对老年代；

采用"标记-整理"算法(还有压缩，Mark-Sweep-Compact）； 单线程收集；

Serial/Serial Old收集器运行示意图如下：

1. 应用场景

主要用于Client模式；

而在Server模式有两大用途：

1. 在JDK1.5及之前，与Parallel Scavenge收集器搭配使用(JDK1.6有Parallel Old收集器可搭配）
   1. 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用(后面详解）； 更多Serial Old收集器信息请参考：

[内存管理白皮书 4.3.2节：http://www.oracle.com/technetwork/java/javase/tech/memoryman agement-whitepaper-1-150020.pdf](http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)

##### 3.2.9 Parallel Old收集器

Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本； JDK1.6中才开始提供；

1. 特点

针对老年代；

采用"标记-整理"算法；

多线程收集；

Parallel Scavenge/Parallel Old收集器运行示意图如下：

1. 应用场景

JDK1.6及之后用来代替老年代的Serial Old收集器； 特别是在Server模式，多CPU的情况下；

在注重吞吐量以及CPU资源敏感场景，就有Parallel Scavenge加Parallel Old收集器"给力"组合

1. 设置参数

"-XX:+UseParallelOldGC"：指定使用Parallel Old收集器； 更多Parallel Old收集器收集过程介绍请参考：

[《内存管理白皮书》 4.5.2节：http://www.oracle.com/technetwork/java/javase/tech/memor ymanagement-whitepaper-1-150020.pdf](http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)

- CMS收集器

并发标记清理(Concurrent Mark Sweep，CMS)收集器也称为并发低停顿收集器(Concurrent Low Pause Collector)或低延迟(low-latency)垃圾收集器；

1. 特点

针对老年代；

基于"标记-清除"算法(不进行压缩操作，产生内存碎片)； 以获取最短回收停顿时间为目标；

并发收集、低停顿；

需要更多的内存(看后面的缺点)；

是HotSpot在JDK1.5推出的第一款真正意义上的并发(Concurrent)收集器； 第一次实现了让垃圾收集线程与用户线程(基本上)同时工作；

1. 应用场景

与用户交互较多的场景；希望系统停顿时间最短，注重服务的响应速度；

以给用户带来较好的体验；如常见WEB、B/S系统的服务器上的应用；

1. 设置参数

"-XX:+UseConcMarkSweepGC"：指定使用CMS收集器；

1. CMS收集器运作过程，可以分为4个步骤:
   - 初始标记(CMS initial mark)

仅标记一下GC Roots能直接关联到的对象； 速度很快；但需要"Stop The World"；

- 并发标记(CMS concurrent mark) 进行GC Roots Tracing的过程；

刚才产生的集合中标记出存活对象； 应用程序也在运行；

并不能保证可以标记出所有的存活对象；

- 重新标记(CMS remark)

为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录； 需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短；

采用多线程并行执行来提升效率； (D). 并发清除(CMS concurrent sweep)

回收所有的垃圾对象；

整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作； 所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行； CMS收集器运行示意图如下：

1. CMS收集器3个明显的缺点
   1. 对CPU资源非常敏感

并发收集虽不暂停用户线程，但会占用部分CPU资源，导致应用程序变慢，总吞吐量降低。CMS的默认收集线程数量是=(CPU数量+3)/4；

当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个 时，影响更大，可能无法接受。

增量式并发收集器：(Incremental Concurrent Mark Sweep/i-CMS) 针对这种情况，曾出现了"增量式并发收集器"

类似使用抢占式来模拟多任务机制7的思想，让收集线程和用户线程交替运行，减少收集线 程运行时间；但效果并不理想，JDK1.6后就官方不再提倡用户使用。更多请参考：

[官方的《垃圾收集调优指南》8.8节 Incremental Mode：http://docs.oracle.com/ja vase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ)

《内存管理白皮书》 4.6.3节可以看到一些描述；

1. 无法处理浮动垃圾，可能出现"Concurrent Mode Failure"失败
2. 浮动垃圾(Floating Garbage)

在并发清除时，用户线程新产生的垃圾，称为浮动垃圾；

这使得并发清除时需预留一定空间，不能像其他收集器在老年代快满再进行收集； 也要可以认为CMS所需要的空间比其他垃圾收集器大；

"-XX:CMSInitiatingOccupancyFraction"： 设 置 CMS 预 留 内 存 空 间 ； JDK1.5默认值为68%；

JDK1.6变为大约92%；

\2. "Concurrent Mode Failure" 失 败

如CMS预留空间无法满足需求，就会出现一次"Concurrent Mode Failure"失败；

这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生； 这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大。

1. 产生大量内存碎片

由于CMS基于"标记-清除"算法，清除后不进行压缩操作；

前面《Java虚拟机垃圾回收(二) 垃圾回收算法》"标记-清除"算法介绍时曾说过：

产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提 前触发另一次Full GC动作。

解决方法：

(1). "-XX:+UseCMSCompactAtFullCollection"

使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程； 但合并整理过程无法并发，停顿时间会变长；

默认开启(但不会进行，结合下面的CMSFullGCsBeforeCompaction)； (2). "-XX:+CMSFullGCsBeforeCompaction"

设置执行多少次不压缩的Full GC后，来一次压缩整理； 为减少合并整理过程的停顿时间；

默认为0，也就是说每次都执行Full GC，不会进行压缩整理；

由于空间不再连续，CMS需要使用可用"空闲列表"内存分配方式，这比简单实用"碰撞指针"分 配内存消耗大；

更多关于内存分配方式请参考：《Java对象在Java虚拟机中的创建过程》

总体来看，与Parallel Old垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间；

但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间； 更多CMS收集器信息请参考：

[《垃圾收集调优指南》 8节 Concurrent Mark Sweep (CMS) Collector：http://docs.o racle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_ma rk_sweep_cms_collector](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector)

[《内存管理白皮书》 4.6节 Concurrent Mark-Sweep (CMS) Collector：http://www.or acle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020. pdf](http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)

- G1收集器

G1(Garbage-First)是JDK7-u4才推出商用的收集器；

1. 特点
   1. 并行与并发

能充分利用多CPU、多核环境下的硬件优势； 可以并行来缩短"Stop The World"停顿时间；也可以并发让垃圾收集与用户程序同时进行；

1. 分代收集，收集范围包括新生代和老年代

能独立管理整个GC堆(新生代和老年代)，而不需要与其他收集器搭配； 能够采用不同方式处理不同时期的对象；

虽然保留分代概念，但Java堆的内存布局有很大差别；

将整个堆划分为多个大小相等的独立区域(Region)；

新生代和老年代不再是物理隔离，它们都是一部分Region(不需要连续)的集合； 更多G1内存布局信息请参考：

[《垃圾收集调优指南》 9节：http://docs.oracle.com/javase/8/docs/technotes/guides/vm/g ctuning/g1_gc.html#garbage_first_garbage_collection](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection)

1. 结合多种垃圾收集算法，空间整合，不产生碎片从整体看，是基于标记-整理算法；

从局部(两个Region间)看，是基于复制算法；

这是一种类似火车算法的实现；

都不会产生内存碎片，有利于长时间运行；

1. 可预测的停顿：低停顿的同时实现高吞吐量

G1除了追求低停顿处，还能建立可预测的停顿时间模型；

可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒；

1. 应用场景

面向服务端应用，针对具有大内存、多处理器的机器；

最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案； 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；

用来替换掉JDK1.5中的CMS收集器；

在下面的情况时，使用G1可能比CMS好： (1). 超过50％的Java堆被活动数据占用；

- 对象分配频率或年代提升频率变化很大；
  - GC停顿时间过长(长于5至1秒)。是否一定采用G1呢？也未必：

如果现在采用的收集器没有出现问题，不用急着去选择G1； 如果应用程序追求低停顿，可以尝试选择G1；

是否代替CMS需要实际场景测试才知道。

1. 设置参数

"-XX:+UseG1GC"：指定使用G1收集器；

"-XX:InitiatingHeapOccupancyPercent"：当整个Java堆的占用率达到参数值时，开始并发 标记阶段；默认为45；

"-XX:MaxGCPauseMillis"：为G1设置暂停时间目标，默认值为200毫秒； "-XX:

HeapRegionSize"：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region；

更多关于G1参数设置请参考：

[《垃圾收集调优指南》 10.5节：http://docs.oracle.com/javase/8/docs/technotes/gui des/vm/gctuning/g1_gc_tuning.html#important_defaults](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#important_defaults)

1. 为什么G1收集器可以实现可预测的停顿

G1可以建立可预测的停顿时间模型，是因为：

可以有计划地避免在Java堆的进行全区域的垃圾收集； G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表；

每次根据允许的收集时间，优先回收价值最大的Region(名称Garbage-First的由来)； 这就保证了在有限的时间内可以获取尽可能高的收集效率；

1. 一个对象被不同区域引用的问题

一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对 象存活时，是否需要扫描整个Java堆才能保证准确？

在其他的分代收集器，也存在这样的问题(而G1更突出)： 回收新生代也不得不同时扫描老年代？

这样的话会降低Minor GC的效率；

解决方法：

无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描： 每个Region都有一个对应的Remembered Set；

每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；

然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集 器：检查老年代对象是否引用了新生代对象)；

如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；

当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set； 就可以保证不进行全局扫描，也不会有遗漏。

1. G1收集器运作过程

不计算维护Remembered Set的操作，可以分为4个步骤(与CMS较为相似)。(A). 初始标记(Initial Marking)

仅标记一下GC Roots能直接关联到的对象；

且修改TAMS(Next Top at Mark Start)，让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象；

需要"Stop The World"，但速度很快； (B). 并发标记(Concurrent Marking) 进行GC Roots Tracing的过程；

刚才产生的集合中标记出存活对象； 耗时较长，但应用程序也在运行；

并不能保证可以标记出所有的存活对象； (C). 最终标记(Final Marking)

为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录； 上一阶段对象的变化记录在线程的Remembered Set Log；

这里把Remembered Set Log合并到Remembered Set中；

需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短；采用多线程并行执行来提升效率；

(D). 筛选回收(Live Data Counting and Evacuation) 首先排序各个Region的回收价值和成本；

然后根据用户期望的GC停顿时间来制定回收计划； 最后按计划回收一些价值高的Region中垃圾对象；

回收时采用"复制"算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在 此过程中压缩和释放内存；

可以并发进行，降低停顿时间，并增加吞吐量；

# 七、GC日志

## 启用GC日志

在JDK 8中， -verbose:gc 是-XX:+PrintGC 一个别称，日志格式等价与： -XX:+PrintGC 。不过在JDK 9 中 -XX:+PrintGC 被标记为deprecated 。

## 参数详解

-XX:+PrintGC

参数-XX:+PrintGC （或者-verbose:gc ）开启了简单GC日志模式，为每一次新生代（young generation）的GC和每一次的Full GC打印一行信息。下面举例说明：

-XX:+PrintGCDetails

开启了详细GC日志模式。在这种模式下，日志格式和所使用的GC算法有关。

-XX:+PrintGCTimeStamps和-XX:+PrintGCDateStamps

使用-XX:+PrintGCTimeStamps 可以将时间和日期也加到GC日志中。表示自JVM启动至今的时间戳会被添加到每一行中。例子如下：

如果指定了-XX:+PrintGCDateStamps ，每一行就添加上了绝对的日期和时间。

如果需要也可以同时使用两个参数。推荐同时使用这两个参数，因为这样在关联不同来源的GC日志时很有帮助。

-Xloggc

缺省的GC日志时输出到终端的，使用-Xloggc:也可以输出到指定的文件。需要注意这个参数隐式的设置了参数-XX:+PrintGC 和-XX:+PrintGCTimeStamps ，但为了以防在新版本的JVM中有任何变化，我仍建议显示的设置这些参数。

## gc日志

## fullGC日志

## 生产机GC日志

cms垃圾回收：

- Java HotSpot(TM) 64-Bit Server VM (161-b12) for linux-amd64 JRE (1.8.0_161-b12)， built on Dec 19 2017 16:12:43 by "java_re" with gcc 4.3.0 20080428 (Red Hat 4.3.0-8)
- Memory: 4k page， physical 24522532k(13970636k free)， swap 25165820k(25107560k free)

3

4

5 CommandLine flags: -XX:+CMSClassUnloadingEnabled - XX:CMSFullGCsBeforeCompaction=0 -XX:CMSInitiatingOccupancyFraction=70 - XX:+CMSParallelRemarkEnabled -XX:InitialHeapSize=12884901888 - XX:+ManagementServer -XX:MaxHeapSize=12884901888 -XX:MaxNewSize=4831838208

-XX:MaxTenuringThreshold=15 -XX:NewSize=4831838208 -XX:OldPLABSize=16 - XX:ParallelGCThreads=16 -XX:+PrintClassHistogram -XX:+PrintGC - XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SoftRefLRUPolicyMSPerMB=0 - XX:SurvivorRatio=8 -XX:ThreadStackSize=512 -XX:-TraceClassUnloading - XX:+UseCMSCompactAtFullCollection -XX:+UseCompressedClassPointers - XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC

6

7

8

9 2.797: [Full GC (System.gc()) 2.797: [CMS: 0K->26502K(7864320K)， 0.1283532 secs] 1509991K->26502K(12111104K)， [Metaspace: 16421K->16421K(1064960K)]，

0.1318161 secs] [Times: user=0.21 sys=0.03， real=0.13 secs]

- 927: [GC (CMS Initial Mark) [1 CMS-initial-mark: 26502K(7864320K)] 2826906K(12111104K)， 0.1008474 secs] [Times: user=0.78 sys=0.02， real=0.10 secs]

11 11.028: [CMS-concurrent-mark-start]

12 11.052: [CMS-concurrent-mark: 0.024/0.024 secs] [Times: user=0.17 sys=0.04， real=0.03 secs]

13 11.052: [CMS-concurrent-preclean-start]

- 091: [CMS-concurrent-preclean: 0.038/0.039 secs] [Times: user=0.18 sys=0.02， real=0.03 secs]

15 11.091: [CMS-concurrent-abortable-preclean-start]

- CMS: abort preclean due to time 192: [CMS-concurrent-abortable- preclean: 1.216/5.101 secs] [Times: user=21.61 sys=0.44， real=5.11 secs]

17

16.192: [GC (CMS Final Remark) [YG occupancy: 3356366 K (4246784 K)]16.193:

[Rescan (parallel) ， 0.1116331 secs]16.304: [weak refs processing，

0.0004650 secs]16.305: [class unloading， 0.0205329 secs]16.325: [scrub

symbol table， 0.0073514 secs]16.333: [scrub string table， 0.0012032 secs]

[1 CMS-remark: 26502K(7864320K)] 3382869K(12111104K)， 0.1445932 secs]

[Times: user=1.64 sys=0.02， real=0.14 secs]

18

16.337: [CMS-concurrent-sweep-start]

19

16.354: [CMS-concurrent-sweep: 0.016/0.016 secs] [Times: user=0.02

sys=0.00， real=0.02 secs]

20

16.354: [CMS-concurrent-reset-start]

21

16.394: [CMS-concurrent-reset: 0.040/0.040 secs] [Times: user=0.02

sys=0.03， real=0.04 secs]

22

19.647: [GC (Allocation Failure) 19.647: [ParNew: 3774976K-

> 471807K(4246784K)， 0.3042301 secs] 3792918K->587685K(12111104K)，

0.3043870 secs] [Times: user=0.76 sys=0.85， real=0.30 secs]

23

25.275: [GC (Allocation Failure) 25.275: [ParNew: 4246783K-

> 194499K(4246784K)， 0.5530195 secs] 4362661K->659531K(12111104K)，

0.5531499 secs] [Times: user=2.17 sys=0.31， real=0.55 secs]

24

30.986: [GC (Allocation Failure) 30.986: [ParNew: 3969475K-

> 379153K(4246784K)， 0.0874455 secs] 4434507K->844185K(12111104K)，

0.0875569 secs] [Times: user=1.35 sys=0.01， real=0.09 secs]

25

36.502: [GC (Allocation Failure) 36.503: [ParNew: 4154129K-

> 421214K(4246784K)， 0.2554706 secs] 4619161K->1050402K(12111104K)，

0.2555957 secs] [Times: user=2.50 sys=0.24， real=0.25 secs]

26

42.356: [GC (Allocation Failure) 42.356: [ParNew: 4196190K-

> 376925K(4246784K)， 0.2549377 secs] 4825378K->1156190K(12111104K)，

0.2551341 secs] [Times: user=2.83 sys=0.09， real=0.25 secs]

27

50.611: [GC (CMS Initial Mark) [1 CMS-initial-mark: 779265K(7864320K)]

3364823K(12111104K)， 0.1902959 secs] [Times: user=1.55 sys=0.00， real=0.19

secs]

28

50.801: [CMS-concurrent-mark-start]

29

51.245: [CMS-concurrent-mark: 0.416/0.444 secs] [Times: user=5.57 sys=0.05，

real=0.45 secs]

30

51.246: [CMS-concurrent-preclean-start]

31

51.308: [CMS-concurrent-preclean: 0.057/0.062 secs] [Times: user=0.68

sys=0.02， real=0.06 secs]

32

51.308: [CMS-concurrent-abortable-preclean-start]

33

55.878: [GC (Allocation Failure) 55.878: [ParNew: 4151901K-

> 401091K(4246784K)， 0.3703185 secs] 4931166K->1334098K(12111104K)，

0.3706154 secs] [Times: user=3.03 sys=0.07， real=0.37 secs]

34

CMS: abort preclean due to time 56.728: [CMS-concurrent-abortable-

preclean: 4.699/5.419 secs] [Times: user=57.69 sys=1.36， real=5.42 secs]

35

56.729: [GC (CMS Final Remark) [YG occupancy: 1032905 K (4246784 K)]56.729:

[Rescan (parallel) ， 0.0607694 secs]56.790: [weak refs processing，

0.0004417 secs]56.790: [class unloading， 0.0532731 secs]56.844: [scrub

symbol table， 0.0137044 secs]56.857: [scrub string table， 0.0022564 secs]

[1 CMS-remark: 933006K(7864320K)] 1965912K(12111104K)， 0.1541694 secs]

[Times: user=0.98 sys=0.00， real=0.16 secs]

36

56.884: [CMS-concurrent-sweep-start]

37

57.457: [CMS-concurrent-sweep: 0.548/0.573 secs] [Times: user=4.23

sys=0.08， real=0.57 secs]

38

57.457: [CMS-concurrent-reset-start]

39

57.474: [CMS-concurrent-reset: 0.017/0.017 secs] [Times: user=0.09

sys=0.00， real=0.02 secs]

40

63.127: [GC (Allocation Failure) 63.128: [ParNew: 4176067K-

> 272024K(4246784K)， 0.2231164 secs] 4720340K->949516K(12111104K)，

0.2234353 secs] [Times: user=1.84 sys=0.01， real=0.22 secs]

41

65.346: [GC (Allocation Failure) 65.347: [ParNew: 4047000K-

> 146015K(4246784K)， 0.0494929 secs] 4724492K->823507K(12111104K)，

0.0505688 secs] [Times: user=0.53 sys=0.01， real=0.05 secs]

42

67.243: [GC (Allocation Failure) 67.243: [ParNew: 3920991K-

> 151093K(4246784K)， 0.0632491 secs] 4598483K->828584K(12111104K)，

0.0635686 secs] [Times: user=0.72 sys=0.02， real=0.06 secs]

43

71.833: [GC (Allocation Failure) 71.833: [ParNew: 3926069K-

> 152077K(4246784K)， 0.0563183 secs] 4603560K->829569K(12111104K)，

0.0566875 secs] [Times: user=0.51 sys=0.02， real=0.05 secs]

44

74.190: [GC (Allocation Failure) 74.190: [ParNew: 3927053K-

> 155697K(4246784K)， 0.0509473 secs] 4604545K->833189K(12111104K)，

0.0512858 secs] [Times: user=0.52 sys=0.00， real=0.05 secs]

45

77.148: [GC (Allocation Failure) 77.148: [ParNew: 3930673K-

> 172521K(4246784K)， 0.0567456 secs] 4608165K->850012K(12111104K)，

0.0570627 secs] [Times: user=0.51 sys=0.01， real=0.06 secs]

46

80.006: [GC (Allocation Failure) 80.008: [ParNew: 3947497K-

> 187906K(4246784K)， 0.0576664 secs] 4624988K->865398K(12111104K)，

0.0604121 secs] [Times: user=0.58 sys=0.02， real=0.06 secs]

47

82.766: [GC (Allocation Failure) 82.767: [ParNew: 3962882K-

> 215324K(4246784K)， 0.0650993 secs] 4640374K->892816K(12111104K)，

0.0654341 secs] [Times: user=0.59 sys=0.01， real=0.07 secs]

48

84.956: [GC (Allocation Failure) 84.956: [ParNew: 3990300K-

> 189175K(4246784K)， 0.0722586 secs] 4667792K->866667K(12111104K)，

0.0726157 secs] [Times: user=0.68 sys=0.06， real=0.07 secs]

49

86.734: [GC (Allocation Failure) 86.735: [ParNew: 3964151K-

> 225468K(4246784K)， 0.0596107 secs] 4641643K->902960K(12111104K)，

0.0599598 secs] [Times: user=0.62 sys=0.01， real=0.06 secs]

50

88.138: [GC (Allocation Failure) 88.138: [ParNew: 4000444K-

> 238931K(4246784K)， 0.0709075 secs] 4677936K->916423K(12111104K)，

0.0714342 secs] [Times: user=0.75 sys=0.02， real=0.07 secs]

51

89.686: [GC (Allocation Failure) 89.686: [ParNew: 4013907K-

> 215527K(4246784K)， 0.0666623 secs] 4691399K->893019K(12111104K)，

0.0670266 secs] [Times: user=0.71 sys=0.01， real=0.07 secs]

52

94.888: [GC (Allocation Failure) 94.888: [ParNew: 3990503K-

> 250699K(4246784K)， 0.0794478 secs] 4667995K->928191K(12111104K)，

0.0798372 secs] [Times: user=0.68 sys=0.02， real=0.08 secs]

53

98.643: [GC (Allocation Failure) 98.643: [ParNew: 4025675K-

> 251282K(4246784K)， 0.0817729 secs] 4703167K->928774K(12111104K)，

0.0821377 secs] [Times: user=0.70 sys=0.04， real=0.08 secs]

54

101.366: [GC (Allocation Failure) 101.367: [ParNew: 4026258K-

> 197528K(4246784K)， 0.1618516 secs] 4703750K->940477K(12111104K)，

0.1623082 secs] [Times: user=1.52 sys=0.03， real=0.16 secs]

55

104.010: [GC (Allocation Failure) 104.010: [ParNew: 3972504K-

> 145150K(4246784K)， 0.0602960 secs] 4715453K->894191K(12111104K)，

0.0606576 secs] [Times: user=0.58 sys=0.00， real=0.06 secs]

56

107.555: [GC (Allocation Failure) 107.555: [ParNew: 3920126K-

> 168323K(4246784K)， 0.0602142 secs] 4669167K->922176K(12111104K)，

0.0606687 secs] [Times: user=0.54 sys=0.01， real=0.06 secs]

57

109.891: [GC (Allocation Failure) 109.891: [ParNew: 3943299K-

> 150806K(4246784K)， 0.0463666 secs] 4697152K->909307K(12111104K)，

0.0467131 secs] [Times: user=0.52 sys=0.01， real=0.05 secs]

58

112.004: [GC (Allocation Failure) 112.004: [ParNew: 3925782K-

> 142327K(4246784K)， 0.0449720 secs] 4684283K->904433K(12111104K)，

0.0453117 secs] [Times: user=0.52 sys=0.01， real=0.04 secs]

59

114.460: [GC (GCLocker Initiated GC) 114.460: [ParNew: 3917303K-

> 179128K(4246784K)， 0.0496533 secs] 4679409K->945121K(12111104K)，

0.0500101 secs] [Times: user=0.53 sys=0.02， real=0.05 secs]

60 117.121: [GC (Allocation Failure) 117.121: [ParNew: 3954104K-

> 189639K(4246784K)， 0.0543951 secs] 4720097K->960508K(12111104K)，

0.0547834 secs] [Times: user=0.58 sys=0.01， real=0.06 secs] 61 119.502: [GC (Allocation Failure) 119.502: [ParNew: 3964615K-

> 188848K(4246784K)， 0.0589422 secs] 4735484K->966983K(12111104K)，

0.0592991 secs] [Times: user=0.62 sys=0.01， real=0.05 secs] 62 122.948: [GC (Allocation Failure) 122.948: [ParNew: 3963824K-

> 186785K(4246784K)， 0.0608141 secs] 4741959K->971625K(12111104K)，

0.0612381 secs] [Times: user=0.64 sys=0.03， real=0.06 secs] 63 126.492: [GC (Allocation Failure) 126.492: [ParNew: 3961761K-

> 167700K(4246784K)， 0.0637857 secs] 4746601K->957040K(12111104K)，

0.0641659 secs] [Times: user=0.62 sys=0.01， real=0.06 secs] 64 129.435: [GC (Allocation Failure) 129.435: [ParNew: 3942676K-

> 200601K(4246784K)， 0.0607756 secs] 4732016K->993947K(12111104K)，

0.0611351 secs] [Times: user=0.61 sys=0.00， real=0.06 secs] 65 132.434: [GC (Allocation Failure) 132.434: [ParNew: 3975577K-

> 197187K(4246784K)， 0.0565574 secs] 4768923K->993657K(12111104K)，

0.0569111 secs] [Times: user=0.64 sys=0.01， real=0.05 secs] 66 134.970: [GC (Allocation Failure) 134.970: [ParNew: 3972163K-

> 202072K(4246784K)， 0.0532381 secs] 4768633K->999399K(12111104K)，

0.0536108 secs] [Times: user=0.56 sys=0.00， real=0.06 secs]

67 137.014: [GC (GCLocker Initiated GC) 137.014: [ParNew: 3977081K-

> 176798K(4246784K)， 0.0775254 secs] 4774409K->989775K(12111104K)，

0.0778897 secs] [Times: user=0.69 sys=0.01， real=0.07 secs] 68 139.494: [GC (Allocation Failure) 139.494: [ParNew: 3951774K-

> 174304K(4246784K)， 0.0659993 secs] 4764751K->993307K(12111104K)，

0.0663516 secs] [Times: user=0.63 sys=0.01， real=0.06 secs] 69 141.341: [GC (Allocation Failure) 141.341: [ParNew: 3949280K-

> 153273K(4246784K)， 0.0484796 secs] 4768283K->977967K(12111104K)，

0.0494725 secs] [Times: user=0.55 sys=0.01， real=0.05 secs] 70 143.220: [GC (Allocation Failure) 143.220: [ParNew: 3928249K-

> 178782K(4246784K)， 0.0442161 secs] 4752943K->1006168K(12111104K)，

0.0445422 secs] [Times: user=0.55 sys=0.00， real=0.05 secs] 71 145.352: [GC (Allocation Failure) 145.352: [ParNew: 3953758K-

> 138060K(4246784K)， 0.0544436 secs] 4781144K->974572K(12111104K)，

0.0547979 secs] [Times: user=0.59 sys=0.02， real=0.05 secs] 72 147.367: [GC (Allocation Failure) 147.367: [ParNew: 3913036K-

> 169955K(4246784K)， 0.0532576 secs] 4749548K->1013139K(12111104K)，

0.0536105 secs] [Times: user=0.60 sys=0.00， real=0.05 secs] 73 148.867: [GC (Allocation Failure) 148.867: [ParNew: 3944931K-

> 165887K(4246784K)， 0.0583501 secs] 4788115K->1014362K(12111104K)，

0.0587259 secs] [Times: user=0.64 sys=0.02， real=0.06 secs]

## 具体解释

参考http://ifeve.com/jvm-cms-log/

6

新生代使用 (ParNew 并行)回收器。新生代容量为261952K，GC回收后占用从261760K降到0，耗时

0.2314667秒。(译注：262017K->26386K(1048384K)， 0.2318679 secs 表示整个堆占用从

262017K 降至26386K，费时0.2318679)

7

8

40.146: [GC [1 CMS-initial-mark: 26386K(786432K)] 26404K(1048384K)，

0.0074495 secs]

9

开始使用CMS回收器进行老年代回收。初始标记(CMS-initial-mark)阶段，这个阶段标记由根可以

直接到达的对象，标记期间整个应用线程会暂停。

10

老年代容量为786432K，CMS 回收器在空间占用达到 26386K 时被触发

11

12

40.154: [CMS-concurrent-mark-start]

13

开始并发标记(concurrent-mark-start) 阶段，在第一个阶段被暂停的线程重新开始运行，由前阶

段标记过的对象出发，所有可到达的对象都在本阶段中标记。

14

15

40.683: [CMS-concurrent-mark: 0.521/0.529 secs]

16

并发标记阶段结束，占用 0.521秒CPU时间， 0.529秒墙钟时间(也包含线程让出CPU给其他线程执行

的时间)

17

18

40.683: [CMS-concurrent-preclean-start]

19

开始预清理阶段

20

预清理也是一个并发执行的阶段。在本阶段，会查找前一阶段执行过程中，从新生代晋升或新分配或被

更新的对象。通过并发地重新扫描这些对象，预清理阶段可以减少下一个stop-the-world 重新标记

阶段的工作量。

21

22

40.701: [CMS-concurrent-preclean: 0.017/0.018 secs]

23

预清理阶段费时 0.017秒CPU时间，0.018秒墙钟时间。

24

25

40.704: [GC40.704: [Rescan (parallel) ， 0.1790103 secs]40.883: [weak refs

processing， 0.0100966 secs] [1 CMS-remark: 26386K(786432K)]

52644K(1048384K)， 0.1897792 secs]

26

Stop-the-world 阶段，从根及被其引用对象开始，重新扫描 CMS 堆中残留的更新过的对象。这里

重新扫描费时0.1790103秒，处理弱引用对象费时0.0100966秒，本阶段费时0.1897792 秒。

27

28

40.894: [CMS-concurrent-sweep-start]

29

开始并发清理阶段，在清理阶段，应用线程还在运行。

30

31

41.020: [CMS-concurrent-sweep: 0.126/0.126 secs]

32

并发清理阶段费时0.126秒

33

34

41.020: [CMS-concurrent-reset-start]

35

开始并发重置

36

37

41.147: [CMS-concurrent-reset: 0.127/0.127 secs]

38

在本阶段，重新初始化CMS内部数据结构，以备下一轮 GC 使用。本阶段费时0.127秒

39

这是CMS正常运行周期打印的日志，现在让我们一起看一下其他的CMS日志记录：

40

41

197.976: [GC 197.976: [ParNew: 260872K->260872K(261952K)， 0.0000688

secs]197.976: [CMS197.981: [CMS-concurrent-sweep: 0.516/0.531 secs]

42

(concurrent mode failure): 402978K->248977K(786432K)， 2.3728734 secs]

663850K->248977K(1048384K)， 2.3733725 secs]

43

这段信息显示ParNew 收集器被请求进行新生代的回收，但收集器并没有尝试回收，因为 它 预计在最

糟糕的情况下， CMS 老年代中没有足够的空间容纳新生代的幸存对象。我们把这个失败称之为”完全晋

升担保失败”。

44

因为这样，并发模式的 CMS 被中断同并且在 197.981秒时，Full GC被启动。这次Full GC，采用

标记-清除-整理算法，会发生stop-the-world，费时2.3733725秒。CMS 老年代占用从 402978K

降到248977K。

45

避免并发模式失败， 通过增加老年代空间大小或者设置参数 CMSInitiatingOccupancyFraction

同时设置UseCMSInitiatingOccupancyOnly为true。参数

CMSInitiatingOccupancyFraction 的值必须谨慎选择，设置过低会造成频繁发生 CMS 回收。

46

有时我们发现，当日志中出现晋升失败时，老年代还有足够的空间。这是因为”碎片”，老年代中的可用

空间并不连续，而从新生代晋升上来的对象，需要一块连续的可用空间。CMS 收集器是一种非压缩收集

器，在某种类型的应用中会发生碎片。下面博客中 Jon 详细讨论了如何处理碎片问题：

https://blogs.oracle.com/jonthecollector/entry/when\_the\_sum\_of\_the

47

从JDK 1.5 开始，CMS 收集器中的晋升担保检查策略有些变化。原来的策略是考虑最坏情况，即新生

代所有对象都晋升到老年代 ， 新的晋升担保检查策略基于最近晋升历史情况，这种预计晋升对象比最

坏情况下晋升对象要少很多，因此需要的空间也会少点。如果晋升失败，新生代处于一致状态。触发一

次 stop-the-world 的标记-压缩收集. 如果想在 UseSerialGC 中获得这种功能，需要设置参数

-XX:+HandlePromotionFailure.

48

49

283.736: [Full GC 283.736: [ParNew: 261599K->261599K(261952K)， 0.0000615

secs] 826554K->826554K(1048384K)， 0.0003259 secs]

50

GC locker: Trying a full collection because scavenge failed

51

283.736: [Full GC 283.736: [ParNew: 261599K->261599K(261952K)， 0.0000288

secs]

52

53

当一个JNI 关键区被释放时会发生 Stop-the-world GC。新生代因为晋升担保失败回收失败，触发

一次 Full GC.

54

CMS 可以运行在增量模式下(i-cms)， 使用参数 -XX:+CMSIncrementalMode. 在增量模式下，

CMS 收集器在并发阶段，不会独占整个周期，而会周期性的暂停，唤醒应用线程。收集器把并发阶段工

作，划分为片段，安排在次级(minor) 回收之间运行。这对需要低延迟，运行在少量CPU服务器上的应

用很有用。

55

56

以下是增量模式 CMS的日志.

57

2803.125: [GC 2803.125: [ParNew: 408832K->0K(409216K)， 0.5371950 secs]

611130K->206985K(1048192K) icms_dc=4 ， 0.5373720 secs]

58

2824.209: [GC 2824.209: [ParNew: 408832K->0K(409216K)， 0.6755540 secs]

615806K->211897K(1048192K) icms_dc=4 ， 0.6757740 secs]

59

60

新生代花费 537 毫秒 和 675 毫秒. 在2次收集之间 iCMS 短暂运行期间由icms_dc 表示，

icms_dc 表示运行的占空比。这里占空比为4% .

61

简单计算下， iCMS 增量阶段费时 4/100 * (2824.209 – 2803.125 – 0.537) = 821 毫

秒， 即 2次 GC 间隔时间的 4% .

62

63

在JDK 1.5 中， CMS 增加一个并发可中止预清理(concurrent abortable preclean)阶段.

可中止预清理阶段，运行在并行预清理和重新标记之间，直到获得所期望的eden空间占用率。增加这个

阶段是为了避免在重新标记阶段后紧跟着发生一次垃圾清除。为了尽可能区分开垃圾清除和重新标记 ，

我们尽量安排在两次垃圾清除之间运行重新标记阶段。

64

There is a second reason why we do this. Immediately following a scavenge

there are likely a large number of grey objects that need rescanning. The

abortable preclean phase tries to deal with such newly grey objects thus

reducing a subsequent CMS remark pause.

65

可以通过JVM参数CMSScheduleRemarkEdenSizeThreshold 和

CMSScheduleRemarkEdenPenetration 控制 重新标记阶段。默认值是2m和50%.

CMSScheduleRemarkEdenSizeThreshold 设置Eden区大小，低于此值时不启动重新标记阶段，因

为回报预期为微不足道 CMSScheduleRemarkEdenPenetration 设置启动重新标记阶段时Eden区

的空间占用率。(译注：根据下面描述 Eden 应该是指整个新生代)

66

预清理阶段后，如果Eden 空间占用大于 CMSScheduleRemarkEdenSizeThreshold 设置的值，

会启动可中止预清理，直到占用率达到 CMSScheduleRemarkEdenPenetration 设置的值， 否

则，我们立即安排重新标记阶段.(译注：与上面说的正好相反，不知是不是我翻译有误)

67

68

7688.150: [CMS-concurrent-preclean-start]

69

7688.186: [CMS-concurrent-preclean: 0.034/0.035 secs]

70

7688.186: [CMS-concurrent-abortable-preclean-start]

# JVM优化

## 1、我们为什么要对jvm做优化？

在本地开发环境中我们很少会遇到需要对jvm进行优化的需求，但是到了生产环境，我们可能将有下面 的需求：

运行的应用“卡住了”，日志不输出，程序没有反应服务器的CPU负载突然升高

在多线程应用下，如何分配线程的数量？

……

在本次课程中，我们将对jvm有更深入的学习，我们不仅要让程序能跑起来，而且是可以跑的更快！可 以分析解决在生产环境中所遇到的各种“棘手”的问题。

说明：本套课程使用的jdk版本为1.8。

## 2、jvm的运行参数

在jvm中有很多的参数可以进行设置，这样可以让jvm在各种环境中都能够高效的运行。 绝大部分的参数保持默认即可。

## 、三种参数类型

jvm的参数类型分为三类，分别是： 1、标准参数

-help

-version

2、-X参数 （非标准参数）

-Xint

-Xcomp

3、-XX参数（使用率较高）

-XX:newSize

-XX:+UseSerialGC

### 2.1 、标准参数

#### 2.1.1 、参数介绍

jvm的标准参数，一般都是很稳定的，在未来的JVM版本中不会改变，可以使用java -help 检索出所有的标准参数。

2.1.2 、实战

实战1：查看jvm版本

1

[root@node01 ~]# java -version

2

java version "1.8.0_141"

3

Java(TM) SE Runtime Environment (build 1.8.0_141-b15)

4

Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)

5

6

\# -showversion参数是表示，先打印版本信息，再执行后面的命令，在调试时非常有用， 到

后面会使用

实战2：通过-D设置系统属性参数

进行编译、测试：

2.1.3 、-server与-client参数

可以通过-server或-client设置jvm的运行参数。

它们的区别是Server VM的初始堆空间会大一些，默认使用的是并行垃圾回收器，启动慢运行快。

Client VM相对来讲会保守一些，初始堆空间会小一些，使用串行的垃圾回收器，它的目标是为了让JVM的启动速度更快，但运行速度会比Serverm模式慢些。

JVM在启动的时候会根据硬件和操作系统自动选择使用Server还是Client类型的JVM。 32位操作系统

如果是Windows系统，不论硬件配置如何，都默认使用Client类型的JVM。

如果是其他操作系统上，机器配置有2GB以上的内存同时有2个以上CPU的话默认使用server 模式，否则使用client模式。

64位操作系统

只有server类型，不支持client类型。测试：

- 、-X参数

#### 2.2.1 、参数介绍

jvm的-X参数是非标准参数，在不同版本的jvm中，参数可能会有所不同，可以通过java - X查看非标准参数。

##### 2.2.2 、-Xint、-Xcomp、-Xmixed

在解释模式(interpreted mode)下，-Xint标记会强制JVM执行所有的字节码，当然这会降低运行速度，通常低10倍或更多。

-Xcomp参数与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从 而带来最大程度的优化。

然而，很多应用在使用-Xcomp也会有一些性能损失，当然这比使用-Xint损失的少，原因是- xcomp没有让JVM启用JIT编译器的全部功能。JIT编译器可以对是否需要编译做判断，如果所有代 码都进行编译的话，对于一些只执行一次的代码就没有意义了。

-Xmixed是混合模式，将解释模式与编译模式进行混合使用，由jvm自己决定，这是jvm默认的模 式，也是推荐使用的模式。

示例：强制设置运行模式

- 、-XX参数

-XX参数也是非标准参数，主要用于jvm的调优和debug操作。

-XX参数的使用有2种方式，一种是boolean类型，一种是非boolean类型： boolean类型

格式：-XX:[+-]

如：-XX:+DisableExplicitGC 表示禁用手动调用gc操作，也就是说调用System.gc()无效非boolean类型

格式：-XX:

如：-XX:NewRatio=1 表示新生代和老年代的比值

用法：

- 、-Xms与-Xmx参数

-Xms与-Xmx分别是设置jvm的堆内存的初始大小和最大大小。

-Xmx2048m：等价于-XX:MaxHeapSize，设置JVM最大堆内存为2048M。

-Xms512m：等价于-XX:InitialHeapSize，设置JVM初始堆内存为512M。适当的调整jvm的内存大小，可以充分利用服务器资源，让程序跑的更快。 示例：

## 、查看jvm的运行参数

有些时候我们需要查看jvm的运行参数，这个需求可能会存在2种情况： 第一，运行java命令时打印出运行参数；

第二，查看正在运行的java进程的参数；

2.4.1 、运行java命令时打印参数

运行java命令时打印参数，需要添加-XX:+PrintFlagsFinal参数即可。

17

uintx AdaptiveSizeThroughPutPolicy = 0

18

{product}

19

uintx AdaptiveTimeWeight = 25

20

{product}

21

bool AdjustConcurrency = false

22

{product}

23

bool AggressiveOpts = false

24

{product}

25

intx AliasLevel = 3

26

{C2 product}

27

bool AlignVector = true

28

{C2 product}

29

intx AllocateInstancePrefetchLines = 1

30

{product}

31

intx AllocatePrefetchDistance = 256

32

{product}

33

intx AllocatePrefetchInstr = 0

34

{product}

35

36

…………………………略…………………………………………

37

38

bool UseXmmI2D = false

39

{ARCH product}

40

bool UseXmmI2F = false

41

{ARCH product}

42

bool UseXmmLoadAndClearUpper = true

43

{ARCH product}

44

bool UseXmmRegToRegMoveAll = true

45

{ARCH product}

46

bool VMThreadHintNoPreempt = false

47

{product}

48

intx VMThreadPriority = -1

49

{product}

50

intx VMThreadStackSize = 1024

51

{pd product}

52

intx ValueMapInitialSize = 11

53

{C1 product}

54

intx ValueMapMaxLoopSize = 8

55

{C1 product}

56

intx ValueSearchLimit = 1000

57

{C2 product}

58

bool VerifyMergedCPBytecodes = true

59

{product}

60

bool VerifySharedSpaces = false

61

{product}

62

intx WorkAroundNPTLTimedWaitHang = 1

63

{product}

64

uintx YoungGenerationSizeIncrement = 20

65

{product}

66

uintx YoungGenerationSizeSupplement = 80

67

{product}

68

uintx YoungGenerationSizeSupplementDecay = 8

69

{product}

70

uintx YoungPLABSize = 4096

71

{product}

72

bool ZeroTLAB = false

73

{product}

74

intx hashCode = 5

由上述的信息可以看出，参数有boolean类型和数字类型，值的操作符是=或:=，分别代 表默认值和被修改的值。

示例：

2.4.2 、查看正在运行的jvm参数

如果想要查看正在运行的jvm就需要借助于jinfo命令查看。 首先，启动一个tomcat用于测试，来观察下运行的jvm参数。

访问成功：

# 3、jvm的内存模型

jvm的内存模型在1.7和1.8有较大的区别，虽然本套课程是以1.8为例进行讲解，但是我们也是需要对 1.7的内存模型有所了解，所以接下里，我们将先学习1.7再学习1.8的内存模型。

- 、7的堆内存模型

Young 年轻区（代）

Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中， 某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Eden区间变满的时 候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。

Tenured 年老区

Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定 的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。

Perm 永久区

Perm代主要保存class,method,filed对象，这部份的空间一般不会溢出，除非一次性加载了很 多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了permq中，这种情况下，一般重新启动应用服务器可以解决问题。

Virtual区：

最大内存和初始内存的差值，就是Virtual区。

## 、jdk1.8的堆内存模型

由上图可以看出，jdk1.8的内存模型是由2部分组成，年轻代 + 年老代。年轻代：Eden + 2*Survivor

年老代：OldGen

在jdk1.8中变化最大的Perm区，用Metaspace（元数据空间）进行了替换。

需要特别说明的是：Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存空间中，这也是 与1.7的永久代最大的区别所在。

## 、为什么要废弃1.7中的永久区？

官网给出了解释：http://openjdk.java.net/jeps/122

This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.

移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。

现实使用中，由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError:PermGen。

基于此，将永久区废弃，而改用元空间，改为了使用本地内存空间。

## 、通过jstat命令进行查看堆内存使用情况

jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：

3.1.1 、查看class加载统计

说明：

Loaded：加载class的数量Bytes：所占用空间大小 Unloaded：未加载数量Bytes：未加载占用空间 Time：时间

#### 3.1.2 、查看编译统计

说明：

Compiled：编译数量。Failed： 失 败 数 量 Invalid： 不 可 用 数 量 Time： 时 间 FailedType：失败类型FailedMethod：失败的方法

#### 3.1.3 、垃圾回收统计

说明：

S0C： 第 一 个 Survivor 区 的 大 小 （KB） S1C： 第 二 个 Survivor 区 的 大 小 （KB） S0U：第一个Survivor区的使用大小（KB） S1U：第二个Survivor区的使用大小（KB） EC：Eden 区 的 大 小 （KB） EU：Eden 区 的 使 用 大 小 （KB） OC：Old 区 大 小 （KB） OU：Old 使 用 大 小 （KB） MC： 方 法 区 大 小 （KB） MU： 方 法 区 使 用 大 小 （KB） CCSC： 压 缩 类 空 间 大 小 （KB） CCSU： 压 缩 类 空 间 使 用 大 小 （KB） YGC： 年 轻 代 垃 圾 回 收 次 数 YGCT： 年 轻 代 垃 圾 回 收 消 耗 时 间 FGC： 老 年 代 垃 圾 回 收 次 数 FGCT： 老 年 代 垃 圾 回 收 消 耗 时 间 GCT：垃圾回收消耗总时间

# 4、jmap的使用以及内存溢出分析

前面通过jstat可以对jvm堆的内存进行统计分析，而jmap可以获取到更加详细的内容，如：内存使用情况的汇总、对内存溢出的定位与分析。

## 、查看内存使用情况

## 、查看内存中对象数量及大小

## 、将内存使用情况dump到文件中

有些时候我们需要将jvm当前内存中的情况dump到文件中，然后对它进行分析，jmap也是支持dump到文件中的。

可以看到已经在/tmp下生成了dump.dat的文件。

- 、通过jhat对dump文件进行分析

在上一小节中，我们将jvm的内存dump到文件中，这个文件是一个二进制的文件，不方便查看，这时我 们可以借助于jhat工具进行查看。

\#用法：

\#示例：

打开浏览器进行访问：http://192.168.40.133:9999/

在最后面有OQL查询功能。

- 、通过MAT工具对dump文件进行分析

4.2.1 、MAT工具介绍

MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行 分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报 表直观的查看到可能造成这种结果的对象。

官网地址：https://www.eclipse.org/mat/

#### 4.2.2 、下载安装

下载地址：https://www.eclipse.org/mat/downloads.php

将下载得到的MemoryAnalyzer-1.8.0.20180604-win32.win32.x86_64.zip进行解压：

4.2.3 、使用

查看对象以及它的依赖：

查看可能存在内存泄露的分析：

## 5、实战：内存溢出的定位与分析

内存溢出在实际的生产环境中经常会遇到，比如，不断的将数据写入到一个集合中，出现了死循环，读 取超大的文件等等，都可能会造成内存溢出。

如果出现了内存溢出，首先我们需要定位到发生内存溢出的环节，并且进行分析，是正 常还是非正常情况，如果是正常的需求，就应该考虑加大内存的设置，如果是非正常需求，那么就要对代码进行修 改，修复这个bug。

首先，我们得先学会如何定位问题，然后再进行分析。如何定位问题呢，我们需要借助于jmap与MAT工具进行定位分析。

接下来，我们模拟内存溢出的场景。

### 5.1 、模拟内存溢出

编写代码，向List集合中添加100万个字符串，每个字符串由1000个UUID组成。如果程序能够正常执 行，最后打印ok。

为了演示效果，我们将设置执行的参数，这里使用的是Idea编辑器。

### 5.2 、运行测试

测试结果如下：

可以看到，当发生内存溢出时，会dump文件到java_pid5348.hprof。

- 、导入到MAT工具中进行分析

可以看到，有91.03%的内存由Object[]数组占有，所以比较可疑。

分析：这个可疑是正确的，因为已经有超过90%的内存都被它占有，这是非常有可能出现内存溢出的。查看详情：

可以看到集合中存储了大量的uuid字符串。

6、jstack的使用

有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增高了、出现了死锁、死循环等，我们该如何分析呢？

由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要看下jvm的内部 线程的执行情况，然后再进行分析查找出原因。

这个时候，就需要借助于jstack命令了，jstack的作用是将正在运行的jvm的线程情况进行快照，并且打印出来：

\#用法：jstack

1 [root@node01 bin]# jstack 2203 2

3 Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.141-b15 mixed

mode):

4

5 "Attach Listener" #24 daemon prio=9 os_prio=0 tid=0x00007fabb4001000 6

7 nid=0x906 waiting on condition [0x0000000000000000] 8

9 java.lang.Thread.State: RUNNABLE 10

11 "http-bio-8080-exec-5" #23 daemon prio=5 os_prio=0 tid=0x00007fabb057c000

12

13 nid=0x8e1 waiting on condition [0x00007fabd05b8000] 14

15 java.lang.Thread.State: WAITING (parking) 16

17 at sun.misc.Unsafe.park(Native Method) 18

19 - parking to wait for <0x00000000f8508360> (a

20

21 java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) 22

23 at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) 24

25 at 26

27 java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa 28

29 it(AbstractQueuedSynchronizer.java:2039) 30

31 at 32

33 java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44 34

35 2)

36

37 at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) 38

39 at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) 40

41 at

42

43

java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1

44

45

074)

46

47

at

48

49

java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java

50

51

:1134)

52

53

at

54

55

java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav

56

57

a:624)

58

59

at

60

61

org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread

62

63

.java:61)

64

65

at java.lang.Thread.run(Thread.java:748)

66

67

"http-bio-8080-exec-4" #22 daemon prio=5 os_prio=0 tid=0x00007fab9c113800

68

nid=0x8e0 waiting on condition [0x00007fabd06b9000]

69

70

java.lang.Thread.State: WAITING (parking)

71

72

at sun.misc.Unsafe.park(Native Method)

73

74

\- parking to wait for <0x00000000f8508360> (a

75

76

java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

77

78

at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)

79

80

at

81

82

java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa

83

84

it(AbstractQueuedSynchronizer.java:2039)

85

86

at

87

88

java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44

89

90

2)

91

92

at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)

93

94

at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)

95

96

at

97

98

java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1

99

100

074)

101

102

at

103

104

java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java

105

106

:1134)

107

108

at

109

110

java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav

111

112

a:624)

113

114

at

115

116

org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread

117

118

.java:61)

119

120

at java.lang.Thread.run(Thread.java:748)

121

122

"http-bio-8080-exec-3" #21 daemon prio=5 os_prio=0 tid=0x0000000001aeb800

123

124

nid=0x8df waiting on condition [0x00007fabd09ba000]

125

126

java.lang.Thread.State: WAITING (parking)

127

128

at sun.misc.Unsafe.park(Native Method)

129

130

\- parking to wait for <0x00000000f8508360> (a

131

132

java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

133

134

at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)

135

136

at

137

138

java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa

139

140

it(AbstractQueuedSynchronizer.java:2039)

141

142

at

143

144

java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44

145

146

2)

147

148

at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)

149

150

at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)

151

152

at

153

154

java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1

155

156

074)

157

158

at

159

160

java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java

161

162

:1134)

163

164

at

165

166

java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav

167

168

a:624)

169

170

at

171

172

org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread

173

174

.java:61)

175

176

at java.lang.Thread.run(Thread.java:748)

177

178

"http-bio-8080-exec-2" #20 daemon prio=5 os_prio=0 tid=0x0000000001aea000

179

180

nid=0x8de waiting on condition [0x00007fabd0abb000]

181

182

java.lang.Thread.State: WAITING (parking)

183

184

at sun.misc.Unsafe.park(Native Method)

185

186

\- parking to wait for <0x00000000f8508360> (a

187

188

java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

189

190

at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)

191

192

at

193

194

java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa

195

196

it(AbstractQueuedSynchronizer.java:2039)

197

198

at

199

200

java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44

201

202

2)

203

204

at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)

205

206

at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)

207

208

at

209

210

java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1

211

212

074)

213

214

at

215

216

java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java

217

218

:1134)

219

220

at

221

222

java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav

223

224

a:624)

225

226

at

227

228

org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread

229

230

.java:61)

231

232

at java.lang.Thread.run(Thread.java:748)

233

234

"http-bio-8080-exec-1" #19 daemon prio=5 os_prio=0 tid=0x0000000001ae8800

235

236

nid=0x8dd waiting on condition [0x00007fabd0bbc000]

237

238

java.lang.Thread.State: WAITING (parking)

239

240

at sun.misc.Unsafe.park(Native Method)

241

242

\- parking to wait for <0x00000000f8508360> (a

243

244

java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

245

246

at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)

247

248

at

249

250

java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awa

251

252

it(AbstractQueuedSynchronizer.java:2039)

253

254

at

255

256

java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:44

257

258

2)

259

260

at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)

261

262

at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)

263

264

at

265

266

java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1

267

268

074)

269

270

at

271

272

java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java

273

274

:1134)

275

276

at

277

278

java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.jav

279

280

a:624)

281

282

at

283

284

org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread

285

286

.java:61)

287

288

at java.lang.Thread.run(Thread.java:748)

289

290

"ajp-bio-8009-AsyncTimeout" #17 daemon prio=5 os_prio=0

291

292

tid=0x00007fabe8128000 nid=0x8d0 waiting on condition

293

294

[0x00007fabd0ece000]

295

296

java.lang.Thread.State: TIMED_WAITING (sleeping)

297

298

at java.lang.Thread.sleep(Native Method)

299

300

at

301

302

at

303

304

org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java:

305

306

152)

307

308

at java.lang.Thread.run(Thread.java:748)

309

310

"ajp-bio-8009-Acceptor-0" #16 daemon prio=5 os_prio=0

311

312

tid=0x00007fabe82d4000 nid=0x8cf runnable [0x00007fabd0fcf000]

313

314

java.lang.Thread.State: RUNNABLE

315

316

at java.net.PlainSocketImpl.socketAccept(Native Method)

317

318

at

319

320

java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)

321

322

at java.net.ServerSocket.implAccept(ServerSocket.java:545)

323

324

at java.net.ServerSocket.accept(ServerSocket.java:513)

325

326

at

327

328

org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(Defaul

329

330

tServerSocketFactory.java:60)

331

332

at

333

334

org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)

335

336

at java.lang.Thread.run(Thread.java:748)

337

338

"http-bio-8080-AsyncTimeout" #15 daemon prio=5 os_prio=0

339

340

tid=0x00007fabe82d1800 nid=0x8ce waiting on condition

341

342

[0x00007fabd10d0000]

343

344

java.lang.Thread.State: TIMED_WAITING (sleeping)

345

346

at java.lang.Thread.sleep(Native Method)

347

348

at

349

350

org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java:

351

352

152)

353

354

at java.lang.Thread.run(Thread.java:748)

355

356

"http-bio-8080-Acceptor-0" #14 daemon prio=5 os_prio=0

357

358

tid=0x00007fabe82d0000 nid=0x8cd runnable [0x00007fabd11d1000]

359

360

java.lang.Thread.State: RUNNABLE

361

362

at java.net.PlainSocketImpl.socketAccept(Native Method)

363

364

at

365

366

java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)

367

368

at java.net.ServerSocket.implAccept(ServerSocket.java:545)

369

370

at java.net.ServerSocket.accept(ServerSocket.java:513)

371

372

at

373

374

org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(Defaul

375

376

tServerSocketFactory.java:60)

377

378

at

379

380

org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)

381

382

at java.lang.Thread.run(Thread.java:748)

383

384

"ContainerBackgroundProcessor[StandardEngine[Catalina]]" #13 daemon

385

386

prio=5 os_prio=0 tid=0x00007fabe82ce000 nid=0x8cc waiting on condition

387

388

[0x00007fabd12d2000]

389

390

java.lang.Thread.State: TIMED_WAITING (sleeping)

391

392

at java.lang.Thread.sleep(Native Method)

393

394

at

395

396

org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(C

397

398

ontainerBase.java:1513)

399

400

at java.lang.Thread.run(Thread.java:748)

401

402

"GC Daemon" #10 daemon prio=2 os_prio=0 tid=0x00007fabe83b4000 nid=0x8b3

403

404

in Object.wait() [0x00007fabd1c2f000]

405

406

java.lang.Thread.State: TIMED_WAITING (on object monitor)

407

408

at java.lang.Object.wait(Native Method)

409

410

\- waiting on <0x00000000e315c2d0> (a sun.misc.GC$LatencyLock)

411

412

at sun.misc.GC$Daemon.run(GC.java:117)

413

414

\- locked <0x00000000e315c2d0> (a sun.misc.GC$LatencyLock)

415

416

"Service Thread" #7 daemon prio=9 os_prio=0 tid=0x00007fabe80c3800

417

418

nid=0x8a5 runnable [0x0000000000000000]

419

420

java.lang.Thread.State: RUNNABLE

421

422

"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007fabe80b6800

423

424

nid=0x8a4 waiting on condition [0x0000000000000000]

425

426

java.lang.Thread.State: RUNNABLE

427

428

"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007fabe80b3800

429

430

nid=0x8a3 waiting on condition [0x0000000000000000]

431

432

java.lang.Thread.State: RUNNABLE

433

434

"Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00007fabe80b2000

435

436

nid=0x8a2 runnable [0x0000000000000000]

437

438

java.lang.Thread.State: RUNNABLE

439

440

"Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007fabe807f000 nid=0x8a1

441

442

in Object.wait() [0x00007fabd2a67000]

443

444

java.lang.Thread.State: WAITING (on object monitor)

445

446

at java.lang.Object.wait(Native Method)

447

448

\- waiting on <0x00000000e3162918> (a

449

450

java.lang.ref.ReferenceQueue$Lock)

451

452

at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)

453

454

\- locked <0x00000000e3162918> (a java.lang.ref.ReferenceQueue$Lock)

455

456

at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)

457

458

at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

459

460

"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007fabe807a800

461

462

nid=0x8a0 in Object.wait() [0x00007fabd2b68000]

463

464

java.lang.Thread.State: WAITING (on object monitor)

465

466

at java.lang.Object.wait(Native Method)

467

468

\- waiting on <0x00000000e3162958> (a java.lang.ref.Reference$Lock)

469

470

at java.lang.Object.wait(Object.java:502)

471

472

at java.lang.ref.Reference.tryHandlePending(Reference.java:191)

473

474

\- locked <0x00000000e3162958> (a java.lang.ref.Reference$Lock)

475

476

at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

477

478

"main" #1 prio=5 os_prio=0 tid=0x00007fabe8009000 nid=0x89c runnable

479

480

[0x00007fabed210000]

481

482

java.lang.Thread.State: RUNNABLE

483

484

at java.net.PlainSocketImpl.socketAccept(Native Method)

485

486

at

487

488

java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)

489

490

at java.net.ServerSocket.implAccept(ServerSocket.java:545)

491

492

at java.net.ServerSocket.accept(ServerSocket.java:513)

493

494

at

495

496

org.apache.catalina.core.StandardServer.await(StandardServer.java:453)

497

498

at org.apache.catalina.startup.Catalina.await(Catalina.java:777)

499

500

at org.apache.catalina.startup.Catalina.start(Catalina.java:723)

501

502

at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

503

504

at

505

516

at

java.lang.reflect.Method.invoke(Method.java:498)

517

518

at

org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:321)

519

520

at

org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:455)

521

522

at

org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:455)

523

### 6.1 、线程的状态

在Java中线程的状态一共被分成6种：

初始态（NEW）

创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。运行态（RUNNABLE），在Java中，运行态包括 就绪态 和 运行态。

就绪态

该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。所有就绪态的线程存放在就绪队列中。

运行态

获得CPU执行权，正在执行的线程。

由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。阻塞态（BLOCKED）

当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。而在Java中，阻塞态专指请求锁失败时进入的状态。

由一个阻塞队列存放所有阻塞态的线程。

处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。 等待态（WAITING）

当前线程中调用wait、join、park函数时，当前线程就会进入等待态。

也有一个等待队列存放所有等待态的线程。

线程处于等待态表示它需要等待其他线程的指示才能继续运行。进入等待态的线程会释放CPU执行权，并释放资源（如：锁） 超时等待态（TIMED_WAITING）

当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；

它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒； 进入该状态后释放CPU执行权 和 占有的资源。

与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。终止态（TERMINATED）

线程执行结束后的状态。

- 、实战：死锁问题

如果在生产环境发生了死锁，我们将看到的是部署的程序没有任何反应了，这个时候我们可以借助jstack进行分析，下面我们实战下查找死锁的原因。

#### 6.2.1 、构造死锁

编写代码，启动2个线程，Thread1拿到了obj1锁，准备去拿obj2锁时，obj2已经被Thread2锁定，所以发送了死锁。

36

37

38

39

40

41

42

43

44

45

46

47 }

48

synchronized (obj2){

System.out.println("Thread1 拿到了 obj2 的锁！");

}

}

}

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83 }

private static class Thread2 implements Runnable{

@Override

public void run() {

synchronized (obj2){

System.out.println("Thread2 拿到了 obj2 的锁！"); try {

// 停顿2秒的意义在于，让Thread1线程拿到obj1的锁

Thread.sleep(2000);

} catch (InterruptedException e) {

e.printStackTrace();

}

synchronized (obj1){

System.out.println("Thread2 拿到了 obj1 的锁！");

}

}

}

}

6.2.2 、在linux上运行

5

总用量 28

6

7

-rw-r--r--.

1

root

root

184 9月 11 10:39 TestDeadLock$1.class

8

9

-rw-r--r--.

1

root

root

843 9月 11 10:39 TestDeadLock.class

10

11

-rw-r--r--.

1

root

root

1567

9月

11

10:39

TestDeadLock.java

12

13

-rw-r--r--.

1

root

root

1078

9月

11

10:39

TestDeadLock$Thread1.class

14

15

-rw-r--r--.

1

root

root

1078

9月

11

10:39

TestDeadLock$Thread2.class

16

17

18

19

20

21

22

23

24

25

26

27

-rw-r--r--. 1 root root 573 9月 9 10:21 TestJVM.class

-rw-r--r--. 1 root root 261 9月 9 10:21 TestJVM.java [root@node01 test]# java TestDeadLock

Thread1 拿到了 obj1 的锁！

Thread2 拿到了 obj2 的锁！

\#这里发生了死锁，程序一直将等待下去

6.2.3 、使用jstack进行分析

1

[root@node01 ~]# jstack 3256

2

3

Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.141-b15

mixed

4

5

mode):

6

30

31

at java.lang.Thread.run(Thread.java:748)

32

33

"Thread-0" #8 prio=5 os_prio=0 tid=0x00007f5c2c0e7000 nid=0xcc4 waiting

34

35

for monitor entry [0x00007f5c1c8f7000]

36

37

java.lang.Thread.State: BLOCKED (on object monitor)

38

39

at TestDeadLock$Thread1.run(TestDeadLock.java:27)

40

41

\- waiting to lock <0x00000000f655dc50> (a java.lang.Object)

42

43

\- locked <0x00000000f655dc40> (a java.lang.Object)

44

45

at java.lang.Thread.run(Thread.java:748)

46

47

"Service Thread" #7 daemon prio=9 os_prio=0 tid=0x00007f5c2c0d3000

48

49

nid=0xcc2 runnable [0x0000000000000000]

50

51

java.lang.Thread.State: RUNNABLE

52

53

"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b6000

54

55

nid=0xcc1 waiting on condition [0x0000000000000000]

56

57

java.lang.Thread.State: RUNNABLE

58

59

"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b3000

60

61

nid=0xcc0 waiting on condition [0x0000000000000000]

62

63

java.lang.Thread.State: RUNNABLE

64

65

"Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b1800

66

67

nid=0xcbf runnable [0x0000000000000000]

68

69

java.lang.Thread.State: RUNNABLE

70

71

"Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007f5c2c07e800 nid=0xcbe

72

73

in Object.wait() [0x00007f5c1cdfc000]

74

75

java.lang.Thread.State: WAITING (on object monitor)

76

77

at java.lang.Object.wait(Native Method)

78

79

\- waiting on <0x00000000f6508ec8> (a

80

81

java.lang.ref.ReferenceQueue$Lock)

82

83

at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)

84

85

\- locked <0x00000000f6508ec8> (a java.lang.ref.ReferenceQueue$Lock)

86

87

at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)

88

89

at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

90

91

"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007f5c2c07a000

92

93

nid=0xcbd in Object.wait() [0x00007f5c1cefd000]

94

95

java.lang.Thread.State: WAITING (on object monitor)

96

97

at java.lang.Object.wait(Native Method)

98

99

\- waiting on <0x00000000f6506b68> (a java.lang.ref.Reference$Lock)

100

101

at java.lang.Object.wait(Object.java:502)

102

103

at java.lang.ref.Reference.tryHandlePending(Reference.java:191)

104

105

\- locked <0x00000000f6506b68> (a java.lang.ref.Reference$Lock)

106

107

at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

108

109

"VM Thread" os_prio=0 tid=0x00007f5c2c072800 nid=0xcbc runnable

110

111

"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00007f5c2c01d800

112

113

nid=0xcba runnable

114

115

"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00007f5c2c01f800

116

117

nid=0xcbb runnable

118

119

"VM Periodic Task Thread" os_prio=0 tid=0x00007f5c2c0d6800 nid=0xcc3

120

121

waiting on condition

122

123

JNI global references: 6

124

125

Found one Java-level deadlock:

126

127

=============================

128

129

"Thread-1":

130

131

waiting to lock monitor 0x00007f5c080062c8 (object 0x00000000f655dc40,

132

133

a java.lang.Object),

134

135

which is held by "Thread-0"

136

137

"Thread-0":

138

139

waiting to lock monitor 0x00007f5c08004e28 (object 0x00000000f655dc50,

140

141

a java.lang.Object),

142

143

which is held by "Thread-1"

144

145

Java stack information for the threads listed above:

146

147 ===================================================

148

149 "Thread-1":

150

151 at TestDeadLock$Thread2.run(TestDeadLock.java:47) 152

153 - waiting to lock <0x00000000f655dc40> (a java.lang.Object)

154

155 - locked <0x00000000f655dc50> (a java.lang.Object) 156

157 at java.lang.Thread.run(Thread.java:748) 158

159 "Thread-0":

160

161 at TestDeadLock$Thread1.run(TestDeadLock.java:27) 162

163 - waiting to lock <0x00000000f655dc50> (a java.lang.Object)

164

165 - locked <0x00000000f655dc40> (a java.lang.Object) 166

167 at java.lang.Thread.run(Thread.java:748) 168

169 Found 1 deadlock. 170

171 在输出的信息中，已经看到，发现了1个死锁，关键看这个：

172

173 "Thread-1":

174

175 at TestDeadLock$Thread2.run(TestDeadLock.java:47) 176

177 - waiting to lock <0x00000000f655dc40> (a java.lang.Object)

178

179 - locked <0x00000000f655dc50> (a java.lang.Object) 180

181 at java.lang.Thread.run(Thread.java:748) 182

183 "Thread-0":

184

185 at TestDeadLock$Thread1.run(TestDeadLock.java:27) 186

187 - waiting to lock <0x00000000f655dc50> (a java.lang.Object)

188

189 - locked <0x00000000f655dc40> (a java.lang.Object) 190

191 at java.lang.Thread.run(Thread.java:748)

可以清晰的看到：

Thread2获取了 <0x00000000f655dc50> 的锁，等待获取 <0x00000000f655dc40>这个锁Thread1获取了 <0x00000000f655dc40> 的锁，等待获取 <0x00000000f655dc50>这个锁由此可见，发生了死锁。

# 7、VisualVM工具的使用

VisualVM，能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈(如100个String对象分别由哪几个对象分配出来的)。

VisualVM使用简单，几乎0配置，功能还是比较丰富的，几乎囊括了其它JDK自带命令的所有功能。

内存信息线程信息

Dump堆（本地进程） Dump线程（本地进程）

打开堆Dump。堆Dump可以用jmap来生成。打开线程Dump

生成应用快照（包含内存信息、线程信息等等）

性能分析。CPU分析（各个方法调用时间，检查哪些方法耗时多），内存分析（各类对象占用的内存，检查哪些类占用内存多）

……

## 、启动

在jdk的安装目录的bin目录下，找到jvisualvm.exe，双击打开即可。

## 、查看本地进程

### 、查看CPU、内存、类、线程运行信息

### 

、查看线程详情

也可以点击右上角Dump按钮，将线程的信息导出，其实就是执行的jstack命令。

发现，显示的内容是一样的。

### 、抽样器

抽样器可以对CPU、内存在一段时间内进行抽样，以供分析。

- 、监控远程的jvm

VisualJVM不仅是可以监控本地jvm进程，还可以监控远程的jvm进程，需要借助于JMX技术实现。

7.1.1 、什么是JMX？

JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝 集成的系统、网络和服务管理应用。

7.1.2 、监控远程的tomcat

想要监控远程的tomcat，就需要在远程的tomcat进行对JMX配置，方法如下：

保存退出，重启tomcat。

7.1.3 、使用VisualJVM连接远程tomcat

添加远程主机：

在一个主机下可能会有很多的jvm需要监控，所以接下来要在该主机上添加需要监控的jvm：

连接成功。使用方法和前面就一样了，就可以和监控本地jvm进程一样，监控远程的tomcat进程。

# 垃圾回收

## 1、什么是垃圾回收？

程序的运行必然需要申请内存资源，无效的对象资源如果不及时处理就会一直占有内存资源，最终将导 致内存溢出，所以对内存资源的管理是非常重要了。

- 、C/C++语言的垃圾回收

在C/C++语言中，没有自动垃圾回收机制，是通过new关键字申请内存资源，通过delete关键字释放内 存资源。

如果，程序员在某些位置没有写delete进行释放，那么申请的对象将一直占用内存资源，最终可能会导 致内存溢出。

- 、Java语言的垃圾回收

为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自 动的垃圾回收机制，也就是我们熟悉的GC。

有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。

换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没 有释放，同样也可能会导致内存溢出的。

当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。

## 2、垃圾回收的常见算法

自动化的管理内存资源，垃圾回收机制必须要有一套算法来进行计算，哪些是有效的对象，哪些是无效 的对象，对于无效的对象就要进行回收处理。

常见的垃圾回收算法有：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。

### 2.1 、引用计数法

引用计数是历史最悠久的一种算法，最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用。

2.1.1 、原理

假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收。

2.1.2 、优缺点

优点：

实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以 直接回收。

在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报outofmember 错误。区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。

缺点：

每次对象被引用时，都需要去更新计数器，有一点时间开销。

浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。无法解决循环引用问题。（最大的缺点）

#### 2.1.3 、什么是循环引用

虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。

### 2.2 、标记清除法

标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。标记：从根节点开始标记引用的对象。

清除：未被标记引用的对象就是垃圾对象，可以被清理。

2.2.1 、原理

这张图代表的是程序运行期间所有对象的状态，它们的标志位全部是0（也就是未标记，以下默认0就是 未标记，1为已标记），假设这会儿有效内存空间耗尽了，JVM将会停止应用程序的运行并开启GC线程， 然后开始进行标记工作，按照根搜索算法，标记完以后，对象的状态如下图。

可以看到，按照根搜索算法，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第 一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图 所示。

可以看到，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。 接下来就不用说了，唤醒停止的程序线程，让程序继续运行即可。

2.2.2 、优缺点

可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被 回收。

同样，标记清除算法也是有缺点的：

效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。

通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角 落，所以清理出来的内存是不连贯的。

### 2.3 、标记压缩算法

标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节 点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标 记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。

2.3.1 、原理

2.3.2 、优缺点

优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移 动内存位置的步骤，其效率也有有一定的影响。

### 2.4 、复制算法

复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用 的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。

如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反 之，则不适合。

2.4.1 、JVM中年轻代内存空间

1. 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
2. 紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对 象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-

XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。

1. 经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色， 也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样， 都会保证名为To的Survivor区域是空的。
2. GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年 老代中。

2.4.2 、优缺点

优点：

在垃圾对象多的情况下，效率较高清理后，内存无碎片

缺点：

在垃圾对象少的情况下，不适用，如：老年代内存

分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低

### 2.5 、分代算法

前面介绍了多种回收算法，每一种算法都有自己的优点也有缺点，谁都不能替代谁，所以根据垃圾回收 对象的特点进行选择，才是明智的选择。

分代算法其实就是这样的，根据回收对象的特点进行选择，在jvm中，年轻代适合使用复制算法，老年 代适合使用标记清除或标记压缩算法。

## 3、垃圾收集器以及内存分配

前面我们讲了垃圾回收的算法，还需要有具体的实现，在jvm中，实现了多种垃圾收集器，包括：串行 垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器，接下来，我们一个个的了解学习。

### 3.1 、串行垃圾收集器

串行垃圾收集器，是指使用单线程进行垃圾回收，垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为STW（Stop-The-World）。

对于交互性较强的应用而言，这种垃圾收集器是不能够接受的。一般在Javaweb应用中是不会采用该收集器的。

#### 3.1.1 、编写测试代码

3.1.2 、设置垃圾回收为串行收集器

在程序运行参数中添加2个参数，如下：

-XX:+UseSerialGC

指定年轻代和老年代都使用串行垃圾收集器

-XX:+PrintGCDetails 打印垃圾回收的详细信息

启动程序，可以看到下面信息：

GC日志信息解读：

年轻代的内存GC前后的大小： DefNew

表示使用的是串行垃圾收集器。

4416K->512K(4928K)

表示，年轻代GC前，占有4416K内存，GC后，占有512K内存，总大小4928K 0.0046102 secs

表示，GC所用的时间，单位为毫秒。

4416K->1973K(15872K)

表示，GC前，堆内存占有4416K，GC后，占有1973K，总大小为15872K Full GC

表示，内存空间全部进行GC

### 3.2 、并行垃圾收集器

并行垃圾收集器在串行垃圾收集器的基础之上做了改进，将单线程改为了多线程进行垃圾回收，这样可 以缩短垃圾回收的时间。（这里是指，并行能力较强的机器）

当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并 行执行，速度更快些，暂停的时间更短一些。

3.2.1 、ParNew垃圾收集器

ParNew垃圾收集器是工作在年轻代上的，只是将串行的垃圾收集器改为了并行。

通过-XX:+UseParNewGC参数设置年轻代使用ParNew回收器，老年代使用的依然是串行收集器。测试：

由以上信息可以看出， ParNew: 使用的是ParNew收集器。其他信息和串行收集器一致。

3.2.2 、ParallelGC垃圾收集器

ParallelGC收集器工作机制和ParNewGC收集器一样，只是在此基础之上，新增了两个和系统吞吐量相 关的参数，使得其使用起来更加的灵活和高效。

相关参数如下：

-XX:+UseParallelGC

年轻代使用ParallelGC垃圾回收器，老年代使用串行回收器。

-XX:+UseParallelOldGC

年轻代使用ParallelGC垃圾回收器，老年代使用ParallelOldGC垃圾回收器。

-XX:MaxGCPauseMillis

设置最大的垃圾收集时的停顿时间，单位为毫秒

需要注意的时，ParallelGC为了达到设置的停顿时间，可能会调整堆大小或其他的参数，如果堆 的大小设置的较小，就会导致GC工作变得很频繁，反而可能会影响到性能。

该参数使用需谨慎。

-XX:GCTimeRatio

设置垃圾回收时间占程序运行时间的百分比，公式为1/(1+n)。

它的值为0~100之间的数字，默认值为99，也就是垃圾回收时间不能超过1%

-XX:UseAdaptiveSizePolicy

自适应GC模式，垃圾回收器将自动调整年轻代、老年代等参数，达到吞吐量、堆大小、停顿时间之间的平衡。

一般用于，手动调整参数比较困难的场景，让收集器自动进行调整。测试：

有以上信息可以看出，年轻代和老年代都使用了ParallelGC垃圾回收器。

- 、CMS垃圾收集器

CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，通过参数-XX:+UseConcMarkSweepGC进行设置。

CMS垃圾回收器的执行过程如下：

初始化标记(CMS-initial-mark) ,标记root，会导致stw； 并发标记(CMS-concurrent-mark)，与用户线程同时运行；

预清理（CMS-concurrent-preclean），与用户线程同时运行； 重新标记(CMS-remark) ，会导致stw；

并发清除(CMS-concurrent-sweep)，与用户线程同时运行；

调整堆大小，设置CMS在清理之后进行内存压缩，目的是清理内存中的碎片；

并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；

3.3.1 、测试

由以上日志信息，可以看出CMS执行的过程。

- 、G1垃圾收集器（重点）

G1垃圾收集器是在jdk1.7中正式使用的全新的垃圾收集器，oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。

G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：

1. 第一步，开启G1垃圾收集器
2. 第二步，设置堆的最大内存
3. 第三步，设置最大的停顿时间

G1中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。

3.4.1 、原理

G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分，取而代之 的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。

这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。

在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或 者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。

这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms 内存碎片问题的存在了。

在G1中，有一种特殊的区域，叫Humongous区域。

如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。

这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾 收集器造成负面影响。

为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动 Full GC 。

##### 3.4.2 、 Young GC

Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。

Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋 升 到 年 老 代 空 间 。 Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。

最终Eden空间的数据为空，GC停止工作，应用线程继续执行。

- 、Remembered Set（已记忆集合）

在GC年轻代的对象时，我们如何找到年轻代中对象的根对象呢？

根对象可能是在年轻代中，也可以在老年代中，那么老年代中的所有对象都是根么？ 如果全量扫描老年代，那么这样扫描下来会耗费大量的时间。

于是，G1引进了RSet的概念。它的全称是Remembered Set，其作用是跟踪指向某个堆内的对象引用。

每个Region初始化时，会初始化一个RSet，该集合用来记录并跟踪其它Region指向该Region中对象的 引用，每个Region默认按照512Kb划分成多个Card，所以RSet需要记录的东西应该是 xx Region的xx Card 。

##### 3.4.3 、 Mixed GC

当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC 并不是 Full GC。

MixedGC什么时候触发？ 由参数 -XX:InitiatingHeapOccupancyPercent=n 决定。默认：45%，该参数的意思是：当老年代大小占整个堆大小百分比达到该阀值时触发。

它的GC步骤分2步：

1. 全局并发标记（global concurrent marking）
2. 拷贝存活对象（evacuation）

- 、全局并发标记

全局并发标记，执行过程分为五个步骤：

初始标记（initial mark，STW）

标记从根节点直接可达的对象，这个阶段会执行一次年轻代GC，会产生全局停顿。根区域扫描（root region scan）

G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。

该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。

并发标记（Concurrent Marking）

G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断。

重新标记（Remark，STW）

该阶段是 STW 回收，因为程序在运行，针对上一次的标记进行修正。清除垃圾（Cleanup，STW）

清点和重置标记状态，该阶段会STW，这个阶段并不会实际上去做垃圾的收集，等待evacuation 阶段来回收。

- 、拷贝存活对象

Evacuation阶段是全暂停的。该阶段把一部分Region里的活对象拷贝到另一部分Region中，从而实现 垃圾的回收清理。

3.4.4 、G1收集器相关参数

-XX:+UseG1GC

使用 G1 垃圾收集器

-XX:MaxGCPauseMillis

设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是 200 毫秒。

-XX:G1HeapRegionSize=n

设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。

默认是堆内存的1/2000。

-XX:ParallelGCThreads=n

设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。

-XX:ConcGCThreads=n

设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads)的 1/4 左右。

-XX:InitiatingHeapOccupancyPercent=n

设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。

3.4.5 、测试

6 [GC Worker Start (ms): Min: 14763.7, Avg: 14763.8, Max: 14763.8,

Diff: 0.1]

7

- \#扫描根节点
  - [Ext Root Scanning (ms): Min: 0.2, Avg: 0.3, Max: 0.3, Diff: 0.1, Sum: 0.8]

10

11 #更新RS区域所消耗的时间

12 [Update RS (ms): Min: 1.8, Avg: 1.9, Max: 1.9, Diff: 0.2, Sum: 5.6]

13 [Processed Buffers: Min: 1, Avg: 1.7, Max: 3, Diff: 2, Sum: 5] 14 [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]

15 [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]

16

- \#对象拷贝
- [Object Copy (ms): Min: 1.1, Avg: 1.2, Max: 1.3, Diff: 0.2, Sum: 3.6]
- [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.2]
- [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 3]
  - [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
  - [GC Worker Total (ms): Min: 3.4, Avg: 3.4, Max: 3.5, Diff: 0.1, Sum: 10.3]

23 [GC Worker End (ms): Min: 14767.2, Avg: 14767.2, Max: 14767.3,

Diff: 0.1]

- [Code Root Fixup: 0.0 ms]
- [Code Root Purge: 0.0 ms]
- [Clear CT: 0.0 ms] #清空CardTable
- [Other: 0.7 ms]
  - [Choose CSet: 0.0 ms] #选取CSet
  - [Ref Proc: 0.5 ms] #弱引用、软引用的处理耗时
  - [Ref Enq: 0.0 ms] #弱引用、软引用的入队耗时
  - [Redirty Cards: 0.0 ms]
  - [Humongous Register: 0.0 ms] #大对象区域注册耗时
  - [Humongous Reclaim: 0.0 ms] #大对象区域回收耗时
  - [Free CSet: 0.0 ms]

35 [Eden: 7168.0K(7168.0K)->0.0B(13.0M) Survivors: 2048.0K->2048.0K Heap:

55.5M(192.0M)->48.5M(192.0M)] #年轻代的大小统计

36 [Times: user=0.00 sys=0.00, real=0.00 secs]

3.4.6 、对于G1垃圾收集器优化建议

年轻代大小

避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。

暂停时间目标不要太过严苛

G1 GC 的吞吐量目标是 90% 的应用程序时间和 10%的垃圾回收时间。

评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示您愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量。

4、可视化GC日志分析工具

- 、GC日志输出参数

前面通过-XX:+PrintGCDetails可以对GC日志进行打印，我们就可以在控制台查看，这样虽然可以查 看GC的信息，但是并不直观，可以借助于第三方的GC日志分析工具进行查看。

在日志打印输出涉及到的参数如下：

测试：

运行后就可以在E盘下生成gc.log文件。如下：

1 Java HotSpot(TM) 64-Bit Server VM (25.144-b01) for windows-amd64 JRE (1.8.0_144-b01), built on Jul 21 2017 21:57:33 by "java_re" with MS VC++ 10.0 (VS2010)

2

3 Memory: 4k page, physical 12582392k(1939600k free), swap 17300984k(5567740k free)

4 CommandLine flags: -XX:InitialHeapSize=201318272 -XX:MaxGCPauseMillis=100

-XX:MaxHeapSize=268435456 -XX:+PrintGC -XX:+PrintGCDateStamps

-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC

-XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-

UseLargePagesIndividualAllocation

5

6 {Heap before GC invocations=0 (full 0):

7 garbage-first heap total 196608K, used 9216K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)

- region size 1024K, 9 young (9216K), 0 survivors (0K)
  - Metaspace used 3491K, capacity 4500K, committed 4864K, reserved 1056768K
- class space used 381K, capacity 388K, committed 512K, reserved 1048576K 11

12 2018-09-24T23:06:02.230+0800: 0.379: [GC pause (G1 Evacuation Pause)

(young), 0.0031038 secs]

13

14 [Parallel Time: 2.8 ms, GC Workers: 3]

15 [GC Worker Start (ms): Min: 378.6, Avg: 378.8, Max: 379.0, Diff: 0.3]

16 [Ext Root Scanning (ms): Min: 0.0, Avg: 0.4, Max: 0.8, Diff: 0.8, Sum: 1.3]

17 [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]

18

19

20

0.1]

21

22

23

24

0.6]

25

7.6]

26

27

28

29

30

31

32

33

34

35

36

37

38

[Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]

[Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]

[Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum:

[Object Copy (ms): Min: 1.8, Avg: 1.9, Max: 1.9, Diff: 0.1, Sum: 5.6]

[Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]

[Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 3]

[GC Worker Other (ms): Min: 0.0, Avg: 0.2, Max: 0.6, Diff: 0.6, Sum:

[GC Worker Total (ms): Min: 2.4, Avg: 2.5, Max: 2.7, Diff: 0.3, Sum:

[GC Worker End (ms): Min: 381.4, Avg: 381.4, Max: 381.4, Diff: 0.0] [Code Root Fixup: 0.0 ms]

[Code Root Purge: 0.0 ms] [Clear CT: 0.0 ms] [Other: 0.2 ms]

[Choose CSet: 0.0 ms] [Ref Proc: 0.1 ms] [Ref Enq: 0.0 ms]

[Redirty Cards: 0.0 ms] [Humongous Register: 0.0 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 0.0 ms]

[Eden: 9216.0K(9216.0K)->0.0B(7168.0K) Survivors: 0.0B->2048.0K Heap:

9216.0K(192.0M)->1888.0K(192.0M)]

39

40 Heap after GC invocations=1 (full 0):

41 garbage-first heap total 196608K, used 1888K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)

- region size 1024K, 2 young (2048K), 2 survivors (2048K)
  - Metaspace used 3491K, capacity 4500K, committed 4864K, reserved 1056768K

44

45 class space used 381K, capacity 388K, committed 512K, reserved 1048576K 46 }

47

48 [Times: user=0.00 sys=0.00, real=0.00 secs]

49 {Heap before GC invocations=1 (full 0):

50 garbage-first heap total 196608K, used 9056K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)

51

52 region size 1024K, 9 young (9216K), 2 survivors (2048K)

53 Metaspace used 3492K, capacity 4500K, committed 4864K, reserved 1056768K

- class space used 381K, capacity 388K, committed 512K, reserved 1048576K 55 2018-09-24T23:06:02.310+0800: 0.458: [GC pause (G1 Evacuation Pause)

(young), 0.0070126 secs]

56

57 。。。。。。。。。。。。。。。。。。。

- 、GC Easy 可视化工具

GC Easy是一款在线的可视化工具，易用、功能强大，网站： http://gceasy.io/

上传后，点击“Analyze”按钮，即可查看报告。

s