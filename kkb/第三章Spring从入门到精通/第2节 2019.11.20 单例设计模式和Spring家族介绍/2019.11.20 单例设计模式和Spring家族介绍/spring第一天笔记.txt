课程主题
	单例设计模式&Spring家族介绍
	
课程目标
	1.掌握双重检查锁方式的单例模式
	2.了解并发编程中的原子性、有序性、可见性
	3.了解并发编程中的指令重排序
	4.了解Spring全家桶成员，重点是要分清楚每个成员的定位
	5.掌握Spring核心概念，比如IoC、DI、AoP、BoP
	6.了解Spring Framework（也就是我们常说的Spring）各个组件的作用
	7.了解Spring最高级接口BeanFactory的继承体系
	8.掌握Spring IoC模块是如何产生并管理Bean的
	
课程回顾
	1.简单工厂
		
	2.工厂方法
	
	3.抽象工厂
	
	4.原型模式
	
	5.构建者模式
	
	6.单例模式的静态内部类写法
	
课程内容
	1.单例模式的双重检查锁写法
		疑问？既然饿汉式已经是线程安全的了，为什么还要学习懒汉式呢？
		
		首先，是应付面试，可以通过懒汉式的写法去问一些并发编程的问题。
		其次，如果有很多对象，都需要使用单例模式去管理，那么不一定这些对象都会被使用到的，如果不使用，你就帮着创建好了
			那么会造成资源浪费。
			
		线程的执行是通过获取CPU时间片去执行的，等到CPU时间片使用完之后，线程会挂起。
		
		JVM中的对象创建过程是什么流程？
		
			Student student = new Student();// 高级语言
			
			a）new关键字会触发Student类的类加载（如果已加载，则此步骤作废）
			b）根据Class对象中的信息，去开辟相应大小的内存空间。
			c）初始化Student对象，就是完成成员变量的初始化操作（到这一步，我们才能说该对象是可用的）
			d）将开辟出来的内存空间地址，赋值给栈空间的变量student
		
			以上步骤，其实都是通过字节码指令去完成的。
			
			物理机器直接操作的都是CPU指令（原子性其实是相对我们CPU指令来说的）
			
			指令重排序（JIT即时编译器优化）
				有序性
					int x = 10;
					boolean flag = false;
					
					x ++;
					flag = true;
					
					如果两行代码的执行顺序交换之后，不会影响最终的程序执行结果，那么JIT即时编译器会根据情况去进行指令重排序。
				
					总结：如果程序之间没有依赖性，则可以进行指令重排序。
				
					happend-before先行发生原则（六大原则）
					
			分析创建对象的步骤中，c和d这两个步骤，有没有依赖性呢？
				答案是它们两者之间没有依赖性，那么就有可能发生指令重排序。也就是说有可能先执行d再执行c
				
			

			volatile关键字的作用：
				一个是禁止指令重排序。
				另一个作用是禁止使用CPU缓存。
				
				
			可见性
				在CPU单核时代，线程1和线程2使用的是同一个CPU缓存，所以线程之间的数据是可见的。
				在CPU多核时代，线程1在A核，线程2在B核，每个核都有自己的CPU缓存空间，
					如果线程1产生的数据缓存没有同步到线程2对应的CPU缓存，则会出现可见性问题。
					
				
				
	2.spring
		Spring全家桶
			Spring Framework
			Spring boot
			
			Spring Cloud	微服务架构
			Spring Data
			Spring Security
				
				
		核心概念
			IoC
				控制反转，创建对象的权利，由程序员反转给了Spring容器。
				
				IoC的实现，必须依赖DI，因为IoC只是负责对象的创建，而对象创建过程中需要将对象与对象的依赖进行实现。
				此时使用到的就是DI
			DI
				依赖注入
				它必须依赖于IoC
				
			AOP
				面向切面编程，主要解决的就是系统功能和业务功能之间的解耦。
				
				Spring容器可以去创建Bean实例，并且对Bean进行管理。被Spring容器管理的bean，还可以使用AOP进行功能增强。
				AOP是OOP的延续。它们都是编程思想。
				
				
			BOP
				Spring是面向Bean进行编程的，在Spring中，一切对象都是Bean。
		
		手写Spring IoC模块
			最终Spring IoC要实现的就是Bean的创建与管理。然后被Spring管理的Bean有很多，我们交给专业的Bean工厂来创建Bean。
		
			class BeanFactory{
				private Map<String,BeanDefinition> maps = xxx;
				
				
				public Object getBean(String beanName){
					//读取缓存
					//当从缓存中没有找到想要的bean对象，再去执行创建流程
					
						
					//创建流程（根据BeanDefinition对象去创建）	---	Bean实例对象
						//bean的实例化（调用构造方法new对象）
						//bean的属性填充（调用set方法设置属性）
						//bean的初始化（调用初始化方法，完成一些操作）
				}
				
				//BeanFactory初始化的时候，就应该去完成解析操作
				public void init(){
					//解析流程（xml配置文件或者注解）------BeanDefinition对象（封装了bean的定义信息，包括类路径、属性信息等）
				}
			
			}