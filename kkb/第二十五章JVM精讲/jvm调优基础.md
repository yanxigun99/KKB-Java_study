# 引⾔

本⽂通过理论加实践的⽅式逐步讲解JVM调优。共分四部分，第⼀部分：概述，主要讲解关于JVM 调优的理论概念知识；第⼆部分：JVM调优⼯具，主要讲述在调优过程中所使⽤的⼯具以及命令；第三 部分：JVM参数，主要讲述JVM主要调优参数；第四部分：案例分析，通过前三部分的理论基础结合真 实项⽬案例来看看如何进⾏调优。

# JVM调优基础

本章主要通过JVM基础、调优层次、调优指标、何时JVM调优、JVM调优⽬标、JVM调优原则以及JVM调优步骤介绍，以达到对JVM调优有个整体上的认识，后续通过具体的案例结合理论来看下如何进

⾏调优。

## 1 JVM基础

在讲JVM调优之前，先简单回顾下JVM相关的基础知识，这⾥我们重点回顾下JAVA堆、垃圾回收 器。这两块也是在JVM调优过程中重点关注的部分。

### 1.1 java堆

被所有线程共享，在虚拟机启动时创建，⽤来存放对象实例，⼏乎所有的对象实例都在这⾥分配内 存。对于⼤多数应⽤来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最⼤的⼀块。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的⻆度看，由于现在收集器 基本都是采⽤的分代收集算法，所以Java堆中还可以细分为：新⽣代和⽼年代；新⽣代⼜有Eden空间、From Survivor空间、To Survivor空间三部分。Java 堆不需要连续内存，并且可以通过动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。(下图是基于jdk1.7版本，jdk1.8永久代变换成元空间Metaspace)

### 1.2 垃圾回收

从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC，从年⽼代空间回收内存被称为 Major GC，Full GC 是清理整个堆空间—包括年轻代和⽼年代。这使得我们不⽤去关⼼到底是叫Major GC 还是 Full GC，⼤家应该关注当前的 GC 是否停⽌了所有应⽤程序的线程，还是能够并发的处理⽽不⽤停掉应⽤程序的线程。（Stop-the-world STW）

在 JVM 中，具体实现有 串⾏收集器(Serial)、新⽣代并⾏收集器(ParNew)、并⾏回收(Parallel Scavenge)、CMS(Concurrent Mark Sweep)、Serial Old（Serial收集器的⽼年代版本）、Parallel Old(Parallel Scavenge收集器的⽼年代版本)、G1 等。具体的使⽤原则在后⾯的JVM调优原则详细介绍。

## 2 调优层次

性能调优包含多个层次，⽐如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。 架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最⼤的。

## 3 调优指标

### 3.1 吞吐量

重要指标之⼀，吞吐量是衡量系统在单位时间⾥⾯完成的⼯作数量。吞吐量需求通常忽略延迟或者 响应时间。通常情况下，提升吞吐量需要以系统响应变慢和更多内存消耗作为代价。

⼀个吞吐量的例⼦：“这个应⽤需要每秒完成2500个事务。”

### 3.2 延迟或响应时间

延迟或者响应时间是衡量应⽤从接收到⼀个任务到完成这个任务消耗的时间。⼀个延迟或者响应时 间的需求需要忽略吞吐量。通常来讲，提升应⽤的响应时间需要以更低吞吐量或提⾼应⽤的内容消耗。

⼀个延迟或者响应时间的例⼦:"例如系统处理⼀个HTTP请求需要200ms，这个200ms就是系统的 响应时间。"

### 3.3 内存占⽤

内存占⽤是衡量应⽤消耗的内存，这个内存占⽤是指应⽤在运⾏在某⼀个吞吐量、延迟以及可⽤性 和易管理性指标下的内存消耗，内存占⽤是通常描述为应⽤运⾏的时候Java堆的⼤⼩或者总共需要消耗 内存。通常情况下，通过增加Java堆的⼤⼩以增加应⽤内存占⽤可以提升吞吐量或者减少延迟，或者两 者兼具。当应⽤可⽤的内存减少的时候，吞吐量和延迟通常会受到损失。在给定内存的情况下，应⽤占

⽤的内存可以限制应⽤的实例数（这个会影响可⽤性）。

⼀个例⼦说明内存占⽤的需求是：“这个应⽤会单独运⾏在⼀个8G的系统上⾯或者多出3个应⽤实例 运⾏在⼀个24G的应⽤系统上⾯。”

## 4 何时JVM调优

遇到以下情况，就需要考虑进⾏JVM调优： 系统吞吐量与响应性能不⾼或下降；

Heap内存（⽼年代）持续上涨达到设置的最⼤内存值；

Full GC 次数频繁；

GC 停顿时间过⻓（超过1秒）；

应⽤出现OutOfMemory 等内存异常；

应⽤中有使⽤本地缓存且占⽤⼤量内存空间；

## 5 JVM调优⽬标

调优的最终⽬的都是为了应⽤程序使⽤最⼩的硬件消耗来承载更⼤的吞吐量。jvm调优主要是针对 垃圾收集器的收集性能优化，减少GC的频率和Full GC的次数，令运⾏在虚拟机上的应⽤能够使⽤更少的内存以及延迟获取更⼤的吞吐量和减少暂停时间。

下⾯展示了⼀些JVM调优的量化⽬标参考实例，注意：不同应⽤的JVM调优量化⽬标是不⼀样的。 堆内存使⽤率 <= 70%;

⽼年代内存使⽤率<= 70%;

avgpause <= 1秒;

Full GC 次数0 或 avg pause interval >= 24⼩时 ;

## 6 JVM调优原则

### 6.1 优先原则

优先架构调优和代码调优，JVM优化是不得已的⼿段，⼤多数的Java应⽤不需要进⾏JVM优化

### 6.2 堆设置

参数-Xms和-Xmx，通常设置为相同的值，避免运⾏时要不断扩展JVM内存，建议扩⼤⾄3-4倍

FullGC后的⽼年代空间占⽤。

### 6.3 垃圾回收器设置

有 7 种不同的垃圾回收器，它们分别⽤于不同分代的垃圾回收。新⽣代回收器：Serial、ParNew、Parallel Scavenge

⽼年代回收器：Serial Old、Parallel Old、CMS

整堆回收器：G1

两个垃圾回收器之间有连线表示它们可以搭配使⽤，可选的搭配⽅案如下：

**新⽣代**

**⽼年代**

Serial

Serial Old

Serial

CMS

ParNew

Serial Old

ParNew

CMS

Parallel Scavenge

Serial Old

Parallel Scavenge

Parallel Old

G1

G1

### 6.4 年轻代设置

参数-Xmn，1-1.5倍FullGC之后的⽼年代空间占⽤。

避免新⽣代设置过⼩，当新⽣代设置过⼩时，会产⽣两种⽐较明显的现象，⼀是minor GC次数频繁，⼆是可能导致 minor GC对象直接进⼊⽼年代。当⽼年代内存不⾜时，会触发Full GC。

避免新⽣代设置过⼤，当新⽣代设置过⼤时，会带来两个问题：⼀是⽼年⼤变⼩，可能导致Full GC频繁执⾏；⼆是 minor GC 执⾏回收的时间⼤幅度增加。

### 6.5 年⽼代设置

响应时间优先的应⽤：年⽼代使⽤并发收集器，所以其⼤⼩需要⼩⼼设置，⼀般要考虑并发会话率 和会话持续时间等⼀些参数。如果堆设置⼩了，可以会造成内存碎⽚、⾼回收频率以及应⽤暂停⽽使⽤ 传统的标记清除⽅式；如果堆⼤了，则需要较⻓的收集时间。

吞吐量优先的应⽤：⼀般吞吐量优先的应⽤都有⼀个很⼤的年轻代和⼀个较⼩的年⽼代。原因是， 这样可以尽可能回收掉⼤部分短期对象，减少中期的对象，⽽年⽼代尽存放⻓期存活对象

### 6.6 永久代设置

基 于 jdk1.7 版 本 ， 参 数 -XX:PermSize 和 -XX:MaxPermSize， 基 于 jdk1.8 版 本 ， 参 数 - XX:MetaspaceSize和-XX:MaxMetaspaceSize，通常设置为相同的值，避免运⾏时要不断扩展，建议扩

⼤⾄1.2-1.5倍FullGc后的永久带空间占⽤。

## 7 JVM调优步骤

### 7.1 监控分析

分析GC⽇志及dump⽂件，判断是否需要优化，确定瓶颈问题点。监控JVM的状况，可以使⽤阿⾥ 新开源的arthas，或者jconsole等⼯具查看运⾏状态。更多⼯具介绍将在后⾯详细介绍。

**如何⽣成\****GC***\*⽇志**

开启GC⽇志，多种⽅法都能开启GC的⽇志功能，其中包括：使⽤-verbose:gc或-XX:+PrintGC这两 个标志中的任意⼀个能创建基本的GC⽇志（这两个⽇志标志实际上互为别名，默认情况下的GC⽇志功 能是关闭的）使⽤-XX:+PrintGCDetails标志会创建更详细的GC⽇志，推荐使⽤-XX:+PrintGCDetails标 志（这个标志默认情况下也是关闭的）；通常情况下使⽤基本的GC⽇志很难诊断垃圾回收时发⽣的问题。

**如何产⽣\****dump***\*⽂件**1.JVM的配置⽂件中配置JVM启动时增加两个参数:

2.jmap⽣成

发现程序异常前通过执⾏指令，直接⽣成当前JVM的dump⽂件，9257是指JVM的进程号

jmap -dump:ﬁle=⽂件名.dump [pid]

由于第⼀种⽅式是⼀种事后⽅式，需要等待当前JVM出现问题后才能⽣成dump⽂件，实时性不

⾼，第⼆种⽅式在执⾏时，JVM是暂停服务的，所以对线上的运⾏会产⽣影响。所以建议第⼀种⽅式。

### 7.2 判断

如果各项参数设置合理，系统没有超时⽇志出现，GC频率不⾼，GC耗时不⾼，那么没有必要进⾏

GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。

### 7.3 确定⽬标

- ***\*调整参数\****

调优⼀般是从满⾜程序的内存使⽤需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求， 要基于这个步骤来不断优化，每⼀个步骤都是进⾏下⼀步的基础，不可逆⾏之。具体的参数我们在后⾯ 详细介绍。

### 7.5 对⽐调优前后指标差异

- ***\*重复以上过程\****

### 7.7 应⽤

找到最合适的参数，将这些参数应⽤到所有服务器，并进⾏后续跟踪。